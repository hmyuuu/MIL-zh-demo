<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.0, mkdocs-material-9.5.31"><title>S01 Implication and the Universal Quantifier - MIL</title><link rel=stylesheet href=../../../assets/stylesheets/main.3cba04c6.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../assets/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent=light-green> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#implication-and-the-universal-quantifier class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <div data-md-color-scheme=default data-md-component=outdated hidden> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=MIL class="md-header__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> MIL </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> S01 Implication and the Universal Quantifier </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../en/ class=md-tabs__link> 目录 </a> </li> <li class=md-tabs__item> <a href=../../../en/C01_Introduction/ class=md-tabs__link> Introduction </a> </li> <li class=md-tabs__item> <a href=../../../en/C02_Basics/ class=md-tabs__link> Basics </a> </li> <li class=md-tabs__item> <a href=../../../en/C03_Logic/ class=md-tabs__link> Logic </a> </li> <li class=md-tabs__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-tabs__link> Sets and Functions </a> </li> <li class=md-tabs__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-tabs__link> Elementary Number Theory </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=MIL class="md-nav__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> MIL </label> <div class=md-nav__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../en/ class=md-nav__link> <span class=md-ellipsis> 目录 </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C01_Introduction/ class=md-nav__link> <span class=md-ellipsis> Introduction </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C02_Basics/ class=md-nav__link> <span class=md-ellipsis> Basics </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C03_Logic/ class=md-nav__link> <span class=md-ellipsis> Logic </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-nav__link> <span class=md-ellipsis> Sets and Functions </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-nav__link> <span class=md-ellipsis> Elementary Number Theory </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#implication-and-the-universal-quantifier class=md-nav__link> <span class=md-ellipsis> Implication and the Universal Quantifier </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1>S01 Implication and the Universal Quantifier</h1> <h2 id=implication-and-the-universal-quantifier>Implication and the Universal Quantifier<a class=headerlink href=#implication-and-the-universal-quantifier title="Permanent link">&para;</a></h2> <p>Consider the statement after the <code>#check</code>:</p> <div class=highlight><pre><span></span><code><span class=k>#check</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>,</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=bp>|</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span>
</code></pre></div> <p>In words, we would say "for every real number <code>x</code>, if <code>0 ≤ x</code> then the absolute value of <code>x</code> equals <code>x</code>". We can also have more complicated statements like:</p> <div class=highlight><pre><span></span><code><span class=k>#check</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>,</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>y</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>y</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span>
</code></pre></div> <p>In words, we would say "for every <code>x</code>, <code>y</code>, and <code>ε</code>, if <code>0 &lt; ε ≤ 1</code>, the absolute value of <code>x</code> is less than <code>ε</code>, and the absolute value of <code>y</code> is less than <code>ε</code>, then the absolute value of <code>x * y</code> is less than <code>ε</code>." In Lean, in a sequence of implications there are implicit parentheses grouped to the right. So the expression above means "if <code>0 &lt; ε</code> then if <code>ε ≤ 1</code> then if <code>|x| &lt; ε</code> ..." As a result, the expression says that all the assumptions together imply the conclusion.</p> <p>You have already seen that even though the universal quantifier in this statement ranges over objects and the implication arrows introduce hypotheses, Lean treats the two in very similar ways. In particular, if you have proved a theorem of that form, you can apply it to objects and hypotheses in the same way. We will use as an example the following statement that we will help you to prove a bit later:</p> <div class=highlight><pre><span></span><code><span class=kd>theorem</span><span class=w> </span><span class=n>my_lemma</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>,</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>y</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>y</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=gr>sorry</span>

<span class=kn>section</span>
<span class=kd>variable</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>δ</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span>
<span class=kd>variable</span><span class=w> </span><span class=o>(</span><span class=n>h₀</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>δ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h₁</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>δ</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>1</span><span class=o>)</span>
<span class=kd>variable</span><span class=w> </span><span class=o>(</span><span class=n>ha</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>|</span><span class=n>a</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>δ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hb</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>|</span><span class=n>b</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>δ</span><span class=o>)</span>

<span class=k>#check</span><span class=w> </span><span class=n>my_lemma</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>δ</span>
<span class=k>#check</span><span class=w> </span><span class=n>my_lemma</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>δ</span><span class=w> </span><span class=n>h₀</span><span class=w> </span><span class=n>h₁</span>
<span class=k>#check</span><span class=w> </span><span class=n>my_lemma</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>δ</span><span class=w> </span><span class=n>h₀</span><span class=w> </span><span class=n>h₁</span><span class=w> </span><span class=n>ha</span><span class=w> </span><span class=n>hb</span>

<span class=kd>end</span>
</code></pre></div> <p>You have also already seen that it is common in Lean to use curly brackets to make quantified variables implicit when they can be inferred from subsequent hypotheses. When we do that, we can just apply a lemma to the hypotheses without mentioning the objects.</p> <div class=highlight><pre><span></span><code><span class=kd>theorem</span><span class=w> </span><span class=n>my_lemma2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=o>{</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>},</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>y</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>y</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=gr>sorry</span>

<span class=kn>section</span>
<span class=kd>variable</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>δ</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span>
<span class=kd>variable</span><span class=w> </span><span class=o>(</span><span class=n>h₀</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>δ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h₁</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>δ</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>1</span><span class=o>)</span>
<span class=kd>variable</span><span class=w> </span><span class=o>(</span><span class=n>ha</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>|</span><span class=n>a</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>δ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hb</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>|</span><span class=n>b</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>δ</span><span class=o>)</span>

<span class=k>#check</span><span class=w> </span><span class=n>my_lemma2</span><span class=w> </span><span class=n>h₀</span><span class=w> </span><span class=n>h₁</span><span class=w> </span><span class=n>ha</span><span class=w> </span><span class=n>hb</span>

<span class=kd>end</span>
</code></pre></div> <p>At this stage, you also know that if you use the <code>apply</code> tactic to apply <code>my_lemma</code> to a goal of the form <code>|a * b| &lt; δ</code>, you are left with new goals that require you to prove each of the hypotheses.</p> <p>To prove a statement like this, use the <code>intro</code> tactic. Take a look at what it does in this example:</p> <div class=highlight><pre><span></span><code><span class=kd>theorem</span><span class=w> </span><span class=n>my_lemma3</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=bp>∀</span><span class=w> </span><span class=o>{</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>},</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>y</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>y</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>intro</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=n>epos</span><span class=w> </span><span class=n>ele1</span><span class=w> </span><span class=n>xlt</span><span class=w> </span><span class=n>ylt</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <p>We can use any names we want for the universally quantified variables; they do not have to be <code>x</code>, <code>y</code>, and <code>ε</code>. Notice that we have to introduce the variables even though they are marked implicit: making them implicit means that we leave them out when we write an expression <em>using</em> <code>my_lemma</code>, but they are still an essential part of the statement that we are proving. After the <code>intro</code> command, the goal is what it would have been at the start if we listed all the variables and hypotheses <em>before</em> the colon, as we did in the last section. In a moment, we will see why it is sometimes necessary to introduce variables and hypotheses after the proof begins.</p> <p>To help you prove the lemma, we will start you off:</p> <div class=highlight><pre><span></span><code><span class=kd>theorem</span><span class=w> </span><span class=n>my_lemma4</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=bp>∀</span><span class=w> </span><span class=o>{</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>},</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>y</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>y</span><span class=bp>|</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>intro</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=n>epos</span><span class=w> </span><span class=n>ele1</span><span class=w> </span><span class=n>xlt</span><span class=w> </span><span class=n>ylt</span>
<span class=w>  </span><span class=k>calc</span>
<span class=w>    </span><span class=bp>|</span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>y</span><span class=bp>|</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=bp>|</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=bp>|</span><span class=n>y</span><span class=bp>|</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span>
<span class=w>    </span><span class=n>_</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=bp>|</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span>
<span class=w>    </span><span class=n>_</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span>
<span class=w>    </span><span class=n>_</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span>
</code></pre></div> <p>Finish the proof using the theorems <code>abs_mul</code>, <code>mul_le_mul</code>, <code>abs_nonneg</code>, <code>mul_lt_mul_right</code>, and <code>one_mul</code>. Remember that you can find theorems like these using Ctrl-space completion (or Cmd-space completion on a Mac). Remember also that you can use <code>.mp</code> and <code>.mpr</code> or <code>.1</code> and <code>.2</code> to extract the two directions of an if-and-only-if statement.</p> <p>Universal quantifiers are often hidden in definitions, and Lean will unfold definitions to expose them when necessary. For example, let's define two predicates, <code>FnUb f a</code> and <code>FnLb f a</code>, where <code>f</code> is a function from the real numbers to the real numbers and <code>a</code> is a real number. The first says that <code>a</code> is an upper bound on the values of <code>f</code>, and the second says that <code>a</code> is a lower bound on the values of <code>f</code>.</p> <div class=highlight><pre><span></span><code><span class=kd>def</span><span class=w> </span><span class=n>FnUb</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=bp>∀</span><span class=w> </span><span class=n>x</span><span class=o>,</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>a</span>

<span class=kd>def</span><span class=w> </span><span class=n>FnLb</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=bp>∀</span><span class=w> </span><span class=n>x</span><span class=o>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span>
</code></pre></div> <p>In the next example, <code>fun x ↦ f x + g x</code> is the function that maps <code>x</code> to <code>f x + g x</code>. Going from the expression <code>f x + g x</code> to this function is called a lambda abstraction in type theory.</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>hfa</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnUb</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hgb</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnUb</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnUb</span><span class=w> </span><span class=o>(</span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>intro</span><span class=w> </span><span class=n>x</span>
<span class=w>  </span><span class=n>dsimp</span>
<span class=w>  </span><span class=n>apply</span><span class=w> </span><span class=n>add_le_add</span>
<span class=w>  </span><span class=n>apply</span><span class=w> </span><span class=n>hfa</span>
<span class=w>  </span><span class=n>apply</span><span class=w> </span><span class=n>hgb</span>
</code></pre></div> <p>Applying <code>intro</code> to the goal <code>FnUb (fun x ↦ f x + g x) (a + b)</code> forces Lean to unfold the definition of <code>FnUb</code> and introduce <code>x</code> for the universal quantifier. The goal is then <code>(fun (x : ℝ) ↦ f x + g x) x ≤ a + b</code>. But applying <code>(fun x ↦ f x + g x)</code> to <code>x</code> should result in <code>f x + g x</code>, and the <code>dsimp</code> command performs that simplification. (The "d" stands for "definitional.") You can delete that command and the proof still works; Lean would have to perform that contraction anyhow to make sense of the next <code>apply</code>. The <code>dsimp</code> command simply makes the goal more readable and helps us figure out what to do next. Another option is to use the <code>change</code> tactic by writing <code>change f x + g x ≤ a + b</code>. This helps make the proof more readable, and gives you more control over how the goal is transformed.</p> <p>The rest of the proof is routine. The last two <code>apply</code> commands force Lean to unfold the definitions of <code>FnUb</code> in the hypotheses. Try carrying out similar proofs of these:</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>hfa</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnLb</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hgb</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnLb</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnLb</span><span class=w> </span><span class=o>(</span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=gr>sorry</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>nnf</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnLb</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>nng</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnLb</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnLb</span><span class=w> </span><span class=o>(</span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=gr>sorry</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>hfa</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnUb</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hgb</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnUb</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>nng</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnLb</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>nna</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>FnUb</span><span class=w> </span><span class=o>(</span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <p>Even though we have defined <code>FnUb</code> and <code>FnLb</code> for functions from the reals to the reals, you should recognize that the definitions and proofs are much more general. The definitions make sense for functions between any two types for which there is a notion of order on the codomain. Checking the type of the theorem <code>add_le_add</code> shows that it holds of any structure that is an "ordered additive commutative monoid"; the details of what that means don't matter now, but it is worth knowing that the natural numbers, integers, rationals, and real numbers are all instances. So if we prove the theorem <code>fnUb_add</code> at that level of generality, it will apply in all these instances.</p> <div class=highlight><pre><span></span><code><span class=kd>variable</span><span class=w> </span><span class=o>{</span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=bp>*</span><span class=o>}</span><span class=w> </span><span class=o>{</span><span class=n>R</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=bp>*</span><span class=o>}</span><span class=w> </span><span class=o>[</span><span class=n>OrderedCancelAddCommMonoid</span><span class=w> </span><span class=n>R</span><span class=o>]</span>

<span class=k>#check</span><span class=w> </span><span class=n>add_le_add</span>

<span class=kd>def</span><span class=w> </span><span class=n>FnUb&#39;</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>R</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>R</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=bp>∀</span><span class=w> </span><span class=n>x</span><span class=o>,</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>a</span>

<span class=kd>theorem</span><span class=w> </span><span class=n>fnUb_add</span><span class=w> </span><span class=o>{</span><span class=n>f</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>R</span><span class=o>}</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>R</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>hfa</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnUb&#39;</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hgb</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnUb&#39;</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>FnUb&#39;</span><span class=w> </span><span class=o>(</span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>add_le_add</span><span class=w> </span><span class=o>(</span><span class=n>hfa</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hgb</span><span class=w> </span><span class=n>x</span><span class=o>)</span>
</code></pre></div> <p>You have already seen square brackets like these in Section :numref:<code>proving_identities_in_algebraic_structures</code>, though we still haven't explained what they mean. For concreteness, we will stick to the real numbers for most of our examples, but it is worth knowing that Mathlib contains definitions and theorems that work at a high level of generality.</p> <p>For another example of a hidden universal quantifier, Mathlib defines a predicate <code>Monotone</code>, which says that a function is nondecreasing in its arguments:</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Monotone</span><span class=w> </span><span class=n>f</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=o>},</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=bp>@</span><span class=n>h</span>
</code></pre></div> <p>The property <code>Monotone f</code> is defined to be exactly the expression after the colon. We need to put the <code>@</code> symbol before <code>h</code> because if we don't, Lean expands the implicit arguments to <code>h</code> and inserts placeholders.</p> <p>Proving statements about monotonicity involves using <code>intro</code> to introduce two variables, say, <code>a</code> and <code>b</code>, and the hypothesis <code>a ≤ b</code>. To <em>use</em> a monotonicity hypothesis, you can apply it to suitable arguments and hypotheses, and then apply the resulting expression to the goal. Or you can apply it to the goal and let Lean help you work backwards by displaying the remaining hypotheses as new subgoals.</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>mf</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Monotone</span><span class=w> </span><span class=n>f</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>mg</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Monotone</span><span class=w> </span><span class=n>g</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Monotone</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>intro</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>aleb</span>
<span class=w>  </span><span class=n>apply</span><span class=w> </span><span class=n>add_le_add</span>
<span class=w>  </span><span class=n>apply</span><span class=w> </span><span class=n>mf</span><span class=w> </span><span class=n>aleb</span>
<span class=w>  </span><span class=n>apply</span><span class=w> </span><span class=n>mg</span><span class=w> </span><span class=n>aleb</span>
</code></pre></div> <p>When a proof is this short, it is often convenient to give a proof term instead. To describe a proof that temporarily introduces objects <code>a</code> and <code>b</code> and a hypothesis <code>aleb</code>, Lean uses the notation <code>fun a b aleb ↦ ...</code>. This is analogous to the way that an expression like <code>fun x ↦ x^2</code> describes a function by temporarily naming an object, <code>x</code>, and then using it to describe a value. So the <code>intro</code> command in the previous proof corresponds to the lambda abstraction in the next proof term. The <code>apply</code> commands then correspond to building the application of the theorem to its arguments.</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>mf</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Monotone</span><span class=w> </span><span class=n>f</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>mg</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Monotone</span><span class=w> </span><span class=n>g</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Monotone</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=k>fun</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>aleb</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>add_le_add</span><span class=w> </span><span class=o>(</span><span class=n>mf</span><span class=w> </span><span class=n>aleb</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>mg</span><span class=w> </span><span class=n>aleb</span><span class=o>)</span>
</code></pre></div> <p>Here is a useful trick: if you start writing the proof term <code>fun a b aleb ↦ _</code> using an underscore where the rest of the expression should go, Lean will flag an error, indicating that it can't guess the value of that expression. If you check the Lean Goal window in VS Code or hover over the squiggly error marker, Lean will show you the goal that the remaining expression has to solve.</p> <p>Try proving these, with either tactics or proof terms:</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>c</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>mf</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Monotone</span><span class=w> </span><span class=n>f</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>nnc</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>c</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Monotone</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=gr>sorry</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>mf</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Monotone</span><span class=w> </span><span class=n>f</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>mg</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Monotone</span><span class=w> </span><span class=n>g</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Monotone</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>(</span><span class=n>g</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <p>Here are some more examples. A function :math:<code>f</code> from <span class=arithmatex>\(\mathbb{R}\)</span> to <span class=arithmatex>\(\mathbb{R}\)</span> is said to be <em>even</em> if <span class=arithmatex>\(f(-x) = f(x)\)</span> for every <span class=arithmatex>\(x\)</span>, and <em>odd</em> if <span class=arithmatex>\(f(-x) = -f(x)\)</span> for every <span class=arithmatex>\(x\)</span>. The following example defines these two notions formally and establishes one fact about them. You can complete the proofs of the others.</p> <div class=highlight><pre><span></span><code><span class=kd>def</span><span class=w> </span><span class=n>FnEven</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=bp>∀</span><span class=w> </span><span class=n>x</span><span class=o>,</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>(</span><span class=bp>-</span><span class=n>x</span><span class=o>)</span>

<span class=kd>def</span><span class=w> </span><span class=n>FnOdd</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=bp>∀</span><span class=w> </span><span class=n>x</span><span class=o>,</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=bp>-</span><span class=n>f</span><span class=w> </span><span class=o>(</span><span class=bp>-</span><span class=n>x</span><span class=o>)</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>ef</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnEven</span><span class=w> </span><span class=n>f</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>eg</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnEven</span><span class=w> </span><span class=n>g</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnEven</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>intro</span><span class=w> </span><span class=n>x</span>
<span class=w>  </span><span class=k>calc</span>
<span class=w>    </span><span class=o>(</span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>rfl</span>
<span class=w>    </span><span class=n>_</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>(</span><span class=bp>-</span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=o>(</span><span class=bp>-</span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>rw</span><span class=w> </span><span class=o>[</span><span class=n>ef</span><span class=o>,</span><span class=w> </span><span class=n>eg</span><span class=o>]</span>


<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>of</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnOdd</span><span class=w> </span><span class=n>f</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>og</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnOdd</span><span class=w> </span><span class=n>g</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnEven</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=gr>sorry</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>ef</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnEven</span><span class=w> </span><span class=n>f</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>og</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnOdd</span><span class=w> </span><span class=n>g</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnOdd</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=gr>sorry</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>ef</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnEven</span><span class=w> </span><span class=n>f</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>og</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnOdd</span><span class=w> </span><span class=n>g</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>FnEven</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>(</span><span class=n>g</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <p>The first proof can be shortened using <code>dsimp</code> or <code>change</code> to get rid of the lambda abstraction. But you can check that the subsequent <code>rw</code> won't work unless we get rid of the lambda abstraction explicitly, because otherwise it cannot find the patterns <code>f x</code> and <code>g x</code> in the expression. Contrary to some other tactics, <code>rw</code> operates on the syntactic level, it won't unfold definitions or apply reductions for you (it has a variant called <code>erw</code> that tries a little harder in this direction, but not much harder).</p> <p>You can find implicit universal quantifiers all over the place, once you know how to spot them.</p> <p>Mathlib includes a good library for manipulating sets. Recall that Lean does not use foundations based on set theory, so here the word set has its mundane meaning of a collection of mathematical objects of some given type <code>α</code>. If <code>x</code> has type <code>α</code> and <code>s</code> has type <code>Set α</code>, then <code>x ∈ s</code> is a proposition that asserts that <code>x</code> is an element of <code>s</code>. If <code>y</code> has some different type <code>β</code> then the expression <code>y ∈ s</code> makes no sense. Here "makes no sense" means "has no type hence Lean does not accept it as a well-formed statement". This contrasts with Zermelo-Fraenkel set theory for instance where <code>a ∈ b</code> is a well-formed statement for every mathematical objects <code>a</code> and <code>b</code>. For instance <code>sin ∈ cos</code> is a well-formed statement in ZF. This defect of set theoretic foundations is an important motivation for not using it in a proof assistant which is meant to assist us by detecting meaningless expressions. In Lean <code>sin</code> has type <code>ℝ → ℝ</code> and <code>cos</code> has type <code>ℝ → ℝ</code> which is not equal to <code>Set (ℝ → ℝ)</code>, even after unfolding definitions, so the statement <code>sin ∈ cos</code> makes no sense. One can also use Lean to work on set theory itself. For instance the independence of the continuum hypothesis from the axioms of Zermelo-Fraenkel has been formalized in Lean. But such a meta-theory of set theory is completely beyond the scope of this book.</p> <p>If <code>s</code> and <code>t</code> are of type <code>Set α</code>, then the subset relation <code>s ⊆ t</code> is defined to mean <code>∀ {x : α}, x ∈ s → x ∈ t</code>. The variable in the quantifier is marked implicit so that given <code>h : s ⊆ t</code> and <code>h' : x ∈ s</code>, we can write <code>h h'</code> as justification for <code>x ∈ t</code>. The following example provides a tactic proof and a proof term justifying the reflexivity of the subset relation, and asks you to do the same for transitivity.</p> <div class=highlight><pre><span></span><code><span class=kd>variable</span><span class=w> </span><span class=o>{</span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=bp>*</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>r</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Set</span><span class=w> </span><span class=n>α</span><span class=o>)</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=bp>⊆</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>intro</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>xs</span>
<span class=w>  </span><span class=n>exact</span><span class=w> </span><span class=n>xs</span>

<span class=kd>theorem</span><span class=w> </span><span class=n>Subset.refl</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=bp>⊆</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>xs</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>xs</span>

<span class=kd>theorem</span><span class=w> </span><span class=n>Subset.trans</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=bp>⊆</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=bp>⊆</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=bp>⊆</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <p>Just as we defined <code>FnUb</code> for functions, we can define <code>SetUb s a</code> to mean that <code>a</code> is an upper bound on the set <code>s</code>, assuming <code>s</code> is a set of elements of some type that has an order associated with it. In the next example, we ask you to prove that if <code>a</code> is a bound on <code>s</code> and <code>a ≤ b</code>, then <code>b</code> is a bound on <code>s</code> as well.</p> <div class=highlight><pre><span></span><code><span class=kd>variable</span><span class=w> </span><span class=o>{</span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=bp>*</span><span class=o>}</span><span class=w> </span><span class=o>[</span><span class=n>PartialOrder</span><span class=w> </span><span class=n>α</span><span class=o>]</span>
<span class=kd>variable</span><span class=w> </span><span class=o>(</span><span class=n>s</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Set</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span>

<span class=kd>def</span><span class=w> </span><span class=n>SetUb</span><span class=w> </span><span class=o>(</span><span class=n>s</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Set</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=bp>∀</span><span class=w> </span><span class=n>x</span><span class=o>,</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>∈</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>a</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>SetUb</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h&#39;</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>SetUb</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:=</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <p>We close this section with one last important example. A function :math:<code>f</code> is said to be <em>injective</em> if for every :math:<code>x_1</code> and :math:<code>x_2</code>, if :math:<code>f(x_1) = f(x_2)</code> then :math:<code>x_1 = x_2</code>. Mathlib defines <code>Function.Injective f</code> with <code>x₁</code> and <code>x₂</code> implicit. The next example shows that, on the real numbers, any function that adds a constant is injective. We then ask you to show that multiplication by a nonzero constant is also injective, using the lemma name in the example as a source of inspiration. Recall you should use Ctrl-space completion after guessing the beginning of a lemma name.</p> <div class=highlight><pre><span></span><code><span class=kn>open</span><span class=w> </span><span class=n>Function</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>c</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Injective</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>intro</span><span class=w> </span><span class=n>x₁</span><span class=w> </span><span class=n>x₂</span><span class=w> </span><span class=n>h&#39;</span>
<span class=w>  </span><span class=n>exact</span><span class=w> </span><span class=o>(</span><span class=n>add_left_inj</span><span class=w> </span><span class=n>c</span><span class=o>)</span><span class=bp>.</span><span class=n>mp</span><span class=w> </span><span class=n>h&#39;</span>

<span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>c</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>≠</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Injective</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <p>Finally, show that the composition of two injective functions is injective:</p> <div class=highlight><pre><span></span><code><span class=kd>variable</span><span class=w> </span><span class=o>{</span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=bp>*</span><span class=o>}</span><span class=w> </span><span class=o>{</span><span class=n>β</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=bp>*</span><span class=o>}</span><span class=w> </span><span class=o>{</span><span class=n>γ</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=bp>*</span><span class=o>}</span>
<span class=kd>variable</span><span class=w> </span><span class=o>{</span><span class=n>g</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>β</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>γ</span><span class=o>}</span><span class=w> </span><span class=o>{</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>β</span><span class=o>}</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>injg</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Injective</span><span class=w> </span><span class=n>g</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>injf</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Injective</span><span class=w> </span><span class=n>f</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Injective</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>↦</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.sections", "navigation.instant", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"alias": true, "default": "latest", "provider": "mike"}}</script> <script src=../../../assets/javascripts/bundle.fe8b6f2b.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>