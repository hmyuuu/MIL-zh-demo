<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.0, mkdocs-material-9.5.31"><title>S01 Basics - MIL</title><link rel=stylesheet href=../../../assets/stylesheets/main.3cba04c6.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../assets/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent=light-green> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#basics class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <div data-md-color-scheme=default data-md-component=outdated hidden> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=MIL class="md-header__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> MIL </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> S01 Basics </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../en/ class=md-tabs__link> 目录 </a> </li> <li class=md-tabs__item> <a href=../../../en/C01_Introduction/ class=md-tabs__link> Introduction </a> </li> <li class=md-tabs__item> <a href=../../../en/C02_Basics/ class=md-tabs__link> Basics </a> </li> <li class=md-tabs__item> <a href=../../../en/C03_Logic/ class=md-tabs__link> Logic </a> </li> <li class=md-tabs__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-tabs__link> Sets and Functions </a> </li> <li class=md-tabs__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-tabs__link> Elementary Number Theory </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=MIL class="md-nav__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> MIL </label> <div class=md-nav__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../en/ class=md-nav__link> <span class=md-ellipsis> 目录 </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C01_Introduction/ class=md-nav__link> <span class=md-ellipsis> Introduction </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C02_Basics/ class=md-nav__link> <span class=md-ellipsis> Basics </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C03_Logic/ class=md-nav__link> <span class=md-ellipsis> Logic </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-nav__link> <span class=md-ellipsis> Sets and Functions </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-nav__link> <span class=md-ellipsis> Elementary Number Theory </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#basics class=md-nav__link> <span class=md-ellipsis> Basics </span> </a> </li> <li class=md-nav__item> <a href=#check-one1one-one1one-type-self-one1 class=md-nav__link> <span class=md-ellipsis> check One₁.one -- One₁.one {α : Type} [self : One₁ α] : α </span> </a> </li> <li class=md-nav__item> <a href=#check-one2one class=md-nav__link> <span class=md-ellipsis> check One₂.one </span> </a> </li> <li class=md-nav__item> <a href=#check-monoid2mk class=md-nav__link> <span class=md-ellipsis> check Monoid₂.mk </span> </a> </li> <li class=md-nav__item> <a href=#check-monoid1mk class=md-nav__link> <span class=md-ellipsis> check Monoid₁.mk </span> </a> </li> <li class=md-nav__item> <a href=#check-monoid1tosemigroup1 class=md-nav__link> <span class=md-ellipsis> check Monoid₁.toSemigroup₁ </span> </a> </li> <li class=md-nav__item> <a href=#check-monoid1todiaoneclass1 class=md-nav__link> <span class=md-ellipsis> check Monoid₁.toDiaOneClass₁ </span> </a> </li> <li class=md-nav__item> <a href=#check-left_neg_eq_right_neg class=md-nav__link> <span class=md-ellipsis> check left_neg_eq_right_neg' </span> </a> </li> <li class=md-nav__item> <a href=#synth-module1-z-z-abgrpmodule-z class=md-nav__link> <span class=md-ellipsis> synth Module₁ ℤ ℤ -- abGrpModule ℤ </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <p>import MIL.Common import Mathlib.Algebra.BigOperators.Ring import Mathlib.Data.Real.Basic</p> <p>set_option autoImplicit true</p> <p>/- TEXT: .. _section_hierarchies_basics:</p> <h2 id=basics>Basics<a class=headerlink href=#basics title="Permanent link">&para;</a></h2> <p>At the very bottom of all hierarchies in Lean, we find data-carrying classes. The following class records that the given type <code>α</code> is endowed with a distinguished element called <code>one</code>. At this stage, it has no property at all. BOTH: -/</p> <p>-- QUOTE: class One₁ (α : Type) where /-- The element one -/ one : α -- QUOTE.</p> <p>/- TEXT: Since we'll make a much heavier use of classes in this chapter, we need to understand some more details about what the <code>class</code> command is doing. First, the <code>class</code> command above defines a structure <code>One₁</code> with parameter <code>α : Type</code> and a single field <code>one</code>. It also mark this structure as a class so that arguments of type <code>One₁ α</code> for some type <code>α</code> will be inferrable using the instance resolution procedure, as long as they are marked as instance-implicit, ie appear between square brackets. Those two effects could also have been achieved using the <code>structure</code> command with <code>class</code> attribute, ie writing <code>@[class] structure</code> instance of <code>class</code>. But the class command also ensures that <code>One₁ α</code> appears as an instance-implicit argument in its own fields. Compare: BOTH: -/</p> <p>-- QUOTE:</p> <h1 id=check-one1one-one1one-type-self-one1>check One₁.one -- One₁.one {α : Type} [self : One₁ α] : α<a class=headerlink href=#check-one1one-one1one-type-self-one1 title="Permanent link">&para;</a></h1> <p>@[class] structure One₂ (α : Type) where /-- The element one -/ one : α</p> <h1 id=check-one2one>check One₂.one<a class=headerlink href=#check-one2one title="Permanent link">&para;</a></h1> <p>-- QUOTE.</p> <p>/- TEXT: In the second check, we can see that <code>self : One₂ α</code> is an explicit argument. Let us make sure the first version is indeed usable without any explicit argument. BOTH: -/</p> <p>-- QUOTE: example (α : Type) [One₁ α] : α := One₁.one -- QUOTE.</p> <p>/- TEXT: Remark: in the above example, the argument <code>One₁ α</code> is marked as instance-implicit, which is a bit silly since this affects only <em>uses</em> of the declaration and declaration created by the <code>example</code> command cannot be used. However it allows us to avoid giving a name to that argument and, more importantly, it starts installing the good habit of marking <code>One₁ α</code> arguments as instance-implicit.</p> <p>Another remark is that all this will work only when Lean knows what is <code>α</code>. In the above example, leaving out the type ascription <code>: α</code> would generate an error message like: <code>typeclass instance problem is stuck, it is often due to metavariables One₁ (?m.263 α)</code> where <code>?m.263 α</code> means "some type depending on <code>α</code>" (and 263 is simply an auto-generated index that would be useful to distinguish between several unknown things). Another way to avoid this issue would be to use a type annotation, as in: BOTH: -/ -- QUOTE: example (α : Type) [One₁ α] := (One₁.one : α) -- QUOTE.</p> <p>/- TEXT: You may have already encountered that issue when playing with limits of sequences in :numref:<code>sequences_and_convergence</code> if you tried to state for instance that <code>0 &lt; 1</code> without telling Lean whether you meant this inequality to be about natural numbers or real numbers.</p> <p>Our next task is to assign a notation to <code>One₁.one</code>. Since we don't want collisions with the builtin notation for <code>1</code>, we will use <code>𝟙</code>. This is achieved by the following command where the first line tells Lean to use the documentation of <code>One₁.one</code> as documentation for the symbol <code>𝟙</code>. BOTH: -/ -- QUOTE: @[inherit_doc] notation "𝟙" =&gt; One₁.one</p> <p>example {α : Type} [One₁ α] : α := 𝟙</p> <p>example {α : Type} [One₁ α] : (𝟙 : α) = 𝟙 := rfl -- QUOTE.</p> <p>/- TEXT: We now want a data-carrying class recording a binary operation. We don't want to choose between addition and multiplication for now so we'll use diamond. BOTH: -/</p> <p>-- QUOTE: class Dia₁ (α : Type) where dia : α → α → α</p> <p>infixl:70 " ⋄ " =&gt; Dia₁.dia -- QUOTE.</p> <p>/- TEXT: As in the <code>One₁</code> example, the operation has no property at all at this stage. Let us now define the class of semigroup structures where the operation is denoted by <code>⋄</code>. For now, we define it by hand as a structure with two fields, a <code>Dia₁</code> instance and some <code>Prop</code>-valued field <code>dia_assoc</code> asserting associativity of <code>⋄</code>. BOTH: -/</p> <p>-- QUOTE: class Semigroup₁ (α : Type) where toDia₁ : Dia₁ α /-- Diamond is associative -/ dia_assoc : ∀ a b c : α, a ⋄ b ⋄ c = a ⋄ (b ⋄ c) -- QUOTE.</p> <p>/- TEXT: Note that while stating <code>dia_assoc</code>, the previously defined field <code>toDia₁</code> is in the local context hence can be used when Lean searches for an instance of <code>Dia₁ α</code> to make sense of <code>a ⋄ b</code>. However this <code>toDia₁</code> field does not become part of the type class instances database. Hence doing <code>example {α : Type} [Semigroup₁ α] (a b : α) : α := a ⋄ b</code> would fail with error message <code>failed to synthesize instance Dia₁ α</code>.</p> <p>We can fix this by adding the <code>instance</code> attribute later. BOTH: -/</p> <p>-- QUOTE: attribute [instance] Semigroup₁.toDia₁</p> <p>example {α : Type} [Semigroup₁ α] (a b : α) : α := a ⋄ b -- QUOTE.</p> <p>/- TEXT: Before building up, we need a more convenient way to extend structures than explicitly writing fields like <code>toDia₁</code> and adding the instance attribute by hand. The <code>class</code> supports this using the <code>extends</code> syntax as in: BOTH: -/</p> <p>-- QUOTE: class Semigroup₂ (α : Type) extends Dia₁ α where /-- Diamond is associative -/ dia_assoc : ∀ a b c : α, a ⋄ b ⋄ c = a ⋄ (b ⋄ c)</p> <p>example {α : Type} [Semigroup₂ α] (a b : α) : α := a ⋄ b -- QUOTE.</p> <p>/- TEXT: Note this syntax is also available in the <code>structure</code> command, although it that case it fixes only the hurdle of writing fields such as <code>toDia₁</code> since there is no instance to define in that case.</p> <p>Let us now try to combine a diamond operation and a distinguished one with axioms saying this element is neutral on both sides. BOTH: -/ -- QUOTE: class DiaOneClass₁ (α : Type) extends One₁ α, Dia₁ α where /-- One is a left neutral element for diamond. -/ one_dia : ∀ a : α, 𝟙 ⋄ a = a /-- One is a right neutral element for diamond -/ dia_one : ∀ a : α, a ⋄ 𝟙 = a</p> <p>-- QUOTE.</p> <p>/- TEXT: In the next example, we tell Lean that <code>α</code> has a <code>DiaOneClass₁</code> structure and state a property that uses both a <code>Dia₁</code> instance and a <code>One₁</code> instance. In order to see how Lean finds those instances we set a tracing option whose result can be seen in the Infoview. This result is rather terse by default but it can be expanded by clicking on lines ending with black arrows. It includes failed attempts where Lean tried to find instances before having enough type information to succeed. The successful attempts do involve the instances generated by the <code>extends</code> syntax. BOTH: -/</p> <p>-- QUOTE: set_option trace.Meta.synthInstance true in example {α : Type} [DiaOneClass₁ α] (a b : α) : Prop := a ⋄ b = 𝟙 -- QUOTE.</p> <p>/- TEXT: Note that we don't need to include extra fields where combining existing classes. Hence we can define monoids as: BOTH: -/</p> <p>-- QUOTE: class Monoid₁ (α : Type) extends Semigroup₁ α, DiaOneClass₁ α -- QUOTE.</p> <p>/- TEXT: While the above definition seems straightforward, it hides an important subtlety. Both <code>Semigroup₁ α</code> and <code>DiaOneClass₁ α</code> extend <code>Dia₁ α</code>, so one could fear that having a <code>Monoid₁ α</code> instance gives two unrelated diamond operations on <code>α</code>, one coming from a field <code>Monoid₁.toSemigroup₁</code> and one coming from a field <code>Monoid₁.toDiaOneClass₁</code>.</p> <p>Indeed if we try to build a monoid class by hand using: BOTH: -/</p> <p>-- QUOTE: class Monoid₂ (α : Type) where toSemigroup₁ : Semigroup₁ α toDiaOneClass₁ : DiaOneClass₁ α -- QUOTE.</p> <p>/- TEXT: then we get two completely unrelated diamond operations <code>Monoid₂.toSemigroup₁.toDia₁.dia</code> and <code>Monoid₂.toDiaOneClass₁.toDia₁.dia</code>.</p> <p>The version generated using the <code>extends</code> syntax does not have this defect. BOTH: -/</p> <p>-- QUOTE: example {α : Type} [Monoid₁ α] : (Monoid₁.toSemigroup₁.toDia₁.dia : α → α → α) = Monoid₁.toDiaOneClass₁.toDia₁.dia := rfl -- QUOTE.</p> <p>/- TEXT: So the <code>class</code> command did some magic for us (and the <code>structure</code> command would have done it too). An easy way to see what are the fields of our classes is to check their constructor. Compare: BOTH: -/</p> <p>-- QUOTE: /- Monoid₂.mk {α : Type} (toSemigroup₁ : Semigroup₁ α) (toDiaOneClass₁ : DiaOneClass₁ α) : Monoid₂ α -/</p> <h1 id=check-monoid2mk>check Monoid₂.mk<a class=headerlink href=#check-monoid2mk title="Permanent link">&para;</a></h1> <p>/- Monoid₁.mk {α : Type} [toSemigroup₁ : Semigroup₁ α] [toOne₁ : One₁ α] (one_dia : ∀ (a : α), 𝟙 ⋄ a = a) (dia_one : ∀ (a : α), a ⋄ 𝟙 = a) : Monoid₁ α -/</p> <h1 id=check-monoid1mk>check Monoid₁.mk<a class=headerlink href=#check-monoid1mk title="Permanent link">&para;</a></h1> <p>-- QUOTE.</p> <p>/- TEXT: So we see that <code>Monoid₁</code> takes <code>Semigroup₁ α</code> argument as expected but then it won't take a would-be overlapping <code>DiaOneClass₁ α</code> argument but instead tears it apart and includes only the non-overlapping parts. And it also auto-generated an instance <code>Monoid₁.toDiaOneClass₁</code> which is <em>not</em> a field but has the expected signature which, from the end-user point of view, restores the symmetry between the two extended classes <code>Semigroup₁</code> and <code>DiaOneClass₁</code>. BOTH: -/</p> <p>-- QUOTE:</p> <h1 id=check-monoid1tosemigroup1>check Monoid₁.toSemigroup₁<a class=headerlink href=#check-monoid1tosemigroup1 title="Permanent link">&para;</a></h1> <h1 id=check-monoid1todiaoneclass1>check Monoid₁.toDiaOneClass₁<a class=headerlink href=#check-monoid1todiaoneclass1 title="Permanent link">&para;</a></h1> <p>-- QUOTE.</p> <p>/- TEXT: We are now very close to defining groups. We could add to the monoid structure a field asserting the existence of an inverse for every element. But then we would need to work to access these inverses. In practice it is more convenient to add it as data. To optimize reusability, we define a new data-carrying class, and then give it some notation. BOTH: -/</p> <p>-- QUOTE: class Inv₁ (α : Type) where /-- The inversion function -/ inv : α → α</p> <p>@[inherit_doc] postfix:max "⁻¹" =&gt; Inv₁.inv</p> <p>class Group₁ (G : Type) extends Monoid₁ G, Inv₁ G where inv_dia : ∀ a : G, a⁻¹ ⋄ a = 𝟙 -- QUOTE.</p> <p>/- TEXT: The above definition may seem too weak, we only ask that <code>a⁻¹</code> is a left-inverse of <code>a</code>. But the other side is automatic. In order to prove that, we need a preliminary lemma. BOTH: -/</p> <p>-- QUOTE: lemma left_inv_eq_right_inv₁ {M : Type} [Monoid₁ M] {a b c : M} (hba : b ⋄ a = 𝟙) (hac : a ⋄ c = 𝟙) : b = c := by rw [← DiaOneClass₁.one_dia c, ← hba, Semigroup₁.dia_assoc, hac, DiaOneClass₁.dia_one b] -- QUOTE.</p> <p>/- TEXT: In this lemma, it is pretty annoying to give full names, especially since it requires knowing which part of the hierarchy provides those facts. One way to fix this is to use the <code>export</code> command to copy those facts as lemmas in the root name space. BOTH: -/</p> <p>-- QUOTE: export DiaOneClass₁ (one_dia dia_one) export Semigroup₁ (dia_assoc) export Group₁ (inv_dia) -- QUOTE.</p> <p>/- TEXT: We can then rewrite the above proof as: BOTH: -/</p> <p>-- QUOTE: example {M : Type} [Monoid₁ M] {a b c : M} (hba : b ⋄ a = 𝟙) (hac : a ⋄ c = 𝟙) : b = c := by rw [← one_dia c, ← hba, dia_assoc, hac, dia_one b] -- QUOTE.</p> <p>/- TEXT: It is now your turn to prove things about our algebraic structures. BOTH: -/</p> <p>-- QUOTE: lemma inv_eq_of_dia [Group₁ G] {a b : G} (h : a ⋄ b = 𝟙) : a⁻¹ = b := /- EXAMPLES: sorry SOLUTIONS: -/ left_inv_eq_right_inv₁ (inv_dia a) h -- BOTH:</p> <p>lemma dia_inv [Group₁ G] (a : G) : a ⋄ a⁻¹ = 𝟙 := /- EXAMPLES: sorry SOLUTIONS: -/ by rw [← inv_dia a⁻¹, inv_eq_of_dia (inv_dia a)] -- QUOTE.</p> <p>/- TEXT: At this stage we would like to move on to define rings, but there is a serious issue. A ring structure on a type contains both an additive group structure and a multiplicative monoid structure, and some properties about their interaction. But so far we hard-coded a notation <code>⋄</code> for all our operations. More fundamentally, the type class system assumes every type has only one instance of each type class. There are various ways to solve this issue. Surprisingly Mathlib uses the naive idea to duplicate everything for additive and multiplicative theories with the help of some code-generating attribute. Structures and classes are defined in both additive and multiplicative notation with an attribute <code>to_additive</code> linking them. In case of multiple inheritance like for semi-groups, the auto-generated "symmetry-restoring" instances need also to be marked. This is a bit technical; you don't need to understand details. The important point is that lemmas are then only stated in multiplicative notation and marked with the attribute <code>to_additive</code> to generate the additive version as <code>left_inv_eq_right_inv'</code> with its auto-generated additive version <code>left_neg_eq_right_neg'</code>. In order to check the name of this additive version we used the <code>whatsnew in</code> command on top of <code>left_inv_eq_right_inv'</code>. BOTH: -/</p> <p>-- QUOTE:</p> <p>class AddSemigroup₃ (α : Type) extends Add α where /-- Addition is associative -/ add_assoc₃ : ∀ a b c : α, a + b + c = a + (b + c)</p> <p>@[to_additive AddSemigroup₃] class Semigroup₃ (α : Type) extends Mul α where /-- Multiplication is associative -/ mul_assoc₃ : ∀ a b c : α, a * b * c = a * (b * c)</p> <p>class AddMonoid₃ (α : Type) extends AddSemigroup₃ α, AddZeroClass α</p> <p>@[to_additive AddMonoid₃] class Monoid₃ (α : Type) extends Semigroup₃ α, MulOneClass α</p> <p>attribute [to_additive existing] Monoid₃.toMulOneClass</p> <p>export Semigroup₃ (mul_assoc₃) export AddSemigroup₃ (add_assoc₃)</p> <p>whatsnew in @[to_additive] lemma left_inv_eq_right_inv' {M : Type} [Monoid₃ M] {a b c : M} (hba : b * a = 1) (hac : a * c = 1) : b = c := by rw [← one_mul c, ← hba, mul_assoc₃, hac, mul_one b]</p> <h1 id=check-left_neg_eq_right_neg>check left_neg_eq_right_neg'<a class=headerlink href=#check-left_neg_eq_right_neg title="Permanent link">&para;</a></h1> <p>-- QUOTE.</p> <p>/- TEXT: Equipped with this technology, we can easily define also commutative semigroups, monoids and groups, and then define rings.</p> <p>BOTH: -/ -- QUOTE: class AddCommSemigroup₃ (α : Type) extends AddSemigroup₃ α where add_comm : ∀ a b : α, a + b = b + a</p> <p>@[to_additive AddCommSemigroup₃] class CommSemigroup₃ (α : Type) extends Semigroup₃ α where mul_comm : ∀ a b : α, a * b = b * a</p> <p>class AddCommMonoid₃ (α : Type) extends AddMonoid₃ α, AddCommSemigroup₃ α</p> <p>@[to_additive AddCommMonoid₃] class CommMonoid₃ (α : Type) extends Monoid₃ α, CommSemigroup₃ α</p> <p>class AddGroup₃ (G : Type) extends AddMonoid₃ G, Neg G where neg_add : ∀ a : G, -a + a = 0</p> <p>@[to_additive AddGroup₃] class Group₃ (G : Type) extends Monoid₃ G, Inv G where inv_mul : ∀ a : G, a⁻¹ * a = 1 -- QUOTE.</p> <p>/- TEXT: We should remember to tag lemmas with <code>simp</code> when appropriate. BOTH: -/</p> <p>-- QUOTE: attribute [simp] Group₃.inv_mul AddGroup₃.neg_add</p> <p>-- QUOTE.</p> <p>/- TEXT: Then we need to repeat ourselves a bit since we switch to standard notations, but at least <code>to_additive</code> does the work of translating from the multiplicative notation to the additive one. BOTH: -/</p> <p>-- QUOTE: @[to_additive] lemma inv_eq_of_mul [Group₃ G] {a b : G} (h : a * b = 1) : a⁻¹ = b := /- EXAMPLES: sorry SOLUTIONS: -/ left_inv_eq_right_inv' (Group₃.inv_mul a) h -- BOTH: -- QUOTE.</p> <p>/- TEXT: Note that <code>to_additive</code> can be asked to tag a lemma with <code>simp</code> and propagate that attribute to the additive version as follows. BOTH: -/</p> <p>-- QUOTE: @[to_additive (attr := simp)] lemma Group₃.mul_inv {G : Type} [Group₃ G] {a : G} : a * a⁻¹ = 1 := by /- EXAMPLES: sorry SOLUTIONS: -/ rw [← inv_mul a⁻¹, inv_eq_of_mul (inv_mul a)] -- BOTH:</p> <p>@[to_additive] lemma mul_left_cancel₃ {G : Type} [Group₃ G] {a b c : G} (h : a * b = a * c) : b = c := by /- EXAMPLES: sorry SOLUTIONS: -/ simpa [← mul_assoc₃] using congr_arg (a⁻¹ * ·) h -- BOTH:</p> <p>@[to_additive] lemma mul_right_cancel₃ {G : Type} [Group₃ G] {a b c : G} (h : b*a = c*a) : b = c := by /- EXAMPLES: sorry SOLUTIONS: -/ simpa [mul_assoc₃] using congr_arg (· * a⁻¹) h -- BOTH:</p> <p>class AddCommGroup₃ (G : Type) extends AddGroup₃ G, AddCommMonoid₃ G</p> <p>@[to_additive AddCommGroup₃] class CommGroup₃ (G : Type) extends Group₃ G, CommMonoid₃ G</p> <p>-- QUOTE.</p> <p>/- TEXT: We are now ready for rings. For demonstration purposes we won't assume that addition is commutative, and then immediately provide an instance of <code>AddCommGroup₃</code>. Mathlib does not play this game, first because in practice this does not make any ring instance easier and also because Mathlib's algebraic hierarchy goes through semirings which are like rings but without opposites so that the proof below does not work for them. What we gain here, besides a nice exercise if you have never seen it, is an example of building an instance using the syntax that allows to provide a parent structure and some extra fields. BOTH: -/</p> <p>-- QUOTE: class Ring₃ (R : Type) extends AddGroup₃ R, Monoid₃ R, MulZeroClass R where /-- Multiplication is left distributive over addition -/ left_distrib : ∀ a b c : R, a * (b + c) = a * b + a * c /-- Multiplication is right distributive over addition -/ right_distrib : ∀ a b c : R, (a + b) * c = a * c + b * c</p> <p>instance {R : Type} [Ring₃ R] : AddCommGroup₃ R := { Ring₃.toAddGroup₃ with add_comm := by /- EXAMPLES: sorry } SOLUTIONS: -/ intro a b have : a + (a + b + b) = a + (b + a + b) := calc a + (a + b + b) = (a + a) + (b + b) := by simp [add_assoc₃, add_assoc₃] _ = (1 * a + 1 * a) + (1 * b + 1 * b) := by simp _ = (1 + 1) * a + (1 + 1) * b := by simp [Ring₃.right_distrib] _ = (1 + 1) * (a + b) := by simp [Ring₃.left_distrib] _ = 1 * (a + b) + 1 * (a + b) := by simp [Ring₃.right_distrib] _ = (a + b) + (a + b) := by simp _ = a + (b + a + b) := by simp [add_assoc₃] exact add_right_cancel₃ (add_left_cancel₃ this) } -- QUOTE. /- TEXT: Of course we can also build concrete instances, such as a ring structure on integers (of course the instance below uses that all the work is already done in Mathlib). BOTH: -/</p> <p>-- QUOTE: instance : Ring₃ ℤ where add := (· + ·) add_assoc₃ := add_assoc zero := 0 zero_add := by simp add_zero := by simp neg := (- ·) neg_add := by simp mul := (· * ·) mul_assoc₃ := mul_assoc one := 1 one_mul := by simp mul_one := by simp zero_mul := by simp mul_zero := by simp left_distrib := Int.mul_add right_distrib := Int.add_mul -- QUOTE. /- TEXT: As an exercise you can now set up a simple hierarchy for order relations, including a class for ordered commutative monoids, which have both a partial order and a commutative monoid structure such that <code>∀ a b : α, a ≤ b → ∀ c : α, c * a ≤ c * b</code>. Of course you need to add fields and maybe <code>extends</code> clauses to the following classes. BOTH: -/ -- QUOTE:</p> <p>class LE₁ (α : Type) where /-- The Less-or-Equal relation. -/ le : α → α → Prop</p> <p>@[inherit_doc] infix:50 " ≤₁ " =&gt; LE₁.le</p> <p>class Preorder₁ (α : Type) -- SOLUTIONS: extends LE₁ α where le_refl : ∀ a : α, a ≤₁ a le_trans : ∀ a b c : α, a ≤₁ b → b ≤₁ c → a ≤₁ c -- BOTH:</p> <p>class PartialOrder₁ (α : Type) -- SOLUTIONS: extends Preorder₁ α where le_antisymm : ∀ a b : α, a ≤₁ b → b ≤₁ a → a = b -- BOTH:</p> <p>class OrderedCommMonoid₁ (α : Type) -- SOLUTIONS: extends PartialOrder₁ α, CommMonoid₃ α where mul_of_le : ∀ a b : α, a ≤₁ b → ∀ c : α, c * a ≤₁ c * b -- BOTH:</p> <p>instance : OrderedCommMonoid₁ ℕ where -- SOLUTIONS: le := (· ≤ ·) le_refl := fun _ ↦ le_rfl le_trans := fun _ _ _ ↦ le_trans le_antisymm := fun _ _ ↦ le_antisymm mul := (· * ·) mul_assoc₃ := mul_assoc one := 1 one_mul := one_mul mul_one := mul_one mul_comm := mul_comm mul_of_le := fun _ _ h c ↦ Nat.mul_le_mul_left c h -- QUOTE. /- TEXT:</p> <p>We now want to discuss algebraic structures involving several types. The prime example is modules over rings. If you don't know what is a module, you can pretend it means vector space and think that all our rings are fields. Those structures are commutative additive groups equipped with a scalar multiplication by elements of some ring.</p> <p>We first define the data-carrying type class of scalar multiplication by some type <code>α</code> on some type <code>β</code>, and give it a right associative notation. BOTH: -/</p> <p>-- QUOTE: class SMul₃ (α : Type) (β : Type) where /-- Scalar multiplication -/ smul : α → β → β</p> <p>infixr:73 " • " =&gt; SMul₃.smul -- QUOTE.</p> <p>/- TEXT: Then we can define modules (again think about vector spaces if you don't know what is a module). BOTH: -/</p> <p>-- QUOTE: class Module₁ (R : Type) [Ring₃ R] (M : Type) [AddCommGroup₃ M] extends SMul₃ R M where zero_smul : ∀ m : M, (0 : R) • m = 0 one_smul : ∀ m : M, (1 : R) • m = m mul_smul : ∀ (a b : R) (m : M), (a * b) • m = a • b • m add_smul : ∀ (a b : R) (m : M), (a + b) • m = a • m + b • m smul_add : ∀ (a : R) (m n : M), a • (m + n) = a • m + a • n -- QUOTE.</p> <p>/- TEXT: There is something interesting going on here. While it isn't too surprising that the ring structure on <code>R</code> is a parameter in this definition, you probably expected <code>AddCommGroup₃ M</code> to be part of the <code>extends</code> clause just as <code>SMul₃ R M</code> is. Trying to do that would lead to a mysterious sounding error message: <code>cannot find synthesization order for instance Module₁.toAddCommGroup₃ with type (R : Type) → [inst : Ring₃ R] → {M : Type} → [self : Module₁ R M] → AddCommGroup₃ M all remaining arguments have metavariables: Ring₃ ?R @Module₁ ?R ?inst✝ M</code>. In order to understand this message, you need to remember that such an <code>extends</code> clause would lead to a field <code>Module₃.toAddCommGroup₃</code> marked as an instance. This instance would have the signature appearing in the error message: <code>(R : Type) → [inst : Ring₃ R] → {M : Type} → [self : Module₁ R M] → AddCommGroup₃ M</code>. With such an instance in the type class database, each time Lean would look for a <code>AddCommGroup₃ M</code> instance for some <code>M</code>, it would need to go hunting for a completely unspecified type <code>R</code> and a <code>Ring₃ R</code> instance before embarking on the main quest of finding a <code>Module₁ R M</code> instance. Those two side-quests are represented by the meta-variables mentioned in the error message and denoted by <code>?R</code> and <code>?inst✝</code> there. Such a <code>Module₃.toAddCommGroup₃</code> instance would then be a huge trap for the instance resolution procedure and then <code>class</code> command refuses to set it up.</p> <p>What about <code>extends SMul₃ R M</code> then? That one creates a field <code>Module₁.toSMul₃ : {R : Type} → [inst : Ring₃ R] → {M : Type} → [inst_1 : AddCommGroup₃ M] → [self : Module₁ R M] → SMul₃ R M</code> whose end result <code>SMul₃ R M</code> mentions both <code>R</code> and <code>M</code> so this field can safely be used as an instance. The rule is easy to remember: each class appearing in the <code>extends</code> clause should mention every type appearing in the parameters.</p> <p>Let us create our first module instance: a ring is a module over itself using its multiplication as a scalar multiplication. BOTH: -/ -- QUOTE: instance selfModule (R : Type) [Ring₃ R] : Module₁ R R where smul := fun r s ↦ r*s zero_smul := zero_mul one_smul := one_mul mul_smul := mul_assoc₃ add_smul := Ring₃.right_distrib smul_add := Ring₃.left_distrib -- QUOTE. /- TEXT: As a second example, every abelian group is a module over <code>ℤ</code> (this is one of the reason to generalize the theory of vector spaces by allowing non-invertible scalars). First one can define scalar multiplication by a natural number for any type equipped with a zero and an addition: <code>n • a</code> is defined as <code>a + ⋯ + a</code> where <code>a</code> appears <code>n</code> times. Then this is extended to scalar multiplication by an integer by ensuring <code>(-1) • a = -a</code>. BOTH: -/ -- QUOTE:</p> <p>def nsmul₁ [Zero M] [Add M] : ℕ → M → M | 0, _ =&gt; 0 | n + 1, a =&gt; a + nsmul₁ n a</p> <p>def zsmul₁ {M : Type*} [Zero M] [Add M] [Neg M] : ℤ → M → M | Int.ofNat n, a =&gt; nsmul₁ n a | Int.negSucc n, a =&gt; -nsmul₁ n.succ a -- QUOTE. /- TEXT: Proving this gives rise to a module structure is a bit tedious and not interesting for the current discussion, so we will sorry all axioms. You are <em>not</em> asked to replace those sorries with proofs. If you insist on doing it then you will probably want to state and prove several intermediate lemmas about <code>nsmul₁</code> and <code>zsmul₁</code>. BOTH: -/ -- QUOTE:</p> <p>instance abGrpModule (A : Type) [AddCommGroup₃ A] : Module₁ ℤ A where smul := zsmul₁ zero_smul := sorry one_smul := sorry mul_smul := sorry add_smul := sorry smul_add := sorry -- QUOTE. /- TEXT: A much more important issue is that we now have two module structures over the ring <code>ℤ</code> for <code>ℤ</code> itself: <code>abGrpModule ℤ</code> since <code>ℤ</code> is a abelian group, and <code>selfModule ℤ</code> since <code>ℤ</code> is a ring. Those two module structure correspond to the same abelian group structure, but it is not obvious that they have the same scalar multiplication. They actually do, but this isn't true by definition, it requires a proof. This is very bad news for the type class instance resolution procedure and will lead to very frustrating failures for users of this hierarchy. When directly asked to find an instance, Lean will pick one, and we can see which one using: BOTH: -/ -- QUOTE:</p> <h1 id=synth-module1-z-z-abgrpmodule-z>synth Module₁ ℤ ℤ -- abGrpModule ℤ<a class=headerlink href=#synth-module1-z-z-abgrpmodule-z title="Permanent link">&para;</a></h1> <p>-- QUOTE. /- TEXT: But in a more indirect context it can happen that Lean infers the one and then gets confused. This situation is known as a bad diamond. This has nothing to do with the diamond operation we used above, it refers to the way one can draw the paths from <code>ℤ</code> to its <code>Module₁ ℤ</code> going through either <code>AddCommGroup₃ ℤ</code> or <code>Ring₃ ℤ</code>.</p> <p>It is important to understand that not all diamonds are bad. In fact there are diamonds everywhere in Mathlib, and also in this chapter. Already at the very beginning we saw one can go from <code>Monoid₁ α</code> to <code>Dia₁ α</code> through either <code>Semigroup₁ α</code> or <code>DiaOneClass₁ α</code> and thanks to the work done by the <code>class</code> command, the resulting two <code>Dia₁ α</code> instances are definitionally equal. In particular a diamond having a <code>Prop</code>-valued class at the bottom cannot be bad since any too proofs of the same statement are definitionally equal.</p> <p>But the diamond we created with modules is definitely bad. The offending piece is the <code>smul</code> field which is data, not a proof, and we have two constructions that are not definitionally equal. The robust way of fixing this issue is to make sure that going from a rich structure to a poor structure is always done by forgetting data, not by defining data. This well-known pattern as been named "forgetful inheritance" and extensively discussed in <a href=https://inria.hal.science/hal-02463336>https://inria.hal.science/hal-02463336</a>.</p> <p>In our concrete case, we can modify the definition of <code>AddMonoid₃</code> to include a <code>nsmul</code> data field and some <code>Prop</code>-valued fields ensuring this operation is provably the one we constructed above. Those fields are given default values using <code>:=</code> after their type in the definition below. Thanks to these default values, most instances would be constructed exactly as with our previous definitions. But in the special case of <code>ℤ</code> we will be able to provide specific values. BOTH: -/ -- QUOTE:</p> <p>class AddMonoid₄ (M : Type) extends AddSemigroup₃ M, AddZeroClass M where /-- Multiplication by a natural number. -/ nsmul : ℕ → M → M := nsmul₁ /-- Multiplication by <code>(0 : ℕ)</code> gives <code>0</code>. -/ nsmul_zero : ∀ x, nsmul 0 x = 0 := by intros; rfl /-- Multiplication by <code>(n + 1 : ℕ)</code> behaves as expected. -/ nsmul_succ : ∀ (n : ℕ) (x), nsmul (n + 1) x = x + nsmul n x := by intros; rfl</p> <p>instance mySMul {M : Type} [AddMonoid₄ M] : SMul ℕ M := ⟨AddMonoid₄.nsmul⟩ -- QUOTE. /- TEXT:</p> <p>Let us check we can still construct a product monoid instance without providing the <code>nsmul</code> related fields. BOTH: -/ -- QUOTE:</p> <p>instance (M N : Type) [AddMonoid₄ M] [AddMonoid₄ N] : AddMonoid₄ (M × N) where add := fun p q ↦ (p.1 + q.1, p.2 + q.2) add_assoc₃ := fun a b c ↦ by ext &lt;;&gt; apply add_assoc₃ zero := (0, 0) zero_add := fun a ↦ by ext &lt;;&gt; apply zero_add add_zero := fun a ↦ by ext &lt;;&gt; apply add_zero -- QUOTE. /- TEXT: And now let us handle the special case of <code>ℤ</code> where we want to build <code>nsmul</code> using the coercion of <code>ℕ</code> to <code>ℤ</code> and the multiplication on <code>ℤ</code>. Note in particular how the proof fields contain more work than in the default value above. BOTH: -/ -- QUOTE:</p> <p>instance : AddMonoid₄ ℤ where add := (· + ·) add_assoc₃ := Int.add_assoc zero := 0 zero_add := Int.zero_add add_zero := Int.add_zero nsmul := fun n m ↦ (n : ℤ) * m nsmul_zero := Int.zero_mul nsmul_succ := fun n m ↦ show (n + 1 : ℤ) * m = m + n * m by rw [Int.add_mul, Int.add_comm, Int.one_mul] -- QUOTE. /- TEXT: Let us check we solved our issue. Because Lean already has a definition of scalar multiplication of a natural number and an integer, and we want to make sure our instance is used, we won't use the <code>•</code> notation but call <code>SMul.mul</code> and explicitly provide our instance defined above. BOTH: -/ -- QUOTE:</p> <p>example (n : ℕ) (m : ℤ) : SMul.smul (self := mySMul) n m = n * m := rfl -- QUOTE. /- TEXT: This story then continues with incorporating a <code>zsmul</code> field into the definition of groups and similar tricks. You are now ready to read the definition of monoids, groups, rings and modules in Mathlib. There are more complicated than what we have seen here, because they are part of a huge hierarchy, but all principles have been explained above.</p> <p>As an exercise, you can come back to the order relation hierarchy you built above and try to incorporate a type class <code>LT₁</code> carrying the Less-Than notation <code>&lt;₁</code> and make sure that every preorder comes with a <code>&lt;₁</code> which has a default value built from <code>≤₁</code> and a <code>Prop</code>-valued field asserting the natural relation between those two comparison operators. -/</p> <p>-- SOLUTIONS:</p> <p>class LT₁ (α : Type) where /-- The Less-Than relation -/ lt : α → α → Prop</p> <p>@[inherit_doc] infix:50 " &lt;₁ " =&gt; LT₁.lt</p> <p>class PreOrder₂ (α : Type) extends LE₁ α, LT₁ α where le_refl : ∀ a : α, a ≤₁ a le_trans : ∀ a b c : α, a ≤₁ b → b ≤₁ c → a ≤₁ c lt := fun a b ↦ a ≤₁ b ∧ ¬b ≤₁ a lt_iff_le_not_le : ∀ a b : α, a &lt;₁ b ↔ a ≤₁ b ∧ ¬b ≤₁ a := by intros; rfl</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.sections", "navigation.instant", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"alias": true, "default": "latest", "provider": "mike"}}</script> <script src=../../../assets/javascripts/bundle.fe8b6f2b.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>