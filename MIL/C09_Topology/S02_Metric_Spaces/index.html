<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.0, mkdocs-material-9.5.31"><title>S02 Metric Spaces - MIL</title><link rel=stylesheet href=../../../assets/stylesheets/main.3cba04c6.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../assets/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent=light-green> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#metric-spaces class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <div data-md-color-scheme=default data-md-component=outdated hidden> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=MIL class="md-header__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> MIL </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> S02 Metric Spaces </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../en/ class=md-tabs__link> 目录 </a> </li> <li class=md-tabs__item> <a href=../../../en/C01_Introduction/ class=md-tabs__link> Introduction </a> </li> <li class=md-tabs__item> <a href=../../../en/C02_Basics/ class=md-tabs__link> Basics </a> </li> <li class=md-tabs__item> <a href=../../../en/C03_Logic/ class=md-tabs__link> Logic </a> </li> <li class=md-tabs__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-tabs__link> Sets and Functions </a> </li> <li class=md-tabs__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-tabs__link> Elementary Number Theory </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=MIL class="md-nav__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> MIL </label> <div class=md-nav__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../en/ class=md-nav__link> <span class=md-ellipsis> 目录 </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C01_Introduction/ class=md-nav__link> <span class=md-ellipsis> Introduction </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C02_Basics/ class=md-nav__link> <span class=md-ellipsis> Basics </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C03_Logic/ class=md-nav__link> <span class=md-ellipsis> Logic </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-nav__link> <span class=md-ellipsis> Sets and Functions </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-nav__link> <span class=md-ellipsis> Elementary Number Theory </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#metric-spaces class=md-nav__link> <span class=md-ellipsis> Metric spaces </span> </a> </li> <li class=md-nav__item> <a href=#check-dist-a-b-r class=md-nav__link> <span class=md-ellipsis> check (dist a b : ℝ) </span> </a> </li> <li class=md-nav__item> <a href=#check-dist_nonneg-0-dist-a-b class=md-nav__link> <span class=md-ellipsis> check (dist_nonneg : 0 ≤ dist a b) </span> </a> </li> <li class=md-nav__item> <a href=#check-dist_eq_zero-dist-a-b-0-a-b class=md-nav__link> <span class=md-ellipsis> check (dist_eq_zero : dist a b = 0 ↔ a = b) </span> </a> </li> <li class=md-nav__item> <a href=#check-dist_comm-a-b-dist-a-b-dist-b-a class=md-nav__link> <span class=md-ellipsis> check (dist_comm a b : dist a b = dist b a) </span> </a> </li> <li class=md-nav__item> <a href=#check-dist_triangle-a-b-c-dist-a-c-dist-a-b-dist-b-c class=md-nav__link> <span class=md-ellipsis> check (dist_triangle a b c : dist a c ≤ dist a b + dist b c) </span> </a> </li> <li class=md-nav__item> <a href=#check-emetricspace class=md-nav__link> <span class=md-ellipsis> check EMetricSpace </span> </a> </li> <li class=md-nav__item> <a href=#check-pseudometricspace class=md-nav__link> <span class=md-ellipsis> check PseudoMetricSpace </span> </a> </li> <li class=md-nav__item> <a href=#check-pseudoemetricspace class=md-nav__link> <span class=md-ellipsis> check PseudoEMetricSpace </span> </a> </li> <li class=md-nav__item> <a href=#check-iscompactisclosed class=md-nav__link> <span class=md-ellipsis> check IsCompact.isClosed </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <p>import MIL.Common import Mathlib.Topology.Instances.Real import Mathlib.Analysis.NormedSpace.BanachSteinhaus</p> <p>open Set Filter open Topology Filter</p> <p>/- TEXT: .. index:: metric space</p> <p>.. _metric_spaces:</p> <h2 id=metric-spaces>Metric spaces<a class=headerlink href=#metric-spaces title="Permanent link">&para;</a></h2> <p>Examples in the previous section focus on sequences of real numbers. In this section we will go up a bit in generality and focus on metric spaces. A metric space is a type <code>X</code> equipped with a distance function <code>dist : X → X → ℝ</code> which is a generalization of the function <code>fun x y ↦ |x - y|</code> from the case where <code>X = ℝ</code>.</p> <p>Introducing such a space is easy and we will check all properties required from the distance function. BOTH: -/ -- QUOTE: variable {X : Type*} [MetricSpace X] (a b c : X)</p> <h1 id=check-dist-a-b-r>check (dist a b : ℝ)<a class=headerlink href=#check-dist-a-b-r title="Permanent link">&para;</a></h1> <h1 id=check-dist_nonneg-0-dist-a-b>check (dist_nonneg : 0 ≤ dist a b)<a class=headerlink href=#check-dist_nonneg-0-dist-a-b title="Permanent link">&para;</a></h1> <h1 id=check-dist_eq_zero-dist-a-b-0-a-b>check (dist_eq_zero : dist a b = 0 ↔ a = b)<a class=headerlink href=#check-dist_eq_zero-dist-a-b-0-a-b title="Permanent link">&para;</a></h1> <h1 id=check-dist_comm-a-b-dist-a-b-dist-b-a>check (dist_comm a b : dist a b = dist b a)<a class=headerlink href=#check-dist_comm-a-b-dist-a-b-dist-b-a title="Permanent link">&para;</a></h1> <h1 id=check-dist_triangle-a-b-c-dist-a-c-dist-a-b-dist-b-c>check (dist_triangle a b c : dist a c ≤ dist a b + dist b c)<a class=headerlink href=#check-dist_triangle-a-b-c-dist-a-c-dist-a-b-dist-b-c title="Permanent link">&para;</a></h1> <p>-- QUOTE.</p> <p>/- TEXT: Note we also have variants where the distance can be infinite or where <code>dist a b</code> can be zero without having <code>a = b</code> or both. They are called <code>EMetricSpace</code>, <code>PseudoMetricSpace</code> and <code>PseudoEMetricSpace</code> respectively (here "e" stands for "extended").</p> <p>BOTH: -/ -- Note the next three lines are not quoted, their purpose is to make sure those things don't get renamed while we're looking elsewhere.</p> <h1 id=check-emetricspace>check EMetricSpace<a class=headerlink href=#check-emetricspace title="Permanent link">&para;</a></h1> <h1 id=check-pseudometricspace>check PseudoMetricSpace<a class=headerlink href=#check-pseudometricspace title="Permanent link">&para;</a></h1> <h1 id=check-pseudoemetricspace>check PseudoEMetricSpace<a class=headerlink href=#check-pseudoemetricspace title="Permanent link">&para;</a></h1> <p>/- TEXT: Note that our journey from <code>ℝ</code> to metric spaces jumped over the special case of normed spaces that also require linear algebra and will be explained as part of the calculus chapter.</p> <p>Convergence and continuity <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup>^^</p> <p>Using distance functions, we can already define convergent sequences and continuous functions between metric spaces. They are actually defined in a more general setting covered in the next section, but we have lemmas recasting the definition in terms of distances. BOTH: -/ -- QUOTE: example {u : ℕ → X} {a : X} : Tendsto u atTop (𝓝 a) ↔ ∀ ε &gt; 0, ∃ N, ∀ n ≥ N, dist (u n) a &lt; ε := Metric.tendsto_atTop</p> <p>example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X → Y} : Continuous f ↔ ∀ x : X, ∀ ε &gt; 0, ∃ δ &gt; 0, ∀ x', dist x' x &lt; δ → dist (f x') (f x) &lt; ε := Metric.continuous_iff -- QUOTE.</p> <p>/- TEXT: .. index:: continuity, tactics ; continuity</p> <p>A <em>lot</em> of lemmas have some continuity assumptions, so we end up proving a lot of continuity results and there is a <code>continuity</code> tactic devoted to this task. Let's prove a continuity statement that will be needed in an exercise below. Notice that Lean knows how to treat a product of two metric spaces as a metric space, so it makes sense to consider continuous functions from <code>X × X</code> to <code>ℝ</code>. In particular the (uncurried version of the) distance function is such a function.</p> <p>BOTH: -/ -- QUOTE: example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X → Y} (hf : Continuous f) : Continuous fun p : X × X ↦ dist (f p.1) (f p.2) := by continuity -- QUOTE.</p> <p>/- TEXT: This tactic is a bit slow, so it is also useful to know how to do it by hand. We first need to use that <code>fun p : X × X ↦ f p.1</code> is continuous because it is the composition of <code>f</code>, which is continuous by assumption <code>hf</code>, and the projection <code>prod.fst</code> whose continuity is the content of the lemma <code>continuous_fst</code>. The composition property is <code>Continuous.comp</code> which is in the <code>Continuous</code> namespace so we can use dot notation to compress <code>Continuous.comp hf continuous_fst</code> into <code>hf.comp continuous_fst</code> which is actually more readable since it really reads as composing our assumption and our lemma. We can do the same for the second component to get continuity of <code>fun p : X × X ↦ f p.2</code>. We then assemble those two continuities using <code>Continuous.prod_mk</code> to get <code>(hf.comp continuous_fst).prod_mk (hf.comp continuous_snd) : Continuous (fun p : X × X ↦ (f p.1, f p.2))</code> and compose once more to get our full proof. BOTH: -/ -- QUOTE: example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X → Y} (hf : Continuous f) : Continuous fun p : X × X ↦ dist (f p.1) (f p.2) := continuous_dist.comp ((hf.comp continuous_fst).prod_mk (hf.comp continuous_snd)) -- QUOTE.</p> <p>/- TEXT: The combination of <code>Continuous.prod_mk</code> and <code>continuous_dist</code> via <code>Continuous.comp</code> feels clunky, even when heavily using dot notation as above. A more serious issue is that this nice proof requires a lot of planning. Lean accepts the above proof term because it is a full term proving a statement which is definitionally equivalent to our goal, the crucial definition to unfold being that of a composition of functions. Indeed our target function <code>fun p : X × X ↦ dist (f p.1) (f p.2)</code> is not presented as a composition. The proof term we provided proves continuity of <code>dist ∘ (fun p : X × X ↦ (f p.1, f p.2))</code> which happens to be definitionally equal to our target function. But if we try to build this proof gradually using tactics starting with <code>apply continuous_dist.comp</code> then Lean's elaborator will fail to recognize a composition and refuse to apply this lemma. It is especially bad at this when products of types are involved.</p> <p>A better lemma to apply here is <code>Continuous.dist {f g : X → Y} : Continuous f → Continuous g → Continuous (fun x ↦ dist (f x) (g x))</code> which is nicer to Lean's elaborator and also provides a shorter proof when directly providing a full proof term, as can be seen from the following two new proofs of the above statement: BOTH: -/ -- QUOTE: example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X → Y} (hf : Continuous f) : Continuous fun p : X × X ↦ dist (f p.1) (f p.2) := by apply Continuous.dist exact hf.comp continuous_fst exact hf.comp continuous_snd</p> <p>example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X → Y} (hf : Continuous f) : Continuous fun p : X × X ↦ dist (f p.1) (f p.2) := (hf.comp continuous_fst).dist (hf.comp continuous_snd) -- QUOTE.</p> <p>/- TEXT: Note that, without the elaboration issue coming from composition, another way to compress our proof would be to use <code>Continuous.prod_map</code> which is sometimes useful and gives as an alternate proof term <code>continuous_dist.comp (hf.prod_map hf)</code> which even shorter to type.</p> <p>Since it is sad to decide between a version which is better for elaboration and a version which is shorter to type, let us wrap this discussion with a last bit of compression offered by <code>Continuous.fst'</code> which allows to compress <code>hf.comp continuous_fst</code> to <code>hf.fst'</code> (and the same with <code>snd</code>) and get our final proof, now bordering obfuscation.</p> <p>BOTH: -/ -- QUOTE: example {X Y : Type*} [MetricSpace X] [MetricSpace Y] {f : X → Y} (hf : Continuous f) : Continuous fun p : X × X ↦ dist (f p.1) (f p.2) := hf.fst'.dist hf.snd' -- QUOTE.</p> <p>/- TEXT: It's your turn now to prove some continuity lemma. After trying the continuity tactic, you will need <code>Continuous.add</code>, <code>continuous_pow</code> and <code>continuous_id</code> to do it by hand.</p> <p>BOTH: -/ -- QUOTE: example {f : ℝ → X} (hf : Continuous f) : Continuous fun x : ℝ ↦ f (x ^ 2 + x) := sorry -- QUOTE.</p> <p>-- SOLUTIONS: example {f : ℝ → X} (hf : Continuous f) : Continuous fun x : ℝ ↦ f (x ^ 2 + x) := hf.comp &lt;| (continuous_pow 2).add continuous_id</p> <p>/- TEXT: So far we saw continuity as a global notion, but one can also define continuity at a point. BOTH: -/ -- QUOTE: example {X Y : Type*} [MetricSpace X] [MetricSpace Y] (f : X → Y) (a : X) : ContinuousAt f a ↔ ∀ ε &gt; 0, ∃ δ &gt; 0, ∀ {x}, dist x a &lt; δ → dist (f x) (f a) &lt; ε := Metric.continuousAt_iff -- QUOTE.</p> <p>/- TEXT:</p> <p>Balls, open sets and closed sets <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup>^^</p> <p>Once we have a distance function, the most important geometric definitions are (open) balls and closed balls.</p> <p>BOTH: -/ -- QUOTE: variable (r : ℝ)</p> <p>example : Metric.ball a r = { b | dist b a &lt; r } := rfl</p> <p>example : Metric.closedBall a r = { b | dist b a ≤ r } := rfl -- QUOTE.</p> <p>/- TEXT: Note that <code>r</code> is any real number here, there is no sign restriction. Of course some statements do require a radius condition. BOTH: -/ -- QUOTE: example (hr : 0 &lt; r) : a ∈ Metric.ball a r := Metric.mem_ball_self hr</p> <p>example (hr : 0 ≤ r) : a ∈ Metric.closedBall a r := Metric.mem_closedBall_self hr -- QUOTE.</p> <p>/- TEXT: Once we have balls, we can define open sets. They are actually defined in a more general setting covered in the next section, but we have lemmas recasting the definition in terms of balls.</p> <p>BOTH: -/ -- QUOTE: example (s : Set X) : IsOpen s ↔ ∀ x ∈ s, ∃ ε &gt; 0, Metric.ball x ε ⊆ s := Metric.isOpen_iff -- QUOTE.</p> <p>/- TEXT: Then closed sets are sets whose complement is open. Their important property is they are closed under limits. The closure of a set is the smallest closed set containing it. BOTH: -/ -- QUOTE: example {s : Set X} : IsClosed s ↔ IsOpen (sᶜ) := isOpen_compl_iff.symm</p> <p>example {s : Set X} (hs : IsClosed s) {u : ℕ → X} (hu : Tendsto u atTop (𝓝 a)) (hus : ∀ n, u n ∈ s) : a ∈ s := hs.mem_of_tendsto hu (eventually_of_forall hus)</p> <p>example {s : Set X} : a ∈ closure s ↔ ∀ ε &gt; 0, ∃ b ∈ s, a ∈ Metric.ball b ε := Metric.mem_closure_iff -- QUOTE.</p> <p>/- TEXT: Do the next exercise without using <code>mem_closure_iff_seq_limit</code> BOTH: -/ -- QUOTE: example {u : ℕ → X} (hu : Tendsto u atTop (𝓝 a)) {s : Set X} (hs : ∀ n, u n ∈ s) : a ∈ closure s := sorry -- QUOTE.</p> <p>-- SOLUTIONS: example {u : ℕ → X} (hu : Tendsto u atTop (𝓝 a)) {s : Set X} (hs : ∀ n, u n ∈ s) : a ∈ closure s := by rw [Metric.tendsto_atTop] at hu rw [Metric.mem_closure_iff] intro ε ε_pos rcases hu ε ε_pos with ⟨N, hN⟩ refine' ⟨u N, hs _, _⟩ rw [dist_comm] exact hN N le_rfl</p> <p>/- TEXT:</p> <p>Remember from the filters sections that neighborhood filters play a big role in Mathlib. In the metric space context, the crucial point is that balls provide bases for those filters. The main lemmas here are <code>Metric.nhds_basis_ball</code> and <code>Metric.nhds_basis_closedBall</code> that claim this for open and closed balls with positive radius. The center point is an implicit argument so we can invoke <code>Filter.HasBasis.mem_iff</code> as in the following example.</p> <p>BOTH: -/ -- QUOTE: example {x : X} {s : Set X} : s ∈ 𝓝 x ↔ ∃ ε &gt; 0, Metric.ball x ε ⊆ s := Metric.nhds_basis_ball.mem_iff</p> <p>example {x : X} {s : Set X} : s ∈ 𝓝 x ↔ ∃ ε &gt; 0, Metric.closedBall x ε ⊆ s := Metric.nhds_basis_closedBall.mem_iff -- QUOTE.</p> <p>/- TEXT:</p> <p>Compactness <sup>^</sup><sup>^</sup><sup>^</sup>^^</p> <p>Compactness is an important topological notion. It distinguishes subsets of a metric space that enjoy the same kind of properties as segments in reals compared to other intervals:</p> <ul> <li>Any sequence taking value in a compact set has a subsequence that converges in this set</li> <li>Any continuous function on a nonempty compact set with values in real numbers is bounded and achieves its bounds somewhere (this is called the extreme values theorem).</li> <li>Compact sets are closed sets.</li> </ul> <p>Let us first check that the unit interval in reals is indeed a compact set, and then check the above claims for compact sets in general metric spaces. In the second statement we only need continuity on the given set so we will use <code>ContinuousOn</code> instead of <code>Continuous</code>, and we will give separate statements for the minimum and the maximum. Of course all these results are deduced from more general versions, some of which will be discussed in later sections.</p> <p>BOTH: -/ -- QUOTE: example : IsCompact (Set.Icc 0 1 : Set ℝ) := isCompact_Icc</p> <p>example {s : Set X} (hs : IsCompact s) {u : ℕ → X} (hu : ∀ n, u n ∈ s) : ∃ a ∈ s, ∃ φ : ℕ → ℕ, StrictMono φ ∧ Tendsto (u ∘ φ) atTop (𝓝 a) := hs.tendsto_subseq hu</p> <p>example {s : Set X} (hs : IsCompact s) (hs' : s.Nonempty) {f : X → ℝ} (hfs : ContinuousOn f s) : ∃ x ∈ s, ∀ y ∈ s, f x ≤ f y := hs.exists_forall_le hs' hfs</p> <p>example {s : Set X} (hs : IsCompact s) (hs' : s.Nonempty) {f : X → ℝ} (hfs : ContinuousOn f s) : ∃ x ∈ s, ∀ y ∈ s, f y ≤ f x := hs.exists_forall_ge hs' hfs</p> <p>example {s : Set X} (hs : IsCompact s) : IsClosed s := hs.isClosed -- QUOTE.</p> <p>/- TEXT:</p> <p>We can also specify that a metric spaces is globally compact, using an extra <code>Prop</code>-valued type class:</p> <p>BOTH: -/ -- QUOTE: example {X : Type*} [MetricSpace X] [CompactSpace X] : IsCompact (univ : Set X) := isCompact_univ -- QUOTE.</p> <p>/- TEXT:</p> <p>In a compact metric space any closed set is compact, this is <code>IsClosed.isCompact</code>.</p> <p>BOTH: -/</p> <h1 id=check-iscompactisclosed>check IsCompact.isClosed<a class=headerlink href=#check-iscompactisclosed title="Permanent link">&para;</a></h1> <p>/- TEXT: Uniformly continuous functions <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup></p> <p>We now turn to uniformity notions on metric spaces : uniformly continuous functions, Cauchy sequences and completeness. Again those are defined in a more general context but we have lemmas in the metric name space to access their elementary definitions. We start with uniform continuity.</p> <p>BOTH: -/ -- QUOTE: example {X : Type*} [MetricSpace X] {Y : Type*} [MetricSpace Y] {f : X → Y} : UniformContinuous f ↔ ∀ ε &gt; 0, ∃ δ &gt; 0, ∀ {a b : X}, dist a b &lt; δ → dist (f a) (f b) &lt; ε := Metric.uniformContinuous_iff -- QUOTE.</p> <p>/- TEXT: In order to practice manipulating all those definitions, we will prove that continuous functions from a compact metric space to a metric space are uniformly continuous (we will see a more general version in a later section).</p> <p>We will first give an informal sketch. Let <code>f : X → Y</code> be a continuous function from a compact metric space to a metric space. We fix <code>ε &gt; 0</code> and start looking for some <code>δ</code>.</p> <p>Let <code>φ : X × X → ℝ := fun p ↦ dist (f p.1) (f p.2)</code> and let <code>K := { p : X × X | ε ≤ φ p }</code>. Observe <code>φ</code> is continuous since <code>f</code> and distance are continuous. And <code>K</code> is clearly closed (use <code>isClosed_le</code>) hence compact since <code>X</code> is compact.</p> <p>Then we discuss two possibilities using <code>eq_empty_or_nonempty</code>. If <code>K</code> is empty then we are clearly done (we can set <code>δ = 1</code> for instance). So let's assume <code>K</code> is not empty, and use the extreme value theorem to choose <code>(x₀, x₁)</code> attaining the infimum of the distance function on <code>K</code>. We can then set <code>δ = dist x₀ x₁</code> and check everything works.</p> <p>BOTH: -/ -- QUOTE: example {X : Type*} [MetricSpace X] [CompactSpace X] {Y : Type*} [MetricSpace Y] {f : X → Y} (hf : Continuous f) : UniformContinuous f := sorry -- QUOTE.</p> <p>-- SOLUTIONS: example {X : Type*} [MetricSpace X] [CompactSpace X] {Y : Type*} [MetricSpace Y] {f : X → Y} (hf : Continuous f) : UniformContinuous f := by rw [Metric.uniformContinuous_iff] intro ε ε_pos let φ : X × X → ℝ := fun p ↦ dist (f p.1) (f p.2) have φ_cont : Continuous φ := hf.fst'.dist hf.snd' let K := { p : X × X | ε ≤ φ p } have K_closed : IsClosed K := isClosed_le continuous_const φ_cont have K_cpct : IsCompact K := K_closed.isCompact rcases eq_empty_or_nonempty K with hK | hK · use 1, by norm_num intro x y _ have : (x, y) ∉ K := by simp [hK] simpa [K] using this · rcases K_cpct.exists_forall_le hK continuous_dist.continuousOn with ⟨⟨x₀, x₁⟩, xx_in, H⟩ use dist x₀ x₁ constructor · change _ &lt; _ rw [dist_pos] intro h have : ε ≤ 0 := by simpa [K, φ, *] using xx_in linarith · intro x x' contrapose! intro hxx' exact H (x, x') hxx'</p> <p>/- TEXT: Completeness <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup></p> <p>A Cauchy sequence in a metric space is a sequence whose terms get closer and closer to each other. There are a couple of equivalent ways to state that idea. In particular converging sequences are Cauchy. The converse is true only in so-called <em>complete</em> spaces.</p> <p>BOTH: -/ -- QUOTE: example (u : ℕ → X) : CauchySeq u ↔ ∀ ε &gt; 0, ∃ N : ℕ, ∀ m ≥ N, ∀ n ≥ N, dist (u m) (u n) &lt; ε := Metric.cauchySeq_iff</p> <p>example (u : ℕ → X) : CauchySeq u ↔ ∀ ε &gt; 0, ∃ N : ℕ, ∀ n ≥ N, dist (u n) (u N) &lt; ε := Metric.cauchySeq_iff'</p> <p>example [CompleteSpace X] (u : ℕ → X) (hu : CauchySeq u) : ∃ x, Tendsto u atTop (𝓝 x) := cauchySeq_tendsto_of_complete hu -- QUOTE.</p> <p>/- TEXT:</p> <p>We'll practice using this definition by proving a convenient criterion which is a special case of a criterion appearing in Mathlib. This is also a good opportunity to practice using big sums in a geometric context. In addition to the explanations from the filters section, you will probably need <code>tendsto_pow_atTop_nhds_0_of_lt_1</code>, <code>Tendsto.mul</code> and <code>dist_le_range_sum_dist</code>. BOTH: -/ open BigOperators</p> <p>open Finset</p> <p>-- QUOTE: theorem cauchySeq_of_le_geometric_two' {u : ℕ → X} (hu : ∀ n : ℕ, dist (u n) (u (n + 1)) ≤ (1 / 2) ^ n) : CauchySeq u := by rw [Metric.cauchySeq_iff'] intro ε ε_pos obtain ⟨N, hN⟩ : ∃ N : ℕ, 1 / 2 ^ N * 2 &lt; ε := by sorry use N intro n hn obtain ⟨k, rfl : n = N + k⟩ := le_iff_exists_add.mp hn calc dist (u (N + k)) (u N) = dist (u (N + 0)) (u (N + k)) := sorry _ ≤ ∑ i in range k, dist (u (N + i)) (u (N + (i + 1))) := sorry _ ≤ ∑ i in range k, (1 / 2 : ℝ) ^ (N + i) := sorry _ = 1 / 2 ^ N * ∑ i in range k, (1 / 2 : ℝ) ^ i := sorry _ ≤ 1 / 2 ^ N * 2 := sorry _ &lt; ε := sorry</p> <p>-- QUOTE.</p> <p>-- SOLUTIONS: example {u : ℕ → X} (hu : ∀ n : ℕ, dist (u n) (u (n + 1)) ≤ (1 / 2) ^ n) : CauchySeq u := by rw [Metric.cauchySeq_iff'] intro ε ε_pos obtain ⟨N, hN⟩ : ∃ N : ℕ, 1 / 2 ^ N * 2 &lt; ε := by have : Tendsto (fun N : ℕ ↦ (1 / 2 ^ N * 2 : ℝ)) atTop (𝓝 0) := by rw [← zero_mul (2 : ℝ)] apply Tendsto.mul simp_rw [← one_div_pow (2 : ℝ)] apply tendsto_pow_atTop_nhds_0_of_lt_1 &lt;;&gt; linarith exact tendsto_const_nhds rcases(atTop_basis.tendsto_iff (nhds_basis_Ioo_pos (0 : ℝ))).mp this ε ε_pos with ⟨N, _, hN⟩ exact ⟨N, by simpa using (hN N left_mem_Ici).2⟩ use N intro n hn obtain ⟨k, rfl : n = N + k⟩ := le_iff_exists_add.mp hn calc dist (u (N + k)) (u N) = dist (u (N + 0)) (u (N + k)) := by rw [dist_comm, add_zero] _ ≤ ∑ i in range k, dist (u (N + i)) (u (N + (i + 1))) := (dist_le_range_sum_dist (fun i ↦ u (N + i)) k) _ ≤ ∑ i in range k, (1 / 2 : ℝ) ^ (N + i) := (sum_le_sum fun i _ ↦ hu &lt;| N + i) _ = 1 / 2 ^ N * ∑ i in range k, (1 / 2 : ℝ) ^ i := by simp_rw [← one_div_pow, pow_add, ← mul_sum] _ ≤ 1 / 2 ^ N * 2 := (mul_le_mul_of_nonneg_left (sum_geometric_two_le _) (one_div_nonneg.mpr (pow_nonneg (zero_le_two : (0 : ℝ) ≤ 2) _))) _ &lt; ε := hN</p> <p>/- TEXT:</p> <p>We are ready for the final boss of this section: Baire's theorem for complete metric spaces! The proof skeleton below shows interesting techniques. It uses the <code>choose</code> tactic in its exclamation mark variant (you should experiment with removing this exclamation mark) and it shows how to define something inductively in the middle of a proof using <code>Nat.rec_on</code>.</p> <p>BOTH: -/ -- QUOTE: open Metric</p> <p>example [CompleteSpace X] (f : ℕ → Set X) (ho : ∀ n, IsOpen (f n)) (hd : ∀ n, Dense (f n)) : Dense (⋂ n, f n) := by let B : ℕ → ℝ := fun n ↦ (1 / 2) ^ n have Bpos : ∀ n, 0 &lt; B n sorry /- Translate the density assumption into two functions <code>center</code> and <code>radius</code> associating to any n, x, δ, δpos a center and a positive radius such that <code>closedBall center radius</code> is included both in <code>f n</code> and in <code>closedBall x δ</code>. We can also require <code>radius ≤ (1/2)^(n+1)</code>, to ensure we get a Cauchy sequence later. -/ have : ∀ (n : ℕ) (x : X), ∀ δ &gt; 0, ∃ y : X, ∃ r &gt; 0, r ≤ B (n + 1) ∧ closedBall y r ⊆ closedBall x δ ∩ f n := by sorry choose! center radius Hpos HB Hball using this intro x rw [mem_closure_iff_nhds_basis nhds_basis_closedBall] intro ε εpos /- <code>ε</code> is positive. We have to find a point in the ball of radius <code>ε</code> around <code>x</code> belonging to all <code>f n</code>. For this, we construct inductively a sequence <code>F n = (c n, r n)</code> such that the closed ball <code>closedBall (c n) (r n)</code> is included in the previous ball and in <code>f n</code>, and such that <code>r n</code> is small enough to ensure that <code>c n</code> is a Cauchy sequence. Then <code>c n</code> converges to a limit which belongs to all the <code>f n</code>. -/ let F : ℕ → X × ℝ := fun n ↦ Nat.recOn n (Prod.mk x (min ε (B 0))) fun n p ↦ Prod.mk (center n p.1 p.2) (radius n p.1 p.2) let c : ℕ → X := fun n ↦ (F n).1 let r : ℕ → ℝ := fun n ↦ (F n).2 have rpos : ∀ n, 0 &lt; r n := by sorry have rB : ∀ n, r n ≤ B n := by sorry have incl : ∀ n, closedBall (c (n + 1)) (r (n + 1)) ⊆ closedBall (c n) (r n) ∩ f n := by sorry have cdist : ∀ n, dist (c n) (c (n + 1)) ≤ B n := by sorry have : CauchySeq c := cauchySeq_of_le_geometric_two' cdist -- as the sequence <code>c n</code> is Cauchy in a complete space, it converges to a limit <code>y</code>. rcases cauchySeq_tendsto_of_complete this with ⟨y, ylim⟩ -- this point <code>y</code> will be the desired point. We will check that it belongs to all -- <code>f n</code> and to <code>ball x ε</code>. use y have I : ∀ n, ∀ m ≥ n, closedBall (c m) (r m) ⊆ closedBall (c n) (r n) := by sorry have yball : ∀ n, y ∈ closedBall (c n) (r n) := by sorry sorry -- QUOTE.</p> <p>-- SOLUTIONS: example [CompleteSpace X] (f : ℕ → Set X) (ho : ∀ n, IsOpen (f n)) (hd : ∀ n, Dense (f n)) : Dense (⋂ n, f n) := by let B : ℕ → ℝ := fun n ↦ (1 / 2) ^ n have Bpos : ∀ n, 0 &lt; B n := fun n ↦ pow_pos sorry n /- Translate the density assumption into two functions <code>center</code> and <code>radius</code> associating to any n, x, δ, δpos a center and a positive radius such that <code>closedBall center radius</code> is included both in <code>f n</code> and in <code>closedBall x δ</code>. We can also require <code>radius ≤ (1/2)^(n+1)</code>, to ensure we get a Cauchy sequence later. -/ have : ∀ (n : ℕ) (x : X), ∀ δ &gt; 0, ∃ y : X, ∃ r &gt; 0, r ≤ B (n + 1) ∧ closedBall y r ⊆ closedBall x δ ∩ f n := by intro n x δ δpos have : x ∈ closure (f n) := hd n x rcases Metric.mem_closure_iff.1 this (δ / 2) (half_pos δpos) with ⟨y, ys, xy⟩ rw [dist_comm] at xy obtain ⟨r, rpos, hr⟩ : ∃ r &gt; 0, closedBall y r ⊆ f n := nhds_basis_closedBall.mem_iff.1 (isOpen_iff_mem_nhds.1 (ho n) y ys) refine' ⟨y, min (min (δ / 2) r) (B (n + 1)), <em>, _, fun z hz ↦ ⟨</em>, _⟩⟩ show 0 &lt; min (min (δ / 2) r) (B (n + 1)) exact lt_min (lt_min (half_pos δpos) rpos) (Bpos (n + 1)) show min (min (δ / 2) r) (B (n + 1)) ≤ B (n + 1) exact min_le_right _ _ show z ∈ closedBall x δ exact calc dist z x ≤ dist z y + dist y x := dist_triangle _ _ _ _ ≤ min (min (δ / 2) r) (B (n + 1)) + δ / 2 := (add_le_add hz xy.le) _ ≤ δ / 2 + δ / 2 := (add_le_add_right ((min_le_left _ _).trans (min_le_left _ _)) _) _ = δ := add_halves δ</p> <div class=codehilite><pre><span></span><code>show z ∈ f n
exact
  hr
    (calc
      dist z y ≤ min (min (δ / 2) r) (B (n + 1)) := hz
      _ ≤ r := (min_le_left _ _).trans (min_le_right _ _)
      )
</code></pre></div> <p>choose! center radius Hpos HB Hball using this refine' fun x ↦ (mem_closure_iff_nhds_basis nhds_basis_closedBall).2 fun ε εpos ↦ _ /- <code>ε</code> is positive. We have to find a point in the ball of radius <code>ε</code> around <code>x</code> belonging to all <code>f n</code>. For this, we construct inductively a sequence <code>F n = (c n, r n)</code> such that the closed ball <code>closedBall (c n) (r n)</code> is included in the previous ball and in <code>f n</code>, and such that <code>r n</code> is small enough to ensure that <code>c n</code> is a Cauchy sequence. Then <code>c n</code> converges to a limit which belongs to all the <code>f n</code>. -/ let F : ℕ → X × ℝ := fun n ↦ Nat.recOn n (Prod.mk x (min ε (B 0))) fun n p ↦ Prod.mk (center n p.1 p.2) (radius n p.1 p.2) let c : ℕ → X := fun n ↦ (F n).1 let r : ℕ → ℝ := fun n ↦ (F n).2 have rpos : ∀ n, 0 &lt; r n := by intro n induction' n with n hn exact lt_min εpos (Bpos 0) exact Hpos n (c n) (r n) hn have rB : ∀ n, r n ≤ B n := by intro n induction' n with n hn exact min_le_right _ _ exact HB n (c n) (r n) (rpos n) have incl : ∀ n, closedBall (c (n + 1)) (r (n + 1)) ⊆ closedBall (c n) (r n) ∩ f n := fun n ↦ Hball n (c n) (r n) (rpos n) have cdist : ∀ n, dist (c n) (c (n + 1)) ≤ B n := by intro n rw [dist_comm] have A : c (n + 1) ∈ closedBall (c (n + 1)) (r (n + 1)) := mem_closedBall_self (rpos &lt;| n + 1).le have I := calc closedBall (c (n + 1)) (r (n + 1)) ⊆ closedBall (c n) (r n) := (incl n).trans Set.inter_subset_left _ ⊆ closedBall (c n) (B n) := closedBall_subset_closedBall (rB n)</p> <div class=codehilite><pre><span></span><code>exact I A
</code></pre></div> <p>have : CauchySeq c := cauchySeq_of_le_geometric_two' cdist -- as the sequence <code>c n</code> is Cauchy in a complete space, it converges to a limit <code>y</code>. rcases cauchySeq_tendsto_of_complete this with ⟨y, ylim⟩ -- this point <code>y</code> will be the desired point. We will check that it belongs to all -- <code>f n</code> and to <code>ball x ε</code>. use y have I : ∀ n, ∀ m ≥ n, closedBall (c m) (r m) ⊆ closedBall (c n) (r n) := by intro n refine' Nat.le_induction _ fun m hnm h ↦ _ · exact Subset.rfl · exact (incl m).trans (Set.inter_subset_left.trans h) have yball : ∀ n, y ∈ closedBall (c n) (r n) := by intro n refine' isClosed_ball.mem_of_tendsto ylim _ refine' (Filter.eventually_ge_atTop n).mono fun m hm ↦ _ exact I n m hm (mem_closedBall_self (rpos _).le) constructor · suffices ∀ n, y ∈ f n by rwa [Set.mem_iInter] intro n have : closedBall (c (n + 1)) (r (n + 1)) ⊆ f n := Subset.trans (incl n) Set.inter_subset_right exact this (yball (n + 1)) calc dist y x ≤ r 0 := yball 0 _ ≤ ε := min_le_left _ _</p> <p>/- TEXT:</p> <p>BOTH: -/</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.sections", "navigation.instant", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"alias": true, "default": "latest", "provider": "mike"}}</script> <script src=../../../assets/javascripts/bundle.fe8b6f2b.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>