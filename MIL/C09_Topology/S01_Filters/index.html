<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.0, mkdocs-material-9.5.31"><title>S01 Filters - MIL</title><link rel=stylesheet href=../../../assets/stylesheets/main.3cba04c6.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../assets/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent=light-green> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#filters class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <div data-md-color-scheme=default data-md-component=outdated hidden> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=MIL class="md-header__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> MIL </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> S01 Filters </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../en/ class=md-tabs__link> 目录 </a> </li> <li class=md-tabs__item> <a href=../../../en/C01_Introduction/ class=md-tabs__link> Introduction </a> </li> <li class=md-tabs__item> <a href=../../../en/C02_Basics/ class=md-tabs__link> Basics </a> </li> <li class=md-tabs__item> <a href=../../../en/C03_Logic/ class=md-tabs__link> Logic </a> </li> <li class=md-tabs__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-tabs__link> Sets and Functions </a> </li> <li class=md-tabs__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-tabs__link> Elementary Number Theory </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=MIL class="md-nav__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> MIL </label> <div class=md-nav__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../en/ class=md-nav__link> <span class=md-ellipsis> 目录 </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C01_Introduction/ class=md-nav__link> <span class=md-ellipsis> Introduction </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C02_Basics/ class=md-nav__link> <span class=md-ellipsis> Basics </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C03_Logic/ class=md-nav__link> <span class=md-ellipsis> Logic </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-nav__link> <span class=md-ellipsis> Sets and Functions </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-nav__link> <span class=md-ellipsis> Elementary Number Theory </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#filters class=md-nav__link> <span class=md-ellipsis> Filters </span> </a> </li> <li class=md-nav__item> <a href=#check-filtermap_mono-m-monotone-map-m class=md-nav__link> <span class=md-ellipsis> check (@Filter.map_mono : ∀ {α β} {m : α → β}, Monotone (map m)) </span> </a> </li> <li class=md-nav__item> <a href=#check class=md-nav__link> <span class=md-ellipsis> check </span> </a> </li> <li class=md-nav__item> <a href=#check-comap-q-r-n-x0 class=md-nav__link> <span class=md-ellipsis> check comap ((↑) : ℚ → ℝ) (𝓝 x₀) </span> </a> </li> <li class=md-nav__item> <a href=#check-tendsto-f-comap-q-r-n-x0-n-y0 class=md-nav__link> <span class=md-ellipsis> check Tendsto (f ∘ (↑)) (comap ((↑) : ℚ → ℝ) (𝓝 x₀)) (𝓝 y₀) </span> </a> </li> <li class=md-nav__item> <a href=#check-comap_comap-comap-m-comap-n-f-comap-n-m-f class=md-nav__link> <span class=md-ellipsis> check (comap_comap : comap m (comap n F) = comap (n ∘ m) F) </span> </a> </li> <li class=md-nav__item> <a href=#check-le_inf_iff class=md-nav__link> <span class=md-ellipsis> check le_inf_iff </span> </a> </li> <li class=md-nav__item> <a href=#check-eventually_of_forall class=md-nav__link> <span class=md-ellipsis> check eventually_of_forall </span> </a> </li> <li class=md-nav__item> <a href=#check-eventuallymono class=md-nav__link> <span class=md-ellipsis> check Eventually.mono </span> </a> </li> <li class=md-nav__item> <a href=#check-eventuallyand class=md-nav__link> <span class=md-ellipsis> check Eventually.and </span> </a> </li> <li class=md-nav__item> <a href=#check-mem_closure_iff_clusterpt class=md-nav__link> <span class=md-ellipsis> check mem_closure_iff_clusterPt </span> </a> </li> <li class=md-nav__item> <a href=#check-le_principal_iff class=md-nav__link> <span class=md-ellipsis> check le_principal_iff </span> </a> </li> <li class=md-nav__item> <a href=#check-nebot_of_le class=md-nav__link> <span class=md-ellipsis> check neBot_of_le </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <p>import MIL.Common import Mathlib.Topology.Instances.Real</p> <p>open Set Filter Topology</p> <p>/- TEXT: .. index:: Filter</p> <p>.. _filters:</p> <h2 id=filters>Filters<a class=headerlink href=#filters title="Permanent link">&para;</a></h2> <p>A <em>filter</em> on a type <code>X</code> is a collection of sets of <code>X</code> that satisfies three conditions that we will spell out below. The notion supports two related ideas:</p> <ul> <li> <p><em>limits</em>, including all the kinds of limits discussed above: finite and infinite limits of sequences, finite and infinite limits of functions at a point or at infinity, and so on.</p> </li> <li> <p><em>things happening eventually</em>, including things happening for large enough <code>n : ℕ</code>, or sufficiently near a point <code>x</code>, or for sufficiently close pairs of points, or almost everywhere in the sense of measure theory. Dually, filters can also express the idea of <em>things happening often</em>: for arbitrarily large <code>n</code>, at a point in any neighborhood of a given point, etc.</p> </li> </ul> <p>The filters that correspond to these descriptions will be defined later in this section, but we can already name them:</p> <ul> <li><code>(atTop : Filter ℕ)</code>, made of sets of <code>ℕ</code> containing <code>{n | n ≥ N}</code> for some <code>N</code></li> <li><code>𝓝 x</code>, made of neighborhoods of <code>x</code> in a topological space</li> <li><code>𝓤 X</code>, made of entourages of a uniform space (uniform spaces generalize metric spaces and topological groups)</li> <li><code>μ.ae</code> , made of sets whose complement has zero measure with respect to a measure <code>μ</code>.</li> </ul> <p>The general definition is as follows: a filter <code>F : Filter X</code> is a collection of sets <code>F.sets : Set (Set X)</code> satisfying the following:</p> <ul> <li><code>F.univ_sets : univ ∈ F.sets</code></li> <li><code>F.sets_of_superset : ∀ {U V}, U ∈ F.sets → U ⊆ V → V ∈ F.sets</code></li> <li><code>F.inter_sets : ∀ {U V}, U ∈ F.sets → V ∈ F.sets → U ∩ V ∈ F.sets</code>.</li> </ul> <p>The first condition says that the set of all elements of <code>X</code> belongs to <code>F.sets</code>. The second condition says that if <code>U</code> belongs to <code>F.sets</code> then anything containing <code>U</code> also belongs to <code>F.sets</code>. The third condition says that <code>F.sets</code> is closed under finite intersections. In Mathlib, a filter <code>F</code> is defined to be a structure bundling <code>F.sets</code> and its three properties, but the properties carry no additional data, and it is convenient to blur the distinction between <code>F</code> and <code>F.sets</code>. We therefore define <code>U ∈ F</code> to mean <code>U ∈ F.sets</code>. This explains why the word <code>sets</code> appears in the names of some lemmas that that mention <code>U ∈ F</code>.</p> <p>It may help to think of a filter as defining a notion of a "sufficiently large" set. The first condition then says that <code>univ</code> is sufficiently large, the second one says that a set containing a sufficiently large set is sufficiently large and the third one says that the intersection of two sufficiently large sets is sufficiently large.</p> <p>It may be even more useful to think of a filter on a type <code>X</code> as a generalized element of <code>Set X</code>. For instance, <code>atTop</code> is the "set of very large numbers" and <code>𝓝 x₀</code> is the "set of points very close to <code>x₀</code>." One manifestation of this view is that we can associate to any <code>s : Set X</code> the so-called <em>principal filter</em> consisting of all sets that contain <code>s</code>. This definition is already in Mathlib and has a notation <code>𝓟</code> (localized in the <code>Filter</code> namespace). For the purpose of demonstration, we ask you to take this opportunity to work out the definition here. EXAMPLES: -/ -- QUOTE: def principal {α : Type*} (s : Set α) : Filter α where sets := { t | s ⊆ t } univ_sets := sorry sets_of_superset := sorry inter_sets := sorry -- QUOTE.</p> <p>-- SOLUTIONS: -- In the next example we could use <code>tauto</code> in each proof instead of knowing the lemmas example {α : Type*} (s : Set α) : Filter α := { sets := { t | s ⊆ t } univ_sets := subset_univ s sets_of_superset := fun hU hUV ↦ Subset.trans hU hUV inter_sets := fun hU hV ↦ subset_inter hU hV }</p> <p>/- TEXT: For our second example, we ask you to define the filter <code>atTop : Filter ℕ</code>. (We could use any type with a preorder instead of <code>ℕ</code>.) EXAMPLES: -/ -- QUOTE: example : Filter ℕ := { sets := { s | ∃ a, ∀ b, a ≤ b → b ∈ s } univ_sets := sorry sets_of_superset := sorry inter_sets := sorry } -- QUOTE.</p> <p>-- SOLUTIONS: example : Filter ℕ := { sets := { s | ∃ a, ∀ b, a ≤ b → b ∈ s } univ_sets := by use 42 simp sets_of_superset := by rintro U V ⟨N, hN⟩ hUV use N tauto inter_sets := by rintro U V ⟨N, hN⟩ ⟨N', hN'⟩ use max N N' intro b hb rw [max_le_iff] at hb constructor &lt;;&gt; tauto }</p> <p>/- TEXT: We can also directly define the filter <code>𝓝 x</code> of neighborhoods of any <code>x : ℝ</code>. In the real numbers, a neighborhood of <code>x</code> is a set containing an open interval :math:<code>(x_0 - \varepsilon, x_0 + \varepsilon)</code>, defined in Mathlib as <code>Ioo (x₀ - ε) (x₀ + ε)</code>. (This is notion of a neighborhood is only a special case of a more general construction in Mathlib.)</p> <p>With these examples, we can already define what is means for a function <code>f : X → Y</code> to converge to some <code>G : Filter Y</code> along some <code>F : Filter X</code>, as follows: BOTH: -/ -- QUOTE: def Tendsto₁ {X Y : Type*} (f : X → Y) (F : Filter X) (G : Filter Y) := ∀ V ∈ G, f ⁻¹' V ∈ F -- QUOTE.</p> <p>/- TEXT: When <code>X</code> is <code>ℕ</code> and <code>Y</code> is <code>ℝ</code>, <code>Tendsto₁ u atTop (𝓝 x)</code> is equivalent to saying that the sequence <code>u : ℕ → ℝ</code> converges to the real number <code>x</code>. When both <code>X</code> and <code>Y</code> are <code>ℝ</code>, <code>Tendsto f (𝓝 x₀) (𝓝 y₀)</code> is equivalent to the familiar notion :math:<code>\lim_{x \to x₀} f(x) = y₀</code>. All of the other kinds of limits mentioned in the introduction are also equivalent to instances of <code>Tendsto₁</code> for suitable choices of filters on the source and target.</p> <p>The notion <code>Tendsto₁</code> above is definitionally equivalent to the notion <code>Tendsto</code> that is defined in Mathlib, but the latter is defined more abstractly. The problem with the definition of <code>Tendsto₁</code> is that it exposes a quantifier and elements of <code>G</code>, and it hides the intuition that we get by viewing filters as generalized sets. We can hide the quantifier <code>∀ V</code> and make the intuition more salient by using more algebraic and set-theoretic machinery. The first ingredient is the <em>pushforward</em> operation :math:<code>f_*</code> associated to any map <code>f : X → Y</code>, denoted <code>Filter.map f</code> in Mathlib. Given a filter <code>F</code> on <code>X</code>, <code>Filter.map f F : Filter Y</code> is defined so that <code>V ∈ Filter.map f F ↔ f ⁻¹' V ∈ F</code> holds definitionally. In this examples file we've opened the <code>Filter</code> namespace so that <code>Filter.map</code> can be written as <code>map</code>. This means that we can rewrite the definition of <code>Tendsto</code> using the order relation on <code>Filter Y</code>, which is reversed inclusion of the set of members. In other words, given <code>G H : Filter Y</code>, we have <code>G ≤ H ↔ ∀ V : Set Y, V ∈ H → V ∈ G</code>. EXAMPLES: -/ -- QUOTE: def Tendsto₂ {X Y : Type*} (f : X → Y) (F : Filter X) (G : Filter Y) := map f F ≤ G</p> <p>example {X Y : Type*} (f : X → Y) (F : Filter X) (G : Filter Y) : Tendsto₂ f F G ↔ Tendsto₁ f F G := Iff.rfl -- QUOTE.</p> <p>/- TEXT: It may seem that the order relation on filters is backward. But recall that we can view filters on <code>X</code> as generalized elements of <code>Set X</code>, via the inclusion of <code>𝓟 : Set X → Filter X</code> which maps any set <code>s</code> to the corresponding principal filter. This inclusion is order preserving, so the order relation on <code>Filter</code> can indeed be seen as the natural inclusion relation between generalized sets. In this analogy, pushforward is analogous to the direct image. And, indeed, <code>map f (𝓟 s) = 𝓟 (f '' s)</code>.</p> <p>We can now understand intuitively why a sequence <code>u : ℕ → ℝ</code> converges to a point <code>x₀</code> if and only if we have <code>map u atTop ≤ 𝓝 x₀</code>. The inequality means the "direct image under <code>u</code>" of "the set of very big natural numbers" is "included" in "the set of points very close to <code>x₀</code>."</p> <p>As promised, the definition of <code>Tendsto₂</code> does not exhibit any quantifiers or sets. It also leverages the algebraic properties of the pushforward operation. First, each <code>Filter.map f</code> is monotone. And, second, <code>Filter.map</code> is compatible with composition. EXAMPLES: -/ -- QUOTE:</p> <h1 id=check-filtermap_mono-m-monotone-map-m>check (@Filter.map_mono : ∀ {α β} {m : α → β}, Monotone (map m))<a class=headerlink href=#check-filtermap_mono-m-monotone-map-m title="Permanent link">&para;</a></h1> <h1 id=check>check<a class=headerlink href=#check title="Permanent link">&para;</a></h1> <p>(@Filter.map_map : ∀ {α β γ} {f : Filter α} {m : α → β} {m' : β → γ}, map m' (map m f) = map (m' ∘ m) f) -- QUOTE.</p> <p>/- TEXT: Together these two properties allow us to prove that limits compose, yielding in one shot all 256 variants of the composition lemma described in the introduction, and lots more. You can practice proving the following statement using either the definition of <code>Tendsto₁</code> in terms of the universal quantifier or the algebraic definition, together with the two lemmas above. EXAMPLES: -/ -- QUOTE: example {X Y Z : Type*} {F : Filter X} {G : Filter Y} {H : Filter Z} {f : X → Y} {g : Y → Z} (hf : Tendsto₁ f F G) (hg : Tendsto₁ g G H) : Tendsto₁ (g ∘ f) F H := sorry -- QUOTE.</p> <p>-- SOLUTIONS: example {X Y Z : Type*} {F : Filter X} {G : Filter Y} {H : Filter Z} {f : X → Y} {g : Y → Z} (hf : Tendsto₁ f F G) (hg : Tendsto₁ g G H) : Tendsto₁ (g ∘ f) F H := calc map (g ∘ f) F = map g (map f F) := by rw [map_map] _ ≤ map g G := (map_mono hf) _ ≤ H := hg</p> <p>example {X Y Z : Type*} {F : Filter X} {G : Filter Y} {H : Filter Z} {f : X → Y} {g : Y → Z} (hf : Tendsto₁ f F G) (hg : Tendsto₁ g G H) : Tendsto₁ (g ∘ f) F H := by intro V hV rw [preimage_comp] apply hf apply hg exact hV</p> <p>/- TEXT: The pushforward construction uses a map to push filters from the map source to the map target. There also a <em>pullback</em> operation, <code>Filter.comap</code>, going in the other direction. This generalizes the preimage operation on sets. For any map <code>f</code>, <code>Filter.map f</code> and <code>Filter.comap f</code> form what is known as a <em>Galois connection</em>, which is to say, they satisfy</p> <p><code>Filter.map_le_iff_le_comap : Filter.map f F ≤ G ↔ F ≤ Filter.comap f G</code></p> <p>for every <code>F</code> and <code>G</code>. This operation could be used to provided another formulation of <code>Tendsto</code> that would be provably (but not definitionally) equivalent to the one in Mathlib.</p> <p>The <code>comap</code> operation can be used to restrict filters to a subtype. For instance, suppose we have <code>f : ℝ → ℝ</code>, <code>x₀ : ℝ</code> and <code>y₀ : ℝ</code>, and suppose we want to state that <code>f x</code> approaches <code>y₀</code> when <code>x</code> approaches <code>x₀</code> within the rational numbers. We can pull the filter <code>𝓝 x₀</code> back to <code>ℚ</code> using the coercion map <code>(↑) : ℚ → ℝ</code> and state <code>Tendsto (f ∘ (↑) : ℚ → ℝ) (comap (↑) (𝓝 x₀)) (𝓝 y₀)</code>. EXAMPLES: -/ -- QUOTE: variable (f : ℝ → ℝ) (x₀ y₀ : ℝ)</p> <h1 id=check-comap-q-r-n-x0>check comap ((↑) : ℚ → ℝ) (𝓝 x₀)<a class=headerlink href=#check-comap-q-r-n-x0 title="Permanent link">&para;</a></h1> <h1 id=check-tendsto-f-comap-q-r-n-x0-n-y0>check Tendsto (f ∘ (↑)) (comap ((↑) : ℚ → ℝ) (𝓝 x₀)) (𝓝 y₀)<a class=headerlink href=#check-tendsto-f-comap-q-r-n-x0-n-y0 title="Permanent link">&para;</a></h1> <p>-- QUOTE.</p> <p>/- TEXT: The pullback operation is also compatible with composition, but it is <em>contravariant</em>, which is to say, it reverses the order of the arguments. EXAMPLES: -/ -- QUOTE: section variable {α β γ : Type*} (F : Filter α) {m : γ → β} {n : β → α}</p> <h1 id=check-comap_comap-comap-m-comap-n-f-comap-n-m-f>check (comap_comap : comap m (comap n F) = comap (n ∘ m) F)<a class=headerlink href=#check-comap_comap-comap-m-comap-n-f-comap-n-m-f title="Permanent link">&para;</a></h1> <p>end -- QUOTE.</p> <p>/- TEXT: Let's now shift attention to the plane <code>ℝ × ℝ</code> and try to understand how the neighborhoods of a point <code>(x₀, y₀)</code> are related to <code>𝓝 x₀</code> and <code>𝓝 y₀</code>. There is a product operation <code>Filter.prod : Filter X → Filter Y → Filter (X × Y)</code>, denoted by <code>×ˢ</code>, which answers this question: EXAMPLES: -/ -- QUOTE: example : 𝓝 (x₀, y₀) = 𝓝 x₀ ×ˢ 𝓝 y₀ := nhds_prod_eq -- QUOTE.</p> <p>/- TEXT: The product operation is defined in terms of the pullback operation and the <code>inf</code> operation:</p> <p><code>F ×ˢ G = (comap Prod.fst F) ⊓ (comap Prod.snd G)</code>.</p> <p>Here the <code>inf</code> operation refers to the lattice structure on <code>Filter X</code> for any type <code>X</code>, whereby <code>F ⊓ G</code> is the greatest filter that is smaller than both <code>F</code> and <code>G</code>. Thus the <code>inf</code> operation generalizes the notion of the intersection of sets.</p> <p>A lot of proofs in Mathlib use all of the aforementioned structure (<code>map</code>, <code>comap</code>, <code>inf</code>, <code>sup</code>, and <code>prod</code>) to give algebraic proofs about convergence without ever referring to members of filters. You can practice doing this in a proof of the following lemma, unfolding the definition of <code>Tendsto</code> and <code>Filter.prod</code> if needed. EXAMPLES: -/ -- QUOTE:</p> <h1 id=check-le_inf_iff>check le_inf_iff<a class=headerlink href=#check-le_inf_iff title="Permanent link">&para;</a></h1> <p>example (f : ℕ → ℝ × ℝ) (x₀ y₀ : ℝ) : Tendsto f atTop (𝓝 (x₀, y₀)) ↔ Tendsto (Prod.fst ∘ f) atTop (𝓝 x₀) ∧ Tendsto (Prod.snd ∘ f) atTop (𝓝 y₀) := sorry -- QUOTE.</p> <p>-- SOLUTIONS: example (f : ℕ → ℝ × ℝ) (x₀ y₀ : ℝ) : Tendsto f atTop (𝓝 (x₀, y₀)) ↔ Tendsto (Prod.fst ∘ f) atTop (𝓝 x₀) ∧ Tendsto (Prod.snd ∘ f) atTop (𝓝 y₀) := calc Tendsto f atTop (𝓝 (x₀, y₀)) ↔ map f atTop ≤ 𝓝 (x₀, y₀) := Iff.rfl _ ↔ map f atTop ≤ 𝓝 x₀ ×ˢ 𝓝 y₀ := by rw [nhds_prod_eq] _ ↔ map f atTop ≤ comap Prod.fst (𝓝 x₀) ⊓ comap Prod.snd (𝓝 y₀) := Iff.rfl _ ↔ map f atTop ≤ comap Prod.fst (𝓝 x₀) ∧ map f atTop ≤ comap Prod.snd (𝓝 y₀) := le_inf_iff _ ↔ map Prod.fst (map f atTop) ≤ 𝓝 x₀ ∧ map Prod.snd (map f atTop) ≤ 𝓝 y₀ := by rw [← map_le_iff_le_comap, ← map_le_iff_le_comap] _ ↔ map (Prod.fst ∘ f) atTop ≤ 𝓝 x₀ ∧ map (Prod.snd ∘ f) atTop ≤ 𝓝 y₀ := by rw [map_map, map_map]</p> <p>-- an alternative solution example (f : ℕ → ℝ × ℝ) (x₀ y₀ : ℝ) : Tendsto f atTop (𝓝 (x₀, y₀)) ↔ Tendsto (Prod.fst ∘ f) atTop (𝓝 x₀) ∧ Tendsto (Prod.snd ∘ f) atTop (𝓝 y₀) := by rw [nhds_prod_eq] unfold Tendsto SProd.sprod Filter.instSProd Filter.prod erw [le_inf_iff, ← map_le_iff_le_comap, map_map, ← map_le_iff_le_comap, map_map]</p> <p>/- TEXT: The ordered type <code>Filter X</code> is actually a <em>complete</em> lattice, which is to say, there is a bottom element, there is a top element, and every set of filters on <code>X</code> has an <code>Inf</code> and a <code>Sup</code>.</p> <p>Note that given the second property in the definition of a filter (if <code>U</code> belongs to <code>F</code> then anything larger than <code>U</code> also belongs to <code>F</code>), the first property (the set of all inhabitants of <code>X</code> belongs to <code>F</code>) is equivalent to the property that <code>F</code> is not the empty collection of sets. This shouldn't be confused with the more subtle question as to whether the empty set is an <em>element</em> of <code>F</code>. The definition of a filter does not prohibit <code>∅ ∈ F</code>, but if the empty set is in <code>F</code> then every set is in <code>F</code>, which is to say, <code>∀ U : Set X, U ∈ F</code>. In this case, <code>F</code> is a rather trivial filter, which is precisely the bottom element of the complete lattice <code>Filter X</code>. This contrasts with the definition of filters in Bourbaki, which doesn't allow filters containing the empty set.</p> <p>Because we include the trivial filter in our definition, we sometimes need to explicitly assume nontriviality in some lemmas. In return, however, the theory has nicer global properties. We have already seen that including the trivial filter gives us a bottom element. It also allows us to define <code>principal : Set X → Filter X</code>, which maps <code>∅</code> to <code>⊥</code>, without adding a precondition to rule out the empty set. And it allows us to define the pullback operation without a precondition as well. Indeed, it can happen that <code>comap f F = ⊥</code> although <code>F ≠ ⊥</code>. For instance, given <code>x₀ : ℝ</code> and <code>s : Set ℝ</code>, the pullback of <code>𝓝 x₀</code> under the coercion from the subtype corresponding to <code>s</code> is nontrivial if and only if <code>x₀</code> belongs to the closure of <code>s</code>.</p> <p>In order to manage lemmas that do need to assume some filter is nontrivial, Mathlib has a type class <code>Filter.NeBot</code>, and the library has lemmas that assume <code>(F : Filter X) [F.NeBot]</code>. The instance database knows, for example, that <code>(atTop : Filter ℕ).NeBot</code>, and it knows that pushing forward a nontrivial filter gives a nontrivial filter. As a result, a lemma assuming <code>[F.NeBot]</code> will automatically apply to <code>map u atTop</code> for any sequence <code>u</code>.</p> <p>Our tour of the algebraic properties of filters and their relation to limits is essentially done, but we have not yet justified our claim to have recaptured the usual limit notions. Superficially, it may seem that <code>Tendsto u atTop (𝓝 x₀)</code> is stronger than the notion of convergence defined in :numref:<code>sequences_and_convergence</code> because we ask that <em>every</em> neighborhood of <code>x₀</code> has a preimage belonging to <code>atTop</code>, whereas the usual definition only requires this for the standard neighborhoods <code>Ioo (x₀ - ε) (x₀ + ε)</code>. The key is that, by definition, every neighborhood contains such a standard one. This observation leads to the notion of a <em>filter basis</em>.</p> <p>Given <code>F : Filter X</code>, a family of sets <code>s : ι → Set X</code> is a basis for <code>F</code> if for every set <code>U</code>, we have <code>U ∈ F</code> if and only if it contains some <code>s i</code>. In other words, formally speaking, <code>s</code> is a basis if it satisfies <code>∀ U : Set X, U ∈ F ↔ ∃ i, s i ⊆ U</code>. It is even more flexible to consider a predicate on <code>ι</code> that selects only some of the values <code>i</code> in the indexing type. In the case of <code>𝓝 x₀</code>, we want <code>ι</code> to be <code>ℝ</code>, we write <code>ε</code> for <code>i</code>, and the predicate should select the positive values of <code>ε</code>. So the fact that the sets <code>Ioo (x₀ - ε) (x₀ + ε)</code> form a basis for the neighborhood topology on <code>ℝ</code> is stated as follows: EXAMPLES: -/ -- QUOTE: example (x₀ : ℝ) : HasBasis (𝓝 x₀) (fun ε : ℝ ↦ 0 &lt; ε) fun ε ↦ Ioo (x₀ - ε) (x₀ + ε) := nhds_basis_Ioo_pos x₀ -- QUOTE.</p> <p>/- TEXT: There is also a nice basis for the filter <code>atTop</code>. The lemma <code>Filter.HasBasis.tendsto_iff</code> allows us to reformulate a statement of the form <code>Tendsto f F G</code> given bases for <code>F</code> and <code>G</code>. Putting these pieces together gives us essentially the notion of convergence that we used in :numref:<code>sequences_and_convergence</code>. EXAMPLES: -/ -- QUOTE: example (u : ℕ → ℝ) (x₀ : ℝ) : Tendsto u atTop (𝓝 x₀) ↔ ∀ ε &gt; 0, ∃ N, ∀ n ≥ N, u n ∈ Ioo (x₀ - ε) (x₀ + ε) := by have : atTop.HasBasis (fun _ : ℕ ↦ True) Ici := atTop_basis rw [this.tendsto_iff (nhds_basis_Ioo_pos x₀)] simp -- QUOTE.</p> <p>/- TEXT: We now show how filters facilitate working with properties that hold for sufficiently large numbers or for points that are sufficiently close to a given point. In :numref:<code>sequences_and_convergence</code>, we were often faced with the situation where we knew that some property <code>P n</code> holds for sufficiently large <code>n</code> and that some other property <code>Q n</code> holds for sufficiently large <code>n</code>. Using <code>cases</code> twice gave us <code>N_P</code> and <code>N_Q</code> satisfying <code>∀ n ≥ N_P, P n</code> and <code>∀ n ≥ N_Q, Q n</code>. Using <code>set N := max N_P N_Q</code>, we could eventually prove <code>∀ n ≥ N, P n ∧ Q n</code>. Doing this repeatedly becomes tiresome.</p> <p>We can do better by noting that the statement "<code>P n</code> and <code>Q n</code> hold for large enough <code>n</code>" means that we have <code>{n | P n} ∈ atTop</code> and <code>{n | Q n} ∈ atTop</code>. The fact that <code>atTop</code> is a filter implies that the intersection of two elements of <code>atTop</code> is again in <code>atTop</code>, so we have <code>{n | P n ∧ Q n} ∈ atTop</code>. Writing <code>{n | P n} ∈ atTop</code> is unpleasant, but we can use the more suggestive notation <code>∀ᶠ n in atTop, P n</code>. Here the superscripted <code>f</code> stands for "Filter." You can think of the notation as saying that for all <code>n</code> in the "set of very large numbers," <code>P n</code> holds. The <code>∀ᶠ</code> notation stands for <code>Filter.Eventually</code>, and the lemma <code>Filter.Eventually.and</code> uses the intersection property of filters to do what we just described: EXAMPLES: -/ -- QUOTE: example (P Q : ℕ → Prop) (hP : ∀ᶠ n in atTop, P n) (hQ : ∀ᶠ n in atTop, Q n) : ∀ᶠ n in atTop, P n ∧ Q n := hP.and hQ -- QUOTE.</p> <p>/- TEXT: This notation is so convenient and intuitive that we also have specializations when <code>P</code> is an equality or inequality statement. For example, let <code>u</code> and <code>v</code> be two sequences of real numbers, and let us show that if <code>u n</code> and <code>v n</code> coincide for sufficiently large <code>n</code> then <code>u</code> tends to <code>x₀</code> if and only if <code>v</code> tends to <code>x₀</code>. First we'll use the generic <code>Eventually</code> and then the one specialized for the equality predicate, <code>EventuallyEq</code>. The two statements are definitionally equivalent so the same proof work in both cases. EXAMPLES: -/ -- QUOTE: example (u v : ℕ → ℝ) (h : ∀ᶠ n in atTop, u n = v n) (x₀ : ℝ) : Tendsto u atTop (𝓝 x₀) ↔ Tendsto v atTop (𝓝 x₀) := tendsto_congr' h</p> <p>example (u v : ℕ → ℝ) (h : u =ᶠ[atTop] v) (x₀ : ℝ) : Tendsto u atTop (𝓝 x₀) ↔ Tendsto v atTop (𝓝 x₀) := tendsto_congr' h -- QUOTE.</p> <p>/- TEXT: It is instructive to review the definition of filters in terms of <code>Eventually</code>. Given <code>F : Filter X</code>, for any predicates <code>P</code> and <code>Q</code> on <code>X</code>,</p> <ul> <li>the condition <code>univ ∈ F</code> ensures <code>(∀ x, P x) → ∀ᶠ x in F, P x</code>,</li> <li>the condition <code>U ∈ F → U ⊆ V → V ∈ F</code> ensures <code>(∀ᶠ x in F, P x) → (∀ x, P x → Q x) → ∀ᶠ x in F, Q x</code>, and</li> <li>the condition <code>U ∈ F → V ∈ F → U ∩ V ∈ F</code> ensures <code>(∀ᶠ x in F, P x) → (∀ᶠ x in F, Q x) → ∀ᶠ x in F, P x ∧ Q x</code>. EXAMPLES: -/ -- QUOTE:</li> </ul> <h1 id=check-eventually_of_forall>check eventually_of_forall<a class=headerlink href=#check-eventually_of_forall title="Permanent link">&para;</a></h1> <h1 id=check-eventuallymono>check Eventually.mono<a class=headerlink href=#check-eventuallymono title="Permanent link">&para;</a></h1> <h1 id=check-eventuallyand>check Eventually.and<a class=headerlink href=#check-eventuallyand title="Permanent link">&para;</a></h1> <p>-- QUOTE.</p> <p>/- TEXT: The second item, corresponding to <code>Eventually.mono</code>, supports nice ways of using filters, especially when combined with <code>Eventually.and</code>. The <code>filter_upwards</code> tactic allows us to combine them. Compare: EXAMPLES: -/ -- QUOTE: example (P Q R : ℕ → Prop) (hP : ∀ᶠ n in atTop, P n) (hQ : ∀ᶠ n in atTop, Q n) (hR : ∀ᶠ n in atTop, P n ∧ Q n → R n) : ∀ᶠ n in atTop, R n := by apply (hP.and (hQ.and hR)).mono rintro n ⟨h, h', h''⟩ exact h'' ⟨h, h'⟩</p> <p>example (P Q R : ℕ → Prop) (hP : ∀ᶠ n in atTop, P n) (hQ : ∀ᶠ n in atTop, Q n) (hR : ∀ᶠ n in atTop, P n ∧ Q n → R n) : ∀ᶠ n in atTop, R n := by filter_upwards [hP, hQ, hR] with n h h' h'' exact h'' ⟨h, h'⟩ -- QUOTE.</p> <p>/- TEXT: Readers who know about measure theory will note that the filter <code>μ.ae</code> of sets whose complement has measure zero (aka "the set consisting of almost every point") is not very useful as the source or target of <code>Tendsto</code>, but it can be conveniently used with <code>Eventually</code> to say that a property holds for almost every point.</p> <p>There is a dual version of <code>∀ᶠ x in F, P x</code>, which is occasionally useful: <code>∃ᶠ x in F, P x</code> means <code>{x | ¬P x} ∉ F</code>. For example, <code>∃ᶠ n in atTop, P n</code> means there are arbitrarily large <code>n</code> such that <code>P n</code> holds. The <code>∃ᶠ</code> notation stands for <code>Filter.Frequently</code>.</p> <p>For a more sophisticated example, consider the following statement about a sequence <code>u</code>, a set <code>M</code>, and a value <code>x</code>:</p> <p>If <code>u</code> converges to <code>x</code> and <code>u n</code> belongs to <code>M</code> for sufficiently large <code>n</code> then <code>x</code> is in the closure of <code>M</code>.</p> <p>This can be formalized as follows:</p> <p><code>Tendsto u atTop (𝓝 x) → (∀ᶠ n in atTop, u n ∈ M) → x ∈ closure M</code>.</p> <p>This is a special case of the theorem <code>mem_closure_of_tendsto</code> from the topology library. See if you can prove it using the quoted lemmas, using the fact that <code>ClusterPt x F</code> means <code>(𝓝 x ⊓ F).NeBot</code> and that, by definition, the assumption <code>∀ᶠ n in atTop, u n ∈ M</code> means <code>M ∈ map u atTop</code>. EXAMPLES: -/ -- QUOTE:</p> <h1 id=check-mem_closure_iff_clusterpt>check mem_closure_iff_clusterPt<a class=headerlink href=#check-mem_closure_iff_clusterpt title="Permanent link">&para;</a></h1> <h1 id=check-le_principal_iff>check le_principal_iff<a class=headerlink href=#check-le_principal_iff title="Permanent link">&para;</a></h1> <h1 id=check-nebot_of_le>check neBot_of_le<a class=headerlink href=#check-nebot_of_le title="Permanent link">&para;</a></h1> <p>example (u : ℕ → ℝ) (M : Set ℝ) (x : ℝ) (hux : Tendsto u atTop (𝓝 x)) (huM : ∀ᶠ n in atTop, u n ∈ M) : x ∈ closure M := sorry -- QUOTE.</p> <p>-- SOLUTIONS: example (u : ℕ → ℝ) (M : Set ℝ) (x : ℝ) (hux : Tendsto u atTop (𝓝 x)) (huM : ∀ᶠ n in atTop, u n ∈ M) : x ∈ closure M := mem_closure_iff_clusterPt.mpr (neBot_of_le &lt;| le_inf hux &lt;| le_principal_iff.mpr huM)</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.sections", "navigation.instant", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"alias": true, "default": "latest", "provider": "mike"}}</script> <script src=../../../assets/javascripts/bundle.fe8b6f2b.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>