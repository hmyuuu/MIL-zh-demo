<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.0, mkdocs-material-9.5.31"><title>S03 Topological Spaces - MIL</title><link rel=stylesheet href=../../../assets/stylesheets/main.3cba04c6.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../assets/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent=light-green> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#topological-spaces class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <div data-md-color-scheme=default data-md-component=outdated hidden> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=MIL class="md-header__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> MIL </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> S03 Topological Spaces </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../en/ class=md-tabs__link> 目录 </a> </li> <li class=md-tabs__item> <a href=../../../en/C01_Introduction/ class=md-tabs__link> Introduction </a> </li> <li class=md-tabs__item> <a href=../../../en/C02_Basics/ class=md-tabs__link> Basics </a> </li> <li class=md-tabs__item> <a href=../../../en/C03_Logic/ class=md-tabs__link> Logic </a> </li> <li class=md-tabs__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-tabs__link> Sets and Functions </a> </li> <li class=md-tabs__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-tabs__link> Elementary Number Theory </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=MIL class="md-nav__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> MIL </label> <div class=md-nav__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../en/ class=md-nav__link> <span class=md-ellipsis> 目录 </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C01_Introduction/ class=md-nav__link> <span class=md-ellipsis> Introduction </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C02_Basics/ class=md-nav__link> <span class=md-ellipsis> Basics </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C03_Logic/ class=md-nav__link> <span class=md-ellipsis> Logic </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-nav__link> <span class=md-ellipsis> Sets and Functions </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-nav__link> <span class=md-ellipsis> Elementary Number Theory </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#topological-spaces class=md-nav__link> <span class=md-ellipsis> Topological spaces </span> </a> </li> <li class=md-nav__item> <a href=#check-topologicalspacemkofnhds class=md-nav__link> <span class=md-ellipsis> check TopologicalSpace.mkOfNhds </span> </a> </li> <li class=md-nav__item> <a href=#check-topologicalspacenhds_mkofnhds class=md-nav__link> <span class=md-ellipsis> check TopologicalSpace.nhds_mkOfNhds </span> </a> </li> <li class=md-nav__item> <a href=#check-coinduced_compose class=md-nav__link> <span class=md-ellipsis> check coinduced_compose </span> </a> </li> <li class=md-nav__item> <a href=#check-induced_compose class=md-nav__link> <span class=md-ellipsis> check induced_compose </span> </a> </li> <li class=md-nav__item> <a href=#check-hasbasistendsto_right_iff class=md-nav__link> <span class=md-ellipsis> check HasBasis.tendsto_right_iff </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <p>import MIL.Common import Mathlib.Topology.Instances.Real import Mathlib.Analysis.NormedSpace.BanachSteinhaus</p> <p>open Set Filter Topology</p> <p>/- TEXT: .. index:: topological space</p> <p>.. _topological_spaces:</p> <h2 id=topological-spaces>Topological spaces<a class=headerlink href=#topological-spaces title="Permanent link">&para;</a></h2> <p>Fundamentals <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup></p> <p>We now go up in generality and introduce topological spaces. We will review the two main ways to define topological spaces and then explain how the category of topological spaces is much better behaved than the category of metric spaces. Note that we won't be using Mathlib category theory here, only having a somewhat categorical point of view.</p> <p>The first way to think about the transition from metric spaces to topological spaces is that we only remember the notion of open sets (or equivalently the notion of closed sets). From this point of view, a topological space is a type equipped with a collection of sets that are called open sets. This collection has to satisfy a number of axioms presented below (this collection is slightly redundant but we will ignore that). BOTH: -/ -- QUOTE: section variable {X : Type*} [TopologicalSpace X]</p> <p>example : IsOpen (univ : Set X) := isOpen_univ</p> <p>example : IsOpen (∅ : Set X) := isOpen_empty</p> <p>example {ι : Type*} {s : ι → Set X} (hs : ∀ i, IsOpen (s i)) : IsOpen (⋃ i, s i) := isOpen_iUnion hs</p> <p>example {ι : Type*} [Fintype ι] {s : ι → Set X} (hs : ∀ i, IsOpen (s i)) : IsOpen (⋂ i, s i) := isOpen_iInter_of_finite hs -- QUOTE.</p> <p>/- TEXT:</p> <p>Closed sets are then defined as sets whose complement is open. A function between topological spaces is (globally) continuous if all preimages of open sets are open. BOTH: -/ -- QUOTE: variable {Y : Type*} [TopologicalSpace Y]</p> <p>example {f : X → Y} : Continuous f ↔ ∀ s, IsOpen s → IsOpen (f ⁻¹' s) := continuous_def -- QUOTE.</p> <p>/- TEXT: With this definition we already see that, compared to metric spaces, topological spaces only remember enough information to talk about continuous functions: two topological structures on a type are the same if and only if they have the same continuous functions (indeed the identity function will be continuous in both direction if and only if the two structures have the same open sets).</p> <p>However as soon as we move on to continuity at a point we see the limitations of the approach based on open sets. In Mathlib we frequently think of topological spaces as types equipped with a neighborhood filter <code>𝓝 x</code> attached to each point <code>x</code> (the corresponding function <code>X → Filter X</code> satisfies certain conditions explained further down). Remember from the filters section that these gadgets play two related roles. First <code>𝓝 x</code> is seen as the generalized set of points of <code>X</code> that are close to <code>x</code>. And then it is seen as giving a way to say, for any predicate <code>P : X → Prop</code>, that this predicate holds for points that are close enough to <code>x</code>. Let us state that <code>f : X → Y</code> is continuous at <code>x</code>. The purely filtery way is to say that the direct image under <code>f</code> of the generalized set of points that are close to <code>x</code> is contained in the generalized set of points that are close to <code>f x</code>. Recall this is spelled either <code>map f (𝓝 x) ≤ 𝓝 (f x)</code> or <code>Tendsto f (𝓝 x) (𝓝 (f x))</code>.</p> <p>BOTH: -/ -- QUOTE: example {f : X → Y} {x : X} : ContinuousAt f x ↔ map f (𝓝 x) ≤ 𝓝 (f x) := Iff.rfl -- QUOTE.</p> <p>/- TEXT: One can also spell it using both neighborhoods seen as ordinary sets and a neighborhood filter seen as a generalized set: "for any neighborhood <code>U</code> of <code>f x</code>, all points close to <code>x</code> are sent to <code>U</code>". Note that the proof is again <code>iff.rfl</code>, this point of view is definitionally equivalent to the previous one.</p> <p>BOTH: -/ -- QUOTE: example {f : X → Y} {x : X} : ContinuousAt f x ↔ ∀ U ∈ 𝓝 (f x), ∀ᶠ x in 𝓝 x, f x ∈ U := Iff.rfl -- QUOTE.</p> <p>/- TEXT: We now explain how to go from one point of view to the other. In terms of open sets, we can simply define members of <code>𝓝 x</code> as sets that contain an open set containing <code>x</code>.</p> <p>BOTH: -/ -- QUOTE: example {x : X} {s : Set X} : s ∈ 𝓝 x ↔ ∃ t, t ⊆ s ∧ IsOpen t ∧ x ∈ t := mem_nhds_iff -- QUOTE.</p> <p>/- TEXT: To go in the other direction we need to discuss the condition that <code>𝓝 : X → Filter X</code> must satisfy in order to be the neighborhood function of a topology.</p> <p>The first constraint is that <code>𝓝 x</code>, seen as a generalized set, contains the set <code>{x}</code> seen as the generalized set <code>pure x</code> (explaining this weird name would be too much of a digression, so we simply accept it for now). Another way to say it is that if a predicate holds for points close to <code>x</code> then it holds at <code>x</code>.</p> <p>BOTH: -/ -- QUOTE: example (x : X) : pure x ≤ 𝓝 x := pure_le_nhds x</p> <p>example (x : X) (P : X → Prop) (h : ∀ᶠ y in 𝓝 x, P y) : P x := h.self_of_nhds -- QUOTE.</p> <p>/- TEXT: Then a more subtle requirement is that, for any predicate <code>P : X → Prop</code> and any <code>x</code>, if <code>P y</code> holds for <code>y</code> close to <code>x</code> then for <code>y</code> close to <code>x</code> and <code>z</code> close to <code>y</code>, <code>P z</code> holds. More precisely we have: BOTH: -/ -- QUOTE: example {P : X → Prop} {x : X} (h : ∀ᶠ y in 𝓝 x, P y) : ∀ᶠ y in 𝓝 x, ∀ᶠ z in 𝓝 y, P z := eventually_eventually_nhds.mpr h -- QUOTE.</p> <p>/- TEXT: Those two results characterize the functions <code>X → Filter X</code> that are neighborhood functions for a topological space structure on <code>X</code>. There is a still a function <code>TopologicalSpace.mkOfNhds : (X → Filter X) → TopologicalSpace X</code> but it will give back its input as a neighborhood function only if it satisfies the above two constraints. More precisely we have a lemma <code>TopologicalSpace.nhds_mkOfNhds</code> saying that in a different way and our next exercise deduces this different way from how we stated it above. BOTH: -/</p> <h1 id=check-topologicalspacemkofnhds>check TopologicalSpace.mkOfNhds<a class=headerlink href=#check-topologicalspacemkofnhds title="Permanent link">&para;</a></h1> <h1 id=check-topologicalspacenhds_mkofnhds>check TopologicalSpace.nhds_mkOfNhds<a class=headerlink href=#check-topologicalspacenhds_mkofnhds title="Permanent link">&para;</a></h1> <p>-- QUOTE: example {α : Type*} (n : α → Filter α) (H₀ : ∀ a, pure a ≤ n a) (H : ∀ a : α, ∀ p : α → Prop, (∀ᶠ x in n a, p x) → ∀ᶠ y in n a, ∀ᶠ x in n y, p x) : ∀ a, ∀ s ∈ n a, ∃ t ∈ n a, t ⊆ s ∧ ∀ a' ∈ t, s ∈ n a' := sorry -- QUOTE.</p> <p>-- SOLUTIONS: example {α : Type*} (n : α → Filter α) (H₀ : ∀ a, pure a ≤ n a) (H : ∀ a : α, ∀ p : α → Prop, (∀ᶠ x in n a, p x) → ∀ᶠ y in n a, ∀ᶠ x in n y, p x) : ∀ a, ∀ s ∈ n a, ∃ t ∈ n a, t ⊆ s ∧ ∀ a' ∈ t, s ∈ n a' := by intro a s s_in refine' ⟨{ y | s ∈ n y }, H a (fun x ↦ x ∈ s) s_in, _, by tauto⟩ rintro y (hy : s ∈ n y) exact H₀ y hy</p> <p>-- BOTH: end</p> <p>-- BOTH. /- TEXT: Note that <code>TopologicalSpace.mkOfNhds</code> is not so frequently used, but it still good to know in what precise sense the neighborhood filters is all there is in a topological space structure.</p> <p>The next thing to know in order to efficiently use topological spaces in Mathlib is that we use a lot of formal properties of <code>TopologicalSpace : Type u → Type u</code>. From a purely mathematical point of view, those formal properties are a very clean way to explain how topological spaces solve issues that metric spaces have. From this point of view, the issues solved by topological spaces is that metric spaces enjoy very little functoriality, and have very bad categorical properties in general. This comes on top of the fact already discussed that metric spaces contain a lot of geometrical information that is not topologically relevant.</p> <p>Let us focus on functoriality first. A metric space structure can be induced on a subset or, equivalently, it can be pulled back by an injective map. But that's pretty much everything. They cannot be pulled back by general map or pushed forward, even by surjective maps.</p> <p>In particular there is no sensible distance to put on a quotient of a metric space or on an uncountable products of metric spaces. Consider for instance the type <code>ℝ → ℝ</code>, seen as a product of copies of <code>ℝ</code> indexed by <code>ℝ</code>. We would like to say that pointwise convergence of sequences of functions is a respectable notion of convergence. But there is no distance on <code>ℝ → ℝ</code> that gives this notion of convergence. Relatedly, there is no distance ensuring that a map <code>f : X → (ℝ → ℝ)</code> is continuous if and only if <code>fun x ↦ f x t</code> is continuous for every <code>t : ℝ</code>.</p> <p>We now review the data used to solve all those issues. First we can use any map <code>f : X → Y</code> to push or pull topologies from one side to the other. Those two operations form a Galois connection.</p> <p>BOTH: -/ -- QUOTE: variable {X Y : Type*}</p> <p>example (f : X → Y) : TopologicalSpace X → TopologicalSpace Y := TopologicalSpace.coinduced f</p> <p>example (f : X → Y) : TopologicalSpace Y → TopologicalSpace X := TopologicalSpace.induced f</p> <p>example (f : X → Y) (T_X : TopologicalSpace X) (T_Y : TopologicalSpace Y) : TopologicalSpace.coinduced f T_X ≤ T_Y ↔ T_X ≤ TopologicalSpace.induced f T_Y := coinduced_le_iff_le_induced -- QUOTE.</p> <p>/- TEXT: Those operations are compactible with composition of functions. As usual, pushing forward is covariant and pulling back is contravariant, see <code>coinduced_compose</code> and <code>induced_compose</code>. On paper we will use notations :math:<code>f_*T</code> for <code>TopologicalSpace.coinduced f T</code> and :math:<code>f^*T</code> for <code>TopologicalSpace.induced f T</code>. BOTH: -/</p> <h1 id=check-coinduced_compose>check coinduced_compose<a class=headerlink href=#check-coinduced_compose title="Permanent link">&para;</a></h1> <h1 id=check-induced_compose>check induced_compose<a class=headerlink href=#check-induced_compose title="Permanent link">&para;</a></h1> <p>/- TEXT:</p> <p>Then the next big piece is a complete lattice structure on <code>TopologicalSpace X</code> for any given structure. If you think of topologies as being primarily the data of open sets then you expect the order relation on <code>TopologicalSpace X</code> to come from <code>Set (Set X)</code>, ie you expect <code>t ≤ t'</code> if a set <code>u</code> is open for <code>t'</code> as soon as it is open for <code>t</code>. However we already know that Mathlib focuses on neighborhoods more than open sets so, for any <code>x : X</code> we want the map from topological spaces to neighborhoods <code>fun T : TopologicalSpace X ↦ @nhds X T x</code> to be order preserving. And we know the order relation on <code>Filter X</code> is designed to ensure an order preserving <code>principal : Set X → Filter X</code>, allowing to see filters as generalized sets. So the order relation we do use on <code>TopologicalSpace X</code> is opposite to the one coming from <code>Set (Set X)</code>.</p> <p>BOTH: -/ -- QUOTE: example {T T' : TopologicalSpace X} : T ≤ T' ↔ ∀ s, T'.IsOpen s → T.IsOpen s := Iff.rfl -- QUOTE.</p> <p>/- TEXT:</p> <p>Now we can recover continuity by combining the push-forward (or pull-back) operation with the order relation.</p> <p>BOTH: -/ -- QUOTE: example (T_X : TopologicalSpace X) (T_Y : TopologicalSpace Y) (f : X → Y) : Continuous f ↔ TopologicalSpace.coinduced f T_X ≤ T_Y := continuous_iff_coinduced_le -- QUOTE.</p> <p>/- TEXT: With this definition and the compatibility of push-forward and composition, we get for free the universal property that, for any topological space :math:<code>Z</code>, a function :math:<code>g : Y → Z</code> is continuous for the topology :math:<code>f_*T_X</code> if and only if :math:<code>g ∘ f</code> is continuous.</p> <p>.. math:: g \text{ continuous } &amp;⇔ g_<em>(f_*T_X) ≤ T_Z \ &amp;⇔ (g ∘ f)_</em> T_X ≤ T_Z \ &amp;⇔ g ∘ f \text{ continuous}</p> <p>BOTH: -/ -- QUOTE: example {Z : Type*} (f : X → Y) (T_X : TopologicalSpace X) (T_Z : TopologicalSpace Z) (g : Y → Z) : @Continuous Y Z (TopologicalSpace.coinduced f T_X) T_Z g ↔ @Continuous X Z T_X T_Z (g ∘ f) := by rw [continuous_iff_coinduced_le, coinduced_compose, continuous_iff_coinduced_le] -- QUOTE.</p> <p>/- TEXT: So we already get quotient topologies (using the projection map as <code>f</code>). This wasn't using that <code>TopologicalSpace X</code> is a complete lattice for all <code>X</code>. Let's now see how all this structure proves the existence of the product topology by abstract non-sense. We considered the case of <code>ℝ → ℝ</code> above, but let's now consider the general case of <code>Π i, X i</code> for some <code>ι : Type*</code> and <code>X : ι → Type*</code>. We want, for any topological space <code>Z</code> and any function <code>f : Z → Π i, X i</code>, that <code>f</code> is continuous if and only if <code>(fun x ↦ x i) ∘ f</code> is continuous for all <code>i</code>. Let us explore that constraint "on paper" using notation :math:<code>p_i</code> for the projection <code>(fun (x : Π i, X i) ↦ x i)</code>:</p> <p>.. math:: (∀ i, p_i ∘ f \text{ continuous}) &amp;⇔ ∀ i, (p_i ∘ f)<em>* T_Z ≤ T</em>{X_i} \ &amp;⇔ ∀ i, (p_i)<em>* f</em>* T_Z ≤ T_{X_i}\ &amp;⇔ ∀ i, f_* T_Z ≤ (p_i)^<em>T_{X_i}\ &amp;⇔ f_</em> T_Z ≤ \inf \left[(p_i)^*T_{X_i}\right]</p> <p>So we see that what is the topology we want on <code>Π i, X i</code>: BOTH: -/ -- QUOTE: example (ι : Type*) (X : ι → Type*) (T_X : ∀ i, TopologicalSpace (X i)) : (Pi.topologicalSpace : TopologicalSpace (∀ i, X i)) = ⨅ i, TopologicalSpace.induced (fun x ↦ x i) (T_X i) := rfl -- QUOTE.</p> <p>/- TEXT:</p> <p>This ends our tour of how Mathlib thinks that topological spaces fix defects of the theory of metric spaces by being a more functorial theory and having a complete lattice structure for any fixed type.</p> <p>Separation and countability <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup></p> <p>We saw that the category of topological spaces have very nice properties. The price to pay for this is existence of rather pathological topological spaces. There are a number of assumptions you can make on a topological space to ensure its behavior is closer to what metric spaces do. The most important is <code>T2Space</code>, also called "Hausdorff", that will ensure that limits are unique. A stronger separation property is <code>T3Space</code> that ensures in addition the <code>RegularSpace</code> property: each point has a basis of closed neighborhoods.</p> <p>BOTH: -/ -- QUOTE: example [TopologicalSpace X] [T2Space X] {u : ℕ → X} {a b : X} (ha : Tendsto u atTop (𝓝 a)) (hb : Tendsto u atTop (𝓝 b)) : a = b := tendsto_nhds_unique ha hb</p> <p>example [TopologicalSpace X] [RegularSpace X] (a : X) : (𝓝 a).HasBasis (fun s : Set X ↦ s ∈ 𝓝 a ∧ IsClosed s) id := closed_nhds_basis a -- QUOTE.</p> <p>/- TEXT: Note that, in every topological space, each point has a basis of open neighborhood, by definition.</p> <p>BOTH: -/ -- QUOTE: example [TopologicalSpace X] {x : X} : (𝓝 x).HasBasis (fun t : Set X ↦ t ∈ 𝓝 x ∧ IsOpen t) id := nhds_basis_opens' x -- QUOTE.</p> <p>/- TEXT: Our main goal is now to prove the basic theorem which allows extension by continuity. From Bourbaki's general topology book, I.8.5, Theorem 1 (taking only the non-trivial implication):</p> <p>Let :math:<code>X</code> be a topological space, :math:<code>A</code> a dense subset of :math:<code>X</code>, :math:<code>f : A → Y</code> a continuous mapping of :math:<code>A</code> into a :math:<code>T_3</code> space :math:<code>Y</code>. If, for each :math:<code>x</code> in :math:<code>X</code>, :math:<code>f(y)</code> tends to a limit in :math:<code>Y</code> when :math:<code>y</code> tends to :math:<code>x</code> while remaining in :math:<code>A</code> then there exists a continuous extension :math:<code>φ</code> of :math:<code>f</code> to :math:<code>X</code>.</p> <p>Actually Mathlib contains a more general version of the above lemma, <code>DenseInducing.continuousAt_extend</code>, but we'll stick to Bourbaki's version here.</p> <p>Remember that, given <code>A : Set X</code>, <code>↥A</code> is the subtype associated to <code>A</code>, and Lean will automatically insert that funny up arrow when needed. And the (inclusion) coercion map is <code>(↑) : A → X</code>. The assumption "tends to :math:<code>x</code> while remaining in :math:<code>A</code>" corresponds to the pull-back filter <code>comap (↑) (𝓝 x)</code>.</p> <p>Let's first prove an auxiliary lemma, extracted to simplify the context (in particular we don't need Y to be a topological space here).</p> <p>BOTH: -/ -- QUOTE: theorem aux {X Y A : Type*} [TopologicalSpace X] {c : A → X} {f : A → Y} {x : X} {F : Filter Y} (h : Tendsto f (comap c (𝓝 x)) F) {V' : Set Y} (V'_in : V' ∈ F) : ∃ V ∈ 𝓝 x, IsOpen V ∧ c ⁻¹' V ⊆ f ⁻¹' V' := by /- EXAMPLES: sorry</p> <p>SOLUTIONS: -/ simpa [and_assoc] using ((nhds_basis_opens' x).comap c).tendsto_left_iff.mp h V' V'_in -- QUOTE.</p> <p>/- TEXT: Let's now turn to the main proof of the extension by continuity theorem.</p> <p>When Lean needs a topology on <code>↥A</code> it will automatically use the induced topology. The only relevant lemma is <code>nhds_induced (↑) : ∀ a : ↥A, 𝓝 a = comap (↑) (𝓝 ↑a)</code> (this is actually a general lemma about induced topologies).</p> <p>The proof outline is:</p> <p>The main assumption and the axiom of choice give a function <code>φ</code> such that <code>∀ x, Tendsto f (comap (↑) (𝓝 x)) (𝓝 (φ x))</code> (because <code>Y</code> is Hausdorff, <code>φ</code> is entirely determined, but we won't need that until we try to prove that <code>φ</code> indeed extends <code>f</code>).</p> <p>Let's first prove <code>φ</code> is continuous. Fix any <code>x : X</code>. Since <code>Y</code> is regular, it suffices to check that for every <em>closed</em> neighborhood <code>V'</code> of <code>φ x</code>, <code>φ ⁻¹' V' ∈ 𝓝 x</code>. The limit assumption gives (through the auxiliary lemma above) some <code>V ∈ 𝓝 x</code> such <code>IsOpen V ∧ (↑) ⁻¹' V ⊆ f ⁻¹' V'</code>. Since <code>V ∈ 𝓝 x</code>, it suffices to prove <code>V ⊆ φ ⁻¹' V'</code>, ie <code>∀ y ∈ V, φ y ∈ V'</code>. Let's fix <code>y</code> in <code>V</code>. Because <code>V</code> is <em>open</em>, it is a neighborhood of <code>y</code>. In particular <code>(↑) ⁻¹' V ∈ comap (↑) (𝓝 y)</code> and a fortiori <code>f ⁻¹' V' ∈ comap (↑) (𝓝 y)</code>. In addition <code>comap (↑) (𝓝 y) ≠ ⊥</code> because <code>A</code> is dense. Because we know <code>Tendsto f (comap (↑) (𝓝 y)) (𝓝 (φ y))</code> this implies <code>φ y ∈ closure V'</code> and, since <code>V'</code> is closed, we have proved <code>φ y ∈ V'</code>.</p> <p>It remains to prove that <code>φ</code> extends <code>f</code>. This is where the continuity of <code>f</code> enters the discussion, together with the fact that <code>Y</code> is Hausdorff. BOTH: -/ -- QUOTE: example [TopologicalSpace X] [TopologicalSpace Y] [T3Space Y] {A : Set X} (hA : ∀ x, x ∈ closure A) {f : A → Y} (f_cont : Continuous f) (hf : ∀ x : X, ∃ c : Y, Tendsto f (comap (↑) (𝓝 x)) (𝓝 c)) : ∃ φ : X → Y, Continuous φ ∧ ∀ a : A, φ a = f a := by /- EXAMPLES: sorry</p> <h1 id=check-hasbasistendsto_right_iff>check HasBasis.tendsto_right_iff<a class=headerlink href=#check-hasbasistendsto_right_iff title="Permanent link">&para;</a></h1> <p>SOLUTIONS: -/ choose φ hφ using hf use φ constructor · rw [continuous_iff_continuousAt] intro x suffices ∀ V' ∈ 𝓝 (φ x), IsClosed V' → φ ⁻¹' V' ∈ 𝓝 x by simpa [ContinuousAt, (closed_nhds_basis (φ x)).tendsto_right_iff] intro V' V'_in V'_closed obtain ⟨V, V_in, V_op, hV⟩ : ∃ V ∈ 𝓝 x, IsOpen V ∧ (↑) ⁻¹' V ⊆ f ⁻¹' V' := aux (hφ x) V'_in suffices : ∀ y ∈ V, φ y ∈ V' exact mem_of_superset V_in this intro y y_in have hVx : V ∈ 𝓝 y := V_op.mem_nhds y_in haveI : (comap ((↑) : A → X) (𝓝 y)).NeBot := by simpa [mem_closure_iff_comap_neBot] using hA y apply V'_closed.mem_of_tendsto (hφ y) exact mem_of_superset (preimage_mem_comap hVx) hV · intro a have lim : Tendsto f (𝓝 a) (𝓝 (φ a)) := by simpa [nhds_induced] using hφ a exact tendsto_nhds_unique lim f_cont.continuousAt -- QUOTE.</p> <p>/- TEXT: In addition to separation property, the main kind of assumption you can make on a topological space to bring it closer to metric spaces is countability assumption. The main one is first countability asking that every point has a countable neighborhood basis. In particular this ensures that closure of sets can be understood using sequences.</p> <p>BOTH: -/ -- QUOTE: example [TopologicalSpace X] [FirstCountableTopology X] {s : Set X} {a : X} : a ∈ closure s ↔ ∃ u : ℕ → X, (∀ n, u n ∈ s) ∧ Tendsto u atTop (𝓝 a) := mem_closure_iff_seq_limit -- QUOTE.</p> <p>/- TEXT: Compactness <sup>^</sup><sup>^</sup><sup>^</sup>^^</p> <p>Let us now discuss how compactness is defined for topological spaces. As usual there are several ways to think about it and Mathlib goes for the filter version.</p> <p>We first need to define cluster points of filters. Given a filter <code>F</code> on a topological space <code>X</code>, a point <code>x : X</code> is a cluster point of <code>F</code> if <code>F</code>, seen as a generalized set, has non-empty intersection with the generalized set of points that are close to <code>x</code>.</p> <p>Then we can say that a set <code>s</code> is compact if every nonempty generalized set <code>F</code> contained in <code>s</code>, ie such that <code>F ≤ 𝓟 s</code>, has a cluster point in <code>s</code>.</p> <p>BOTH: -/ -- QUOTE: variable [TopologicalSpace X]</p> <p>example {F : Filter X} {x : X} : ClusterPt x F ↔ NeBot (𝓝 x ⊓ F) := Iff.rfl</p> <p>example {s : Set X} : IsCompact s ↔ ∀ (F : Filter X) [NeBot F], F ≤ 𝓟 s → ∃ a ∈ s, ClusterPt a F := Iff.rfl -- QUOTE.</p> <p>/- TEXT: For instance if <code>F</code> is <code>map u atTop</code>, the image under <code>u : ℕ → X</code> of <code>atTop</code>, the generalized set of very large natural numbers, then the assumption <code>F ≤ 𝓟 s</code> means that <code>u n</code> belongs to <code>s</code> for <code>n</code> large enough. Saying that <code>x</code> is a cluster point of <code>map u atTop</code> says the image of very large numbers intersects the set of points that are close to <code>x</code>. In case <code>𝓝 x</code> has a countable basis, we can interpret this as saying that <code>u</code> has a subsequence converging to <code>x</code>, and we get back what compactness looks like in metric spaces. BOTH: -/ -- QUOTE: example [FirstCountableTopology X] {s : Set X} {u : ℕ → X} (hs : IsCompact s) (hu : ∀ n, u n ∈ s) : ∃ a ∈ s, ∃ φ : ℕ → ℕ, StrictMono φ ∧ Tendsto (u ∘ φ) atTop (𝓝 a) := hs.tendsto_subseq hu -- QUOTE.</p> <p>/- TEXT: Cluster points behave nicely with continuous functions.</p> <p>BOTH: -/ -- QUOTE: variable [TopologicalSpace Y]</p> <p>example {x : X} {F : Filter X} {G : Filter Y} (H : ClusterPt x F) {f : X → Y} (hfx : ContinuousAt f x) (hf : Tendsto f F G) : ClusterPt (f x) G := ClusterPt.map H hfx hf -- QUOTE.</p> <p>/- TEXT: As an exercise, we will prove that the image of a compact set under a continuous map is compact. In addition to what we saw already, you should use <code>Filter.push_pull</code> and <code>NeBot.of_map</code>. BOTH: -/ -- QUOTE: -- EXAMPLES: example [TopologicalSpace Y] {f : X → Y} (hf : Continuous f) {s : Set X} (hs : IsCompact s) : IsCompact (f '' s) := by intro F F_ne F_le have map_eq : map f (𝓟 s ⊓ comap f F) = 𝓟 (f '' s) ⊓ F := by sorry have Hne : (𝓟 s ⊓ comap f F).NeBot := by sorry have Hle : 𝓟 s ⊓ comap f F ≤ 𝓟 s := inf_le_left sorry -- QUOTE.</p> <p>-- SOLUTIONS: example [TopologicalSpace Y] {f : X → Y} (hf : Continuous f) {s : Set X} (hs : IsCompact s) : IsCompact (f '' s) := by intro F F_ne F_le have map_eq : map f (𝓟 s ⊓ comap f F) = 𝓟 (f '' s) ⊓ F := by rw [Filter.push_pull, map_principal] have Hne : (𝓟 s ⊓ comap f F).NeBot := by apply NeBot.of_map rwa [map_eq, inf_of_le_right F_le] have Hle : 𝓟 s ⊓ comap f F ≤ 𝓟 s := inf_le_left rcases hs Hle with ⟨x, x_in, hx⟩ refine' ⟨f x, mem_image_of_mem f x_in, _⟩ apply hx.map hf.continuousAt rw [Tendsto, map_eq] exact inf_le_right</p> <p>/- TEXT: One can also express compactness in terms of open covers: <code>s</code> is compact if every family of open sets that cover <code>s</code> has a finite covering sub-family.</p> <p>BOTH: -/ -- QUOTE: example {ι : Type*} {s : Set X} (hs : IsCompact s) (U : ι → Set X) (hUo : ∀ i, IsOpen (U i)) (hsU : s ⊆ ⋃ i, U i) : ∃ t : Finset ι, s ⊆ ⋃ i ∈ t, U i := hs.elim_finite_subcover U hUo hsU -- QUOTE.</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.sections", "navigation.instant", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"alias": true, "default": "latest", "provider": "mike"}}</script> <script src=../../../assets/javascripts/bundle.fe8b6f2b.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>