<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.0, mkdocs-material-9.5.31"><title>S02 Proving Identities in Algebraic Structures - MIL</title><link rel=stylesheet href=../../../assets/stylesheets/main.3cba04c6.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../assets/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent=light-green> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#proving-identities-in-algebraic-structures class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <div data-md-color-scheme=default data-md-component=outdated hidden> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=MIL class="md-header__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> MIL </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> S02 Proving Identities in Algebraic Structures </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../en/ class=md-tabs__link> 目录 </a> </li> <li class=md-tabs__item> <a href=../../../en/C01_Introduction/ class=md-tabs__link> Introduction </a> </li> <li class=md-tabs__item> <a href=../../../en/C02_Basics/ class=md-tabs__link> Basics </a> </li> <li class=md-tabs__item> <a href=../../../en/C03_Logic/ class=md-tabs__link> Logic </a> </li> <li class=md-tabs__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-tabs__link> Sets and Functions </a> </li> <li class=md-tabs__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-tabs__link> Elementary Number Theory </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=MIL class="md-nav__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> MIL </label> <div class=md-nav__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../en/ class=md-nav__link> <span class=md-ellipsis> 目录 </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C01_Introduction/ class=md-nav__link> <span class=md-ellipsis> Introduction </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C02_Basics/ class=md-nav__link> <span class=md-ellipsis> Basics </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C03_Logic/ class=md-nav__link> <span class=md-ellipsis> Logic </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-nav__link> <span class=md-ellipsis> Sets and Functions </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-nav__link> <span class=md-ellipsis> Elementary Number Theory </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#proving-identities-in-algebraic-structures class=md-nav__link> <span class=md-ellipsis> Proving Identities in Algebraic Structures </span> </a> </li> <li class=md-nav__item> <a href=#check-add_assoc-a-b-c-r-a-b-c-a-b-c class=md-nav__link> <span class=md-ellipsis> check (add_assoc : ∀ a b c : R, a + b + c = a + (b + c)) </span> </a> </li> <li class=md-nav__item> <a href=#check-add_comm-a-b-r-a-b-b-a class=md-nav__link> <span class=md-ellipsis> check (add_comm : ∀ a b : R, a + b = b + a) </span> </a> </li> <li class=md-nav__item> <a href=#check-zero_add-a-r-0-a-a class=md-nav__link> <span class=md-ellipsis> check (zero_add : ∀ a : R, 0 + a = a) </span> </a> </li> <li class=md-nav__item> <a href=#check-add_left_neg-a-r-a-a-0 class=md-nav__link> <span class=md-ellipsis> check (add_left_neg : ∀ a : R, -a + a = 0) </span> </a> </li> <li class=md-nav__item> <a href=#check-mul_assoc-a-b-c-r-a-b-c-a-b-c class=md-nav__link> <span class=md-ellipsis> check (mul_assoc : ∀ a b c : R, a * b * c = a * (b * c)) </span> </a> </li> <li class=md-nav__item> <a href=#check-mul_one-a-r-a-1-a class=md-nav__link> <span class=md-ellipsis> check (mul_one : ∀ a : R, a * 1 = a) </span> </a> </li> <li class=md-nav__item> <a href=#check-one_mul-a-r-1-a-a class=md-nav__link> <span class=md-ellipsis> check (one_mul : ∀ a : R, 1 * a = a) </span> </a> </li> <li class=md-nav__item> <a href=#check-mul_add-a-b-c-r-a-b-c-a-b-a-c class=md-nav__link> <span class=md-ellipsis> check (mul_add : ∀ a b c : R, a * (b + c) = a * b + a * c) </span> </a> </li> <li class=md-nav__item> <a href=#check-add_mul-a-b-c-r-a-b-c-a-c-b-c class=md-nav__link> <span class=md-ellipsis> check (add_mul : ∀ a b c : R, (a + b) * c = a * c + b * c) </span> </a> </li> <li class=md-nav__item> <a href=#check-myringadd_zero class=md-nav__link> <span class=md-ellipsis> check MyRing.add_zero </span> </a> </li> <li class=md-nav__item> <a href=#check-add_zero class=md-nav__link> <span class=md-ellipsis> check add_zero </span> </a> </li> <li class=md-nav__item> <a href=#check-add_assoc-a-b-c-a-a-b-c-a-b-c class=md-nav__link> <span class=md-ellipsis> check (add_assoc : ∀ a b c : A, a + b + c = a + (b + c)) </span> </a> </li> <li class=md-nav__item> <a href=#check-zero_add-a-a-0-a-a class=md-nav__link> <span class=md-ellipsis> check (zero_add : ∀ a : A, 0 + a = a) </span> </a> </li> <li class=md-nav__item> <a href=#check-add_left_neg-a-a-a-a-0 class=md-nav__link> <span class=md-ellipsis> check (add_left_neg : ∀ a : A, -a + a = 0) </span> </a> </li> <li class=md-nav__item> <a href=#check-mul_assoc-a-b-c-g-a-b-c-a-b-c class=md-nav__link> <span class=md-ellipsis> check (mul_assoc : ∀ a b c : G, a * b * c = a * (b * c)) </span> </a> </li> <li class=md-nav__item> <a href=#check-one_mul-a-g-1-a-a class=md-nav__link> <span class=md-ellipsis> check (one_mul : ∀ a : G, 1 * a = a) </span> </a> </li> <li class=md-nav__item> <a href=#check-mul_left_inv-a-g-a1-a-1 class=md-nav__link> <span class=md-ellipsis> check (mul_left_inv : ∀ a : G, a⁻¹ * a = 1) </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <p>-- BOTH: import Mathlib.Algebra.Ring.Defs import Mathlib.Data.Real.Basic import MIL.Common</p> <p>/- TEXT: .. _proving_identities_in_algebraic_structures:</p> <h2 id=proving-identities-in-algebraic-structures>Proving Identities in Algebraic Structures<a class=headerlink href=#proving-identities-in-algebraic-structures title="Permanent link">&para;</a></h2> <p>.. index:: ring (algebraic structure)</p> <p>Mathematically, a ring consists of a collection of objects, :math:<code>R</code>, operations :math:<code>+</code> :math:<code>\times</code>, and constants :math:<code>0</code> and :math:<code>1</code>, and an operation :math:<code>x \mapsto -x</code> such that:</p> <ul> <li>:math:<code>R</code> with :math:<code>+</code> is an <em>abelian group</em>, with :math:<code>0</code> as the additive identity and negation as inverse.</li> <li>Multiplication is associative with identity :math:<code>1</code>, and multiplication distributes over addition.</li> </ul> <p>In Lean, the collection of objects is represented as a <em>type</em>, <code>R</code>. The ring axioms are as follows: TEXT. -/ section -- QUOTE: variable (R : Type*) [Ring R]</p> <h1 id=check-add_assoc-a-b-c-r-a-b-c-a-b-c>check (add_assoc : ∀ a b c : R, a + b + c = a + (b + c))<a class=headerlink href=#check-add_assoc-a-b-c-r-a-b-c-a-b-c title="Permanent link">&para;</a></h1> <h1 id=check-add_comm-a-b-r-a-b-b-a>check (add_comm : ∀ a b : R, a + b = b + a)<a class=headerlink href=#check-add_comm-a-b-r-a-b-b-a title="Permanent link">&para;</a></h1> <h1 id=check-zero_add-a-r-0-a-a>check (zero_add : ∀ a : R, 0 + a = a)<a class=headerlink href=#check-zero_add-a-r-0-a-a title="Permanent link">&para;</a></h1> <h1 id=check-add_left_neg-a-r-a-a-0>check (add_left_neg : ∀ a : R, -a + a = 0)<a class=headerlink href=#check-add_left_neg-a-r-a-a-0 title="Permanent link">&para;</a></h1> <h1 id=check-mul_assoc-a-b-c-r-a-b-c-a-b-c>check (mul_assoc : ∀ a b c : R, a * b * c = a * (b * c))<a class=headerlink href=#check-mul_assoc-a-b-c-r-a-b-c-a-b-c title="Permanent link">&para;</a></h1> <h1 id=check-mul_one-a-r-a-1-a>check (mul_one : ∀ a : R, a * 1 = a)<a class=headerlink href=#check-mul_one-a-r-a-1-a title="Permanent link">&para;</a></h1> <h1 id=check-one_mul-a-r-1-a-a>check (one_mul : ∀ a : R, 1 * a = a)<a class=headerlink href=#check-one_mul-a-r-1-a-a title="Permanent link">&para;</a></h1> <h1 id=check-mul_add-a-b-c-r-a-b-c-a-b-a-c>check (mul_add : ∀ a b c : R, a * (b + c) = a * b + a * c)<a class=headerlink href=#check-mul_add-a-b-c-r-a-b-c-a-b-a-c title="Permanent link">&para;</a></h1> <h1 id=check-add_mul-a-b-c-r-a-b-c-a-c-b-c>check (add_mul : ∀ a b c : R, (a + b) * c = a * c + b * c)<a class=headerlink href=#check-add_mul-a-b-c-r-a-b-c-a-c-b-c title="Permanent link">&para;</a></h1> <p>-- QUOTE.</p> <p>end</p> <p>/- TEXT: You will learn more about the square brackets in the first line later, but for the time being, suffice it to say that the declaration gives us a type, <code>R</code>, and a ring structure on <code>R</code>. Lean then allows us to use generic ring notation with elements of <code>R</code>, and to make use of a library of theorems about rings.</p> <p>The names of some of the theorems should look familiar: they are exactly the ones we used to calculate with the real numbers in the last section. Lean is good not only for proving things about concrete mathematical structures like the natural numbers and the integers, but also for proving things about abstract structures, characterized axiomatically, like rings. Moreover, Lean supports <em>generic reasoning</em> about both abstract and concrete structures, and can be trained to recognize appropriate instances. So any theorem about rings can be applied to concrete rings like the integers, <code>ℤ</code>, the rational numbers, <code>ℚ</code>, and the complex numbers <code>ℂ</code>. It can also be applied to any instance of an abstract structure that extends rings, such as any ordered ring or any field.</p> <p>.. index:: commutative ring</p> <p>Not all important properties of the real numbers hold in an arbitrary ring, however. For example, multiplication on the real numbers is commutative, but that does not hold in general. If you have taken a course in linear algebra, you will recognize that, for every :math:<code>n</code>, the :math:<code>n</code> by :math:<code>n</code> matrices of real numbers form a ring in which commutativity usually fails. If we declare <code>R</code> to be a <em>commutative</em> ring, in fact, all the theorems in the last section continue to hold when we replace <code>ℝ</code> by <code>R</code>. TEXT. -/ section -- QUOTE: variable (R : Type*) [CommRing R] variable (a b c d : R)</p> <p>example : c * b * a = b * (a * c) := by ring</p> <p>example : (a + b) * (a + b) = a * a + 2 * (a * b) + b * b := by ring</p> <p>example : (a + b) * (a - b) = a ^ 2 - b ^ 2 := by ring</p> <p>example (hyp : c = d * a + b) (hyp' : b = a * d) : c = 2 * a * d := by rw [hyp, hyp'] ring -- QUOTE.</p> <p>end</p> <p>/- TEXT: We leave it to you to check that all the other proofs go through unchanged. Notice that when a proof is short, like <code>by ring</code> or <code>by linarith</code> or <code>by sorry</code>, it is common (and permissible) to put it on the same line as the <code>by</code>. Good proof-writing style should strike a balance between concision and readability.</p> <p>The goal of this section is to strengthen the skills you have developed in the last section and apply them to reasoning axiomatically about rings. We will start with the axioms listed above, and use them to derive other facts. Most of the facts we prove are already in Mathlib. We will give the versions we prove the same names to help you learn the contents of the library as well as the naming conventions.</p> <p>.. index:: namespace, open, command ; open</p> <p>Lean provides an organizational mechanism similar to those used in programming languages: when a definition or theorem <code>foo</code> is introduced in a <em>namespace</em> <code>bar</code>, its full name is <code>bar.foo</code>. The command <code>open bar</code> later <em>opens</em> the namespace, which allows us to use the shorter name <code>foo</code>. To avoid errors due to name clashes, in the next example we put our versions of the library theorems in a new namespace called <code>MyRing.</code></p> <p>The next example shows that we do not need <code>add_zero</code> or <code>add_right_neg</code> as ring axioms, because they follow from the other axioms. TEXT. -/ -- QUOTE: namespace MyRing variable {R : Type*} [Ring R]</p> <p>theorem add_zero (a : R) : a + 0 = a := by rw [add_comm, zero_add]</p> <p>theorem add_right_neg (a : R) : a + -a = 0 := by rw [add_comm, add_left_neg]</p> <h1 id=check-myringadd_zero>check MyRing.add_zero<a class=headerlink href=#check-myringadd_zero title="Permanent link">&para;</a></h1> <h1 id=check-add_zero>check add_zero<a class=headerlink href=#check-add_zero title="Permanent link">&para;</a></h1> <p>end MyRing -- QUOTE.</p> <p>/- TEXT: The net effect is that we can temporarily reprove a theorem in the library, and then go on using the library version after that. But don't cheat! In the exercises that follow, take care to use only the general facts about rings that we have proved earlier in this section.</p> <p>(If you are paying careful attention, you may have noticed that we changed the round brackets in <code>(R : Type*)</code> for curly brackets in <code>{R : Type*}</code>. This declares <code>R</code> to be an <em>implicit argument</em>. We will explain what this means in a moment, but don't worry about it in the meanwhile.)</p> <p>Here is a useful theorem: TEXT. -/ -- BOTH: namespace MyRing variable {R : Type*} [Ring R]</p> <p>-- EXAMPLES: -- QUOTE: theorem neg_add_cancel_left (a b : R) : -a + (a + b) = b := by rw [← add_assoc, add_left_neg, zero_add] -- QUOTE.</p> <p>/- TEXT: Prove the companion version: TEXT. -/ -- Prove these: -- QUOTE: theorem add_neg_cancel_right (a b : R) : a + b + -b = a := by sorry -- QUOTE.</p> <p>-- SOLUTIONS: theorem add_neg_cancel_rightαα (a b : R) : a + b + -b = a := by rw [add_assoc, add_right_neg, add_zero]</p> <p>/- TEXT: Use these to prove the following: TEXT. -/ -- QUOTE: theorem add_left_cancel {a b c : R} (h : a + b = a + c) : b = c := by sorry</p> <p>theorem add_right_cancel {a b c : R} (h : a + b = c + b) : a = c := by sorry -- QUOTE.</p> <p>-- SOLUTIONS: theorem add_left_cancelαα {a b c : R} (h : a + b = a + c) : b = c := by rw [← neg_add_cancel_left a b, h, neg_add_cancel_left]</p> <p>theorem add_right_cancelαα {a b c : R} (h : a + b = c + b) : a = c := by rw [← add_neg_cancel_right a b, h, add_neg_cancel_right]</p> <p>/- TEXT: With enough planning, you can do each of them with three rewrites.</p> <p>.. index:: implicit argument</p> <p>We will now explain the use of the curly braces. Imagine you are in a situation where you have <code>a</code>, <code>b</code>, and <code>c</code> in your context, as well as a hypothesis <code>h : a + b = a + c</code>, and you would like to draw the conclusion <code>b = c</code>. In Lean, you can apply a theorem to hypotheses and facts just the same way that you can apply them to objects, so you might think that <code>add_left_cancel a b c h</code> is a proof of the fact <code>b = c</code>. But notice that explicitly writing <code>a</code>, <code>b</code>, and <code>c</code> is redundant, because the hypothesis <code>h</code> makes it clear that those are the objects we have in mind. In this case, typing a few extra characters is not onerous, but if we wanted to apply <code>add_left_cancel</code> to more complicated expressions, writing them would be tedious. In cases like these, Lean allows us to mark arguments as <em>implicit</em>, meaning that they are supposed to be left out and inferred by other means, such as later arguments and hypotheses. The curly brackets in <code>{a b c : R}</code> do exactly that. So, given the statement of the theorem above, the correct expression is simply <code>add_left_cancel h</code>.</p> <p>To illustrate, let us show that <code>a * 0 = 0</code> follows from the ring axioms. TEXT. -/ -- QUOTE: theorem mul_zero (a : R) : a * 0 = 0 := by have h : a * 0 + a * 0 = a * 0 + 0 := by rw [← mul_add, add_zero, add_zero] rw [add_left_cancel h] -- QUOTE.</p> <p>/- TEXT: .. index:: have, tactics ; have</p> <p>We have used a new trick! If you step through the proof, you can see what is going on. The <code>have</code> tactic introduces a new goal, <code>a * 0 + a * 0 = a * 0 + 0</code>, with the same context as the original goal. The fact that the next line is indented indicates that Lean is expecting a block of tactics that serves to prove this new goal. The indentation therefore promotes a modular style of proof: the indented subproof establishes the goal that was introduced by the <code>have</code>. After that, we are back to proving the original goal, except a new hypothesis <code>h</code> has been added: having proved it, we are now free to use it. At this point, the goal is exactly the result of <code>add_left_cancel h</code>.</p> <p>.. index:: apply, tactics ; apply, exact, tactics ; exact</p> <p>We could equally well have closed the proof with <code>apply add_left_cancel h</code> or <code>exact add_left_cancel h</code>. The <code>exact</code> tactic takes as argument a proof term which completely proves the current goal, without creating any new goal. The <code>apply</code> tactic is a variant whose argument is not necessarily a complete proof. The missing pieces are either inferred automatically by Lean or become new goals to prove. While the <code>exact</code> tactic is technically redundant since it is strictly less powerful than <code>apply</code>, it makes proof scripts slightly clearer to human readers and easier to maintain when the library evolves.</p> <p>Remember that multiplication is not assumed to be commutative, so the following theorem also requires some work. TEXT. -/ -- QUOTE: theorem zero_mul (a : R) : 0 * a = 0 := by sorry -- QUOTE.</p> <p>-- SOLUTIONS: theorem zero_mulαα (a : R) : 0 * a = 0 := by have h : 0 * a + 0 * a = 0 * a + 0 := by rw [← add_mul, add_zero, add_zero] rw [add_left_cancel h]</p> <p>/- TEXT: By now, you should also be able replace each <code>sorry</code> in the next exercise with a proof, still using only facts about rings that we have established in this section. TEXT. -/ -- QUOTE: theorem neg_eq_of_add_eq_zero {a b : R} (h : a + b = 0) : -a = b := by sorry</p> <p>theorem eq_neg_of_add_eq_zero {a b : R} (h : a + b = 0) : a = -b := by sorry</p> <p>theorem neg_zero : (-0 : R) = 0 := by apply neg_eq_of_add_eq_zero rw [add_zero]</p> <p>theorem neg_neg (a : R) : - -a = a := by sorry -- QUOTE.</p> <p>-- SOLUTIONS: theorem neg_eq_of_add_eq_zeroαα {a b : R} (h : a + b = 0) : -a = b := by rw [← neg_add_cancel_left a b, h, add_zero]</p> <p>theorem eq_neg_of_add_eq_zeroαα {a b : R} (h : a + b = 0) : a = -b := by symm apply neg_eq_of_add_eq_zero rw [add_comm, h]</p> <p>theorem neg_zeroαα : (-0 : R) = 0 := by apply neg_eq_of_add_eq_zero rw [add_zero]</p> <p>theorem neg_negαα (a : R) : - -a = a := by apply neg_eq_of_add_eq_zero rw [add_left_neg]</p> <p>-- BOTH: end MyRing</p> <p>/- TEXT: We had to use the annotation <code>(-0 : R)</code> instead of <code>0</code> in the third theorem because without specifying <code>R</code> it is impossible for Lean to infer which <code>0</code> we have in mind, and by default it would be interpreted as a natural number.</p> <p>In Lean, subtraction in a ring is provably equal to addition of the additive inverse. TEXT. -/ -- Examples. section variable {R : Type*} [Ring R]</p> <p>-- QUOTE: example (a b : R) : a - b = a + -b := sub_eq_add_neg a b -- QUOTE.</p> <p>end</p> <p>/- TEXT: On the real numbers, it is <em>defined</em> that way: TEXT. -/ -- QUOTE: example (a b : ℝ) : a - b = a + -b := rfl</p> <p>example (a b : ℝ) : a - b = a + -b := by rfl -- QUOTE.</p> <p>/- TEXT: .. index:: rfl, reflexivity, tactics ; refl and reflexivity, definitional equality</p> <p>The proof term <code>rfl</code> is short for "reflexivity". Presenting it as a proof of <code>a - b = a + -b</code> forces Lean to unfold the definition and recognize both sides as being the same. The <code>rfl</code> tactic does the same. This is an instance of what is known as a <em>definitional equality</em> in Lean's underlying logic. This means that not only can one rewrite with <code>sub_eq_add_neg</code> to replace <code>a - b = a + -b</code>, but in some contexts, when dealing with the real numbers, you can use the two sides of the equation interchangeably. For example, you now have enough information to prove the theorem <code>self_sub</code> from the last section: TEXT. -/ -- BOTH: namespace MyRing variable {R : Type*} [Ring R]</p> <p>-- EXAMPLES: -- QUOTE: theorem self_sub (a : R) : a - a = 0 := by sorry -- QUOTE.</p> <p>-- SOLUTIONS: theorem self_subαα (a : R) : a - a = 0 := by rw [sub_eq_add_neg, add_right_neg]</p> <p>/- TEXT: Show that you can prove this using <code>rw</code>, but if you replace the arbitrary ring <code>R</code> by the real numbers, you can also prove it using either <code>apply</code> or <code>exact</code>.</p> <p>Lean knows that <code>1 + 1 = 2</code> holds in any ring. With a bit of effort, you can use that to prove the theorem <code>two_mul</code> from the last section: TEXT. -/ -- QUOTE: -- BOTH: theorem one_add_one_eq_two : 1 + 1 = (2 : R) := by norm_num</p> <p>-- EXAMPLES: theorem two_mul (a : R) : 2 * a = a + a := by sorry -- QUOTE.</p> <p>-- SOLUTIONS: theorem two_mulαα (a : R) : 2 * a = a + a := by rw [← one_add_one_eq_two, add_mul, one_mul]</p> <p>-- BOTH: end MyRing</p> <p>/- TEXT: .. index:: group (algebraic structure)</p> <p>We close this section by noting that some of the facts about addition and negation that we established above do not need the full strength of the ring axioms, or even commutativity of addition. The weaker notion of a <em>group</em> can be axiomatized as follows: TEXT. -/ section -- QUOTE: variable (A : Type*) [AddGroup A]</p> <h1 id=check-add_assoc-a-b-c-a-a-b-c-a-b-c>check (add_assoc : ∀ a b c : A, a + b + c = a + (b + c))<a class=headerlink href=#check-add_assoc-a-b-c-a-a-b-c-a-b-c title="Permanent link">&para;</a></h1> <h1 id=check-zero_add-a-a-0-a-a>check (zero_add : ∀ a : A, 0 + a = a)<a class=headerlink href=#check-zero_add-a-a-0-a-a title="Permanent link">&para;</a></h1> <h1 id=check-add_left_neg-a-a-a-a-0>check (add_left_neg : ∀ a : A, -a + a = 0)<a class=headerlink href=#check-add_left_neg-a-a-a-a-0 title="Permanent link">&para;</a></h1> <p>-- QUOTE.</p> <p>end</p> <p>/- TEXT: It is conventional to use additive notation when the group operation is commutative, and multiplicative notation otherwise. So Lean defines a multiplicative version as well as the additive version (and also their abelian variants, <code>AddCommGroup</code> and <code>CommGroup</code>). TEXT. -/ -- BOTH: section -- QUOTE: variable {G : Type*} [Group G]</p> <p>-- EXAMPLES:</p> <h1 id=check-mul_assoc-a-b-c-g-a-b-c-a-b-c>check (mul_assoc : ∀ a b c : G, a * b * c = a * (b * c))<a class=headerlink href=#check-mul_assoc-a-b-c-g-a-b-c-a-b-c title="Permanent link">&para;</a></h1> <h1 id=check-one_mul-a-g-1-a-a>check (one_mul : ∀ a : G, 1 * a = a)<a class=headerlink href=#check-one_mul-a-g-1-a-a title="Permanent link">&para;</a></h1> <h1 id=check-mul_left_inv-a-g-a1-a-1>check (mul_left_inv : ∀ a : G, a⁻¹ * a = 1)<a class=headerlink href=#check-mul_left_inv-a-g-a1-a-1 title="Permanent link">&para;</a></h1> <p>-- QUOTE.</p> <p>/- TEXT: If you are feeling cocky, try proving the following facts about groups, using only these axioms. You will need to prove a number of helper lemmas along the way. The proofs we have carried out in this section provide some hints. TEXT. -/ -- BOTH: namespace MyGroup</p> <p>-- EXAMPLES: -- QUOTE: theorem mul_right_inv (a : G) : a * a⁻¹ = 1 := by sorry</p> <p>theorem mul_one (a : G) : a * 1 = a := by sorry</p> <p>theorem mul_inv_rev (a b : G) : (a * b)⁻¹ = b⁻¹ * a⁻¹ := by sorry -- QUOTE.</p> <p>-- SOLUTIONS: theorem mul_right_invαα (a : G) : a * a⁻¹ = 1 := by have h : (a * a⁻¹)⁻¹ * (a * a⁻¹ * (a * a⁻¹)) = 1 := by rw [mul_assoc, ← mul_assoc a⁻¹ a, mul_left_inv, one_mul, mul_left_inv] rw [← h, ← mul_assoc, mul_left_inv, one_mul]</p> <p>theorem mul_oneαα (a : G) : a * 1 = a := by rw [← mul_left_inv a, ← mul_assoc, mul_right_inv, one_mul]</p> <p>theorem mul_inv_revαα (a b : G) : (a * b)⁻¹ = b⁻¹ * a⁻¹ := by rw [← one_mul (b⁻¹ * a⁻¹), ← mul_left_inv (a * b), mul_assoc, mul_assoc, ← mul_assoc b b⁻¹, mul_right_inv, one_mul, mul_right_inv, mul_one]</p> <p>-- BOTH: end MyGroup</p> <p>end</p> <p>/- TEXT: .. index:: group (tactic), tactics ; group, tactics ; noncomm_ring, tactics ; abel</p> <p>Explicitly invoking those lemmas is tedious, so Mathlib provides tactics similar to <code>ring</code> in order to cover most uses: <code>group</code> is for non-commutative multiplicative groups, <code>abel</code> for abelian additive groups, and <code>noncomm_ring</code> for non-commutative rings. It may seem odd that the algebraic structures are called <code>Ring</code> and <code>CommRing</code> while the tactics are named <code>noncomm_ring</code> and <code>ring</code>. This is partly for historical reasons, but also for the convenience of using a shorter name for the tactic that deals with commutative rings, since it is used more often. TEXT. -/</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.sections", "navigation.instant", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"alias": true, "default": "latest", "provider": "mike"}}</script> <script src=../../../assets/javascripts/bundle.fe8b6f2b.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>