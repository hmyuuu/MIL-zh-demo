<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.0, mkdocs-material-9.5.31"><title>S02 Algebraic Structures - MIL</title><link rel=stylesheet href=../../../assets/stylesheets/main.3cba04c6.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../assets/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent=light-green> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#algebraic-structures class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <div data-md-color-scheme=default data-md-component=outdated hidden> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=MIL class="md-header__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> MIL </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> S02 Algebraic Structures </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../en/ class=md-tabs__link> 目录 </a> </li> <li class=md-tabs__item> <a href=../../../en/C01_Introduction/ class=md-tabs__link> Introduction </a> </li> <li class=md-tabs__item> <a href=../../../en/C02_Basics/ class=md-tabs__link> Basics </a> </li> <li class=md-tabs__item> <a href=../../../en/C03_Logic/ class=md-tabs__link> Logic </a> </li> <li class=md-tabs__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-tabs__link> Sets and Functions </a> </li> <li class=md-tabs__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-tabs__link> Elementary Number Theory </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=MIL class="md-nav__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> MIL </label> <div class=md-nav__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../en/ class=md-nav__link> <span class=md-ellipsis> 目录 </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C01_Introduction/ class=md-nav__link> <span class=md-ellipsis> Introduction </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C02_Basics/ class=md-nav__link> <span class=md-ellipsis> Basics </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C03_Logic/ class=md-nav__link> <span class=md-ellipsis> Logic </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-nav__link> <span class=md-ellipsis> Sets and Functions </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-nav__link> <span class=md-ellipsis> Elementary Number Theory </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#algebraic-structures class=md-nav__link> <span class=md-ellipsis> Algebraic Structures </span> </a> </li> <li class=md-nav__item> <a href=#a-partially-ordered-set-consists-of-a-set-mathp-and class=md-nav__link> <span class=md-ellipsis> . A partially ordered set consists of a set :math:P and </span> </a> </li> <li class=md-nav__item> <a href=#a-group-consists-of-a-set-mathg-with-an-associative class=md-nav__link> <span class=md-ellipsis> . A group consists of a set :math:G with an associative </span> </a> </li> <li class=md-nav__item> <a href=#a-lattice-is-a-partially-ordered-set-with-meets-and-joins class=md-nav__link> <span class=md-ellipsis> . A lattice is a partially ordered set with meets and joins. </span> </a> </li> <li class=md-nav__item> <a href=#a-ring-consists-of-an-additively-written-abelian-group class=md-nav__link> <span class=md-ellipsis> . A ring consists of an (additively written) abelian group </span> </a> </li> <li class=md-nav__item> <a href=#an-ordered-ring-mathr-0-cdot-1-le-consists-of-a-ring class=md-nav__link> <span class=md-ellipsis> . An ordered ring :math:(R, +, 0, -, \cdot, 1, \le) consists of a ring </span> </a> </li> <li class=md-nav__item> <a href=#a-metric-space-consists-of-a-set-mathx-and-a-function class=md-nav__link> <span class=md-ellipsis> . A metric space consists of a set :math:X and a function </span> </a> </li> <li class=md-nav__item> <a href=#a-topological-space-consists-of-a-set-mathx-and-a-collection-mathmathcal-t class=md-nav__link> <span class=md-ellipsis> . A topological space consists of a set :math:X and a collection :math:\mathcal T </span> </a> </li> <li class=md-nav__item> <a href=#check-equiv class=md-nav__link> <span class=md-ellipsis> check Equiv α β </span> </a> </li> <li class=md-nav__item> <a href=#check-ftofun class=md-nav__link> <span class=md-ellipsis> check (f.toFun : α → β) </span> </a> </li> <li class=md-nav__item> <a href=#check-finvfun class=md-nav__link> <span class=md-ellipsis> check (f.invFun : β → α) </span> </a> </li> <li class=md-nav__item> <a href=#check-fright_inv-x-f-finvfun-x-x class=md-nav__link> <span class=md-ellipsis> check (f.right_inv : ∀ x : β, f (f.invFun x) = x) </span> </a> </li> <li class=md-nav__item> <a href=#check-fleft_inv-x-finvfun-f-x-x class=md-nav__link> <span class=md-ellipsis> check (f.left_inv : ∀ x : α, f.invFun (f x) = x) </span> </a> </li> <li class=md-nav__item> <a href=#check-equivrefl class=md-nav__link> <span class=md-ellipsis> check (Equiv.refl α : α ≃ α) </span> </a> </li> <li class=md-nav__item> <a href=#check-fsymm class=md-nav__link> <span class=md-ellipsis> check (f.symm : β ≃ α) </span> </a> </li> <li class=md-nav__item> <a href=#check-ftrans-g class=md-nav__link> <span class=md-ellipsis> check (f.trans g : α ≃ γ) </span> </a> </li> <li class=md-nav__item> <a href=#check-f-g class=md-nav__link> <span class=md-ellipsis> check f * g </span> </a> </li> <li class=md-nav__item> <a href=#check-mul_assoc-f-g-g1 class=md-nav__link> <span class=md-ellipsis> check mul_assoc f g g⁻¹ </span> </a> </li> <li class=md-nav__item> <a href=#check-g-n class=md-nav__link> <span class=md-ellipsis> check g ^ n </span> </a> </li> <li class=md-nav__item> <a href=#logic-a-definition-that-should-be-interpreted-in-any-group-takes-as class=md-nav__link> <span class=md-ellipsis> . Logic. A definition that should be interpreted in any group takes, as </span> </a> </li> <li class=md-nav__item> <a href=#implicit-arguments-the-arguments-for-the-type-and-the-structure class=md-nav__link> <span class=md-ellipsis> . Implicit arguments. The arguments for the type and the structure </span> </a> </li> <li class=md-nav__item> <a href=#type-class-inference-also-known-as-class-inference class=md-nav__link> <span class=md-ellipsis> . Type class inference. Also known as class inference, </span> </a> </li> <li class=md-nav__item> <a href=#check-group2mul class=md-nav__link> <span class=md-ellipsis> check Group₂.mul </span> </a> </li> <li class=md-nav__item> <a href=#check-mysquare class=md-nav__link> <span class=md-ellipsis> check mySquare </span> </a> </li> <li class=md-nav__item> <a href=#check-default-point class=md-nav__link> <span class=md-ellipsis> check (default : Point) </span> </a> </li> <li class=md-nav__item> <a href=#check-x-y class=md-nav__link> <span class=md-ellipsis> check x + y </span> </a> </li> <li class=md-nav__item> <a href=#check-f-1-g1 class=md-nav__link> <span class=md-ellipsis> check f * 1 * g⁻¹ </span> </a> </li> <li class=md-nav__item> <a href=#check-x-y-0 class=md-nav__link> <span class=md-ellipsis> check x + -y + 0 </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <p>import MIL.Common import Mathlib.Data.Real.Basic</p> <p>namespace C06S02</p> <p>/- TEXT: .. _section_algebraic_structures:</p> <h2 id=algebraic-structures>Algebraic Structures<a class=headerlink href=#algebraic-structures title="Permanent link">&para;</a></h2> <p>To clarify what we mean by the phrase <em>algebraic structure</em>, it will help to consider some examples.</p> <h1 id=a-partially-ordered-set-consists-of-a-set-mathp-and>. A <em>partially ordered set</em> consists of a set :math:<code>P</code> and<a class=headerlink href=#a-partially-ordered-set-consists-of-a-set-mathp-and title="Permanent link">&para;</a></h1> <p>a binary relation :math:<code>\le</code> on :math:<code>P</code> that is transitive and reflexive.</p> <h1 id=a-group-consists-of-a-set-mathg-with-an-associative>. A <em>group</em> consists of a set :math:<code>G</code> with an associative<a class=headerlink href=#a-group-consists-of-a-set-mathg-with-an-associative title="Permanent link">&para;</a></h1> <p>binary operation, an identity element :math:<code>1</code>, and a function :math:<code>g \mapsto g^{-1}</code> that returns an inverse for each :math:<code>g</code> in :math:<code>G</code>. A group is <em>abelian</em> or <em>commutative</em> if the operation is commutative.</p> <h1 id=a-lattice-is-a-partially-ordered-set-with-meets-and-joins>. A <em>lattice</em> is a partially ordered set with meets and joins.<a class=headerlink href=#a-lattice-is-a-partially-ordered-set-with-meets-and-joins title="Permanent link">&para;</a></h1> <h1 id=a-ring-consists-of-an-additively-written-abelian-group>. A <em>ring</em> consists of an (additively written) abelian group<a class=headerlink href=#a-ring-consists-of-an-additively-written-abelian-group title="Permanent link">&para;</a></h1> <p>:math:<code>(R, +, 0, x \mapsto -x)</code> together with an associative multiplication operation :math:<code>\cdot</code> and an identity :math:<code>1</code>, such that multiplication distributes over addition. A ring is <em>commutative</em> if the multiplication is commutative.</p> <h1 id=an-ordered-ring-mathr-0-cdot-1-le-consists-of-a-ring>. An <em>ordered ring</em> :math:<code>(R, +, 0, -, \cdot, 1, \le)</code> consists of a ring<a class=headerlink href=#an-ordered-ring-mathr-0-cdot-1-le-consists-of-a-ring title="Permanent link">&para;</a></h1> <p>together with a partial order on its elements, such that :math:<code>a \le b</code> implies :math:<code>a + c \le b + c</code> for every :math:<code>a</code>, :math:<code>b</code>, and :math:<code>c</code> in :math:<code>R</code>, and :math:<code>0 \le a</code> and :math:<code>0 \le b</code> implies :math:<code>0 \le a b</code> for every :math:<code>a</code> and :math:<code>b</code> in :math:<code>R</code>.</p> <h1 id=a-metric-space-consists-of-a-set-mathx-and-a-function>. A <em>metric space</em> consists of a set :math:<code>X</code> and a function<a class=headerlink href=#a-metric-space-consists-of-a-set-mathx-and-a-function title="Permanent link">&para;</a></h1> <p>:math:<code>d : X \times X \to \mathbb{R}</code> such that the following hold:</p> <ul> <li>:math:<code>d(x, y) \ge 0</code> for every :math:<code>x</code> and :math:<code>y</code> in :math:<code>X</code>.</li> <li>:math:<code>d(x, y) = 0</code> if and only if :math:<code>x = y</code>.</li> <li>:math:<code>d(x, y) = d(y, x)</code> for every :math:<code>x</code> and :math:<code>y</code> in :math:<code>X</code>.</li> <li>:math:<code>d(x, z) \le d(x, y) + d(y, z)</code> for every :math:<code>x</code>, :math:<code>y</code>, and :math:<code>z</code> in :math:<code>X</code>.</li> </ul> <h1 id=a-topological-space-consists-of-a-set-mathx-and-a-collection-mathmathcal-t>. A <em>topological space</em> consists of a set :math:<code>X</code> and a collection :math:<code>\mathcal T</code><a class=headerlink href=#a-topological-space-consists-of-a-set-mathx-and-a-collection-mathmathcal-t title="Permanent link">&para;</a></h1> <p>of subsets of :math:<code>X</code>, called the <em>open subsets of</em> :math:<code>X</code>, such that the following hold:</p> <ul> <li>The empty set and :math:<code>X</code> are open.</li> <li>The intersection of two open sets is open.</li> <li>An arbitrary union of open sets is open.</li> </ul> <p>In each of these examples, the elements of the structure belong to a set, the <em>carrier set</em>, that sometimes stands proxy for the entire structure. For example, when we say "let :math:<code>G</code> be a group" and then "let :math:<code>g \in G</code>," we are using :math:<code>G</code> to stand for both the structure and its carrier. Not every algebraic structure is associated with a single carrier set in this way. For example, a <em>bipartite graph</em> involves a relation between two sets, as does a <em>Galois connection</em>, A <em>category</em> also involves two sets of interest, commonly called the <em>objects</em> and the <em>morphisms</em>.</p> <p>The examples indicate some of the things that a proof assistant has to do in order to support algebraic reasoning. First, it needs to recognize concrete instances of structures. The number systems :math:<code>\mathbb{Z}</code>, :math:<code>\mathbb{Q}</code>, and :math:<code>\mathbb{R}</code> are all ordered rings, and we should be able to apply a generic theorem about ordered rings in any of these instances. Sometimes a concrete set may be an instance of a structure in more than one way. For example, in addition to the usual topology on :math:<code>\mathbb{R}</code>, which forms the basis for real analysis, we can also consider the <em>discrete</em> topology on :math:<code>\mathbb{R}</code>, in which every set is open.</p> <p>Second, a proof assistant needs to support generic notation on structures. In Lean, the notation <code>*</code> is used for multiplication in all the usual number systems, as well as for multiplication in generic groups and rings. When we use an expression like <code>f x * y</code>, Lean has to use information about the types of <code>f</code>, <code>x</code>, and <code>y</code> to determine which multiplication we have in mind.</p> <p>Third, it needs to deal with the fact that structures can inherit definitions, theorems, and notation from other structures in various ways. Some structures extend others by adding more axioms. A commutative ring is still a ring, so any definition that makes sense in a ring also makes sense in a commutative ring, and any theorem that holds in a ring also holds in a commutative ring. Some structures extend others by adding more data. For example, the additive part of any ring is an additive group. The ring structure adds a multiplication and an identity, as well as axioms that govern them and relate them to the additive part. Sometimes we can define one structure in terms of another. Any metric space has a canonical topology associated with it, the <em>metric space topology</em>, and there are various topologies that can be associated with any linear ordering.</p> <p>Finally, it is important to keep in mind that mathematics allows us to use functions and operations to define structures in the same way we use functions and operations to define numbers. Products and powers of groups are again groups. For every :math:<code>n</code>, the integers modulo :math:<code>n</code> form a ring, and for every :math:<code>k &gt; 0</code>, the :math:<code>k \times k</code> matrices of polynomials with coefficients in that ring again form a ring. Thus we can calculate with structures just as easily as we can calculate with their elements. This means that algebraic structures lead dual lives in mathematics, as containers for collections of objects and as objects in their own right. A proof assistant has to accommodate this dual role.</p> <p>When dealing with elements of a type that has an algebraic structure associated with it, a proof assistant needs to recognize the structure and find the relevant definitions, theorems, and notation. All this should sound like a lot of work, and it is. But Lean uses a small collection of fundamental mechanisms to carry out these tasks. The goal of this section is to explain these mechanisms and show you how to use them.</p> <p>The first ingredient is almost too obvious to mention: formally speaking, algebraic structures are structures in the sense of :numref:<code>section_structures</code>. An algebraic structure is a specification of a bundle of data satisfying some axiomatic hypotheses, and we saw in :numref:<code>section_structures</code> that this is exactly what the <code>structure</code> command is designed to accommodate. It's a marriage made in heaven!</p> <p>Given a data type <code>α</code>, we can define the group structure on <code>α</code> as follows. EXAMPLES: -/ -- QUOTE: structure Group₁ (α : Type*) where mul : α → α → α one : α inv : α → α mul_assoc : ∀ x y z : α, mul (mul x y) z = mul x (mul y z) mul_one : ∀ x : α, mul x one = x one_mul : ∀ x : α, mul one x = x mul_left_inv : ∀ x : α, mul (inv x) x = one -- QUOTE.</p> <p>-- OMIT: TODO: explain the extends command later, and also redundant inheritance /- TEXT: Notice that the type <code>α</code> is a <em>parameter</em> in the definition of <code>group₁</code>. So you should think of an object <code>struc : Group₁ α</code> as being a group structure on <code>α</code>. We saw in :numref:<code>proving_identities_in_algebraic_structures</code> that the counterpart <code>mul_right_inv</code> to <code>mul_left_inv</code> follows from the other group axioms, so there is no need to add it to the definition.</p> <p>This definition of a group is similar to the definition of <code>Group</code> in Mathlib, and we have chosen the name <code>Group₁</code> to distinguish our version. If you write <code>#check Group</code> and ctrl-click on the definition, you will see that the Mathlib version of <code>Group</code> is defined to extend another structure; we will explain how to do that later. If you type <code>#print Group</code> you will also see that the Mathlib version of <code>Group</code> has a number of extra fields. For reasons we will explain later, sometimes it is useful to add redundant information to a structure, so that there are additional fields for objects and functions that can be defined from the core data. Don't worry about that for now. Rest assured that our simplified version <code>Group₁</code> is morally the same as the definition of a group that Mathlib uses.</p> <p>It is sometimes useful to bundle the type together with the structure, and Mathlib also contains a definition of a <code>GroupCat</code> structure that is equivalent to the following: EXAMPLES: -/ -- QUOTE: structure Group₁Cat where α : Type* str : Group₁ α -- QUOTE.</p> <p>/- TEXT: The Mathlib version is found in <code>Mathlib.Algebra.Category.GroupCat.Basic</code>, and you can <code>#check</code> it if you add this to the imports at the beginning of the examples file.</p> <p>For reasons that will become clearer below, it is more often useful to keep the type <code>α</code> separate from the structure <code>Group α</code>. We refer to the two objects together as a <em>partially bundled structure</em>, since the representation combines most, but not all, of the components into one structure. It is common in Mathlib to use capital roman letters like <code>G</code> for a type when it is used as the carrier type for a group.</p> <p>Let's construct a group, which is to say, an element of the <code>Group₁</code> type. For any pair of types <code>α</code> and <code>β</code>, Mathlib defines the type <code>Equiv α β</code> of <em>equivalences</em> between <code>α</code> and <code>β</code>. Mathlib also defines the suggestive notation <code>α ≃ β</code> for this type. An element <code>f : α ≃ β</code> is a bijection between <code>α</code> and <code>β</code> represented by four components: a function <code>f.toFun</code> from <code>α</code> to <code>β</code>, the inverse function <code>f.invFun</code> from <code>β</code> to <code>α</code>, and two properties that specify these functions are indeed inverse to one another. EXAMPLES: -/ section -- QUOTE: variable (α β γ : Type*) variable (f : α ≃ β) (g : β ≃ γ)</p> <h1 id=check-equiv>check Equiv α β<a class=headerlink href=#check-equiv title="Permanent link">&para;</a></h1> <h1 id=check-ftofun>check (f.toFun : α → β)<a class=headerlink href=#check-ftofun title="Permanent link">&para;</a></h1> <h1 id=check-finvfun>check (f.invFun : β → α)<a class=headerlink href=#check-finvfun title="Permanent link">&para;</a></h1> <h1 id=check-fright_inv-x-f-finvfun-x-x>check (f.right_inv : ∀ x : β, f (f.invFun x) = x)<a class=headerlink href=#check-fright_inv-x-f-finvfun-x-x title="Permanent link">&para;</a></h1> <h1 id=check-fleft_inv-x-finvfun-f-x-x>check (f.left_inv : ∀ x : α, f.invFun (f x) = x)<a class=headerlink href=#check-fleft_inv-x-finvfun-f-x-x title="Permanent link">&para;</a></h1> <h1 id=check-equivrefl>check (Equiv.refl α : α ≃ α)<a class=headerlink href=#check-equivrefl title="Permanent link">&para;</a></h1> <h1 id=check-fsymm>check (f.symm : β ≃ α)<a class=headerlink href=#check-fsymm title="Permanent link">&para;</a></h1> <h1 id=check-ftrans-g>check (f.trans g : α ≃ γ)<a class=headerlink href=#check-ftrans-g title="Permanent link">&para;</a></h1> <p>-- QUOTE.</p> <p>/- TEXT: Notice the creative naming of the last three constructions. We think of the identity function <code>Equiv.refl</code>, the inverse operation <code>Equiv.symm</code>, and the composition operation <code>Equiv.trans</code> as explicit evidence that the property of being in bijective correspondence is an equivalence relation.</p> <p>Notice also that <code>f.trans g</code> requires composing the forward functions in reverse order. Mathlib has declared a <em>coercion</em> from <code>Equiv α β</code> to the function type <code>α → β</code>, so we can omit writing <code>.toFun</code> and have Lean insert it for us. EXAMPLES: -/ -- QUOTE: example (x : α) : (f.trans g).toFun x = g.toFun (f.toFun x) := rfl</p> <p>example (x : α) : (f.trans g) x = g (f x) := rfl</p> <p>example : (f.trans g : α → γ) = g ∘ f := rfl -- QUOTE.</p> <p>end</p> <p>/- TEXT: Mathlib also defines the type <code>perm α</code> of equivalences between <code>α</code> and itself. EXAMPLES: -/ -- QUOTE: example (α : Type*) : Equiv.Perm α = (α ≃ α) := rfl -- QUOTE.</p> <p>/- TEXT: It should be clear that <code>Equiv.Perm α</code> forms a group under composition of equivalences. We orient things so that <code>mul f g</code> is equal to <code>g.trans f</code>, whose forward function is <code>f ∘ g</code>. In other words, multiplication is what we ordinarily think of as composition of the bijections. Here we define this group: EXAMPLES: -/ -- QUOTE: def permGroup {α : Type*} : Group₁ (Equiv.Perm α) where mul f g := Equiv.trans g f one := Equiv.refl α inv := Equiv.symm mul_assoc f g h := (Equiv.trans_assoc _ _ _).symm one_mul := Equiv.trans_refl mul_one := Equiv.refl_trans mul_left_inv := Equiv.self_trans_symm -- QUOTE.</p> <p>/- TEXT: In fact, Mathlib defines exactly this <code>Group</code> structure on <code>Equiv.Perm α</code> in the file <code>GroupTheory.Perm.Basic</code>. As always, you can hover over the theorems used in the definition of <code>permGroup</code> to see their statements, and you can jump to their definitions in the original file to learn more about how they are implemented.</p> <p>In ordinary mathematics, we generally think of notation as independent of structure. For example, we can consider groups :math:<code>(G_1, \cdot, 1, \cdot^{-1})</code>, :math:<code>(G_2, \circ, e, i(\cdot))</code>, and :math:<code>(G_3, +, 0, -)</code>. In the first case, we write the binary operation as :math:<code>\cdot</code>, the identity at :math:<code>1</code>, and the inverse function as :math:<code>x \mapsto x^{-1}</code>. In the second and third cases, we use the notational alternatives shown. When we formalize the notion of a group in Lean, however, the notation is more tightly linked to the structure. In Lean, the components of any <code>Group</code> are named <code>mul</code>, <code>one</code>, and <code>inv</code>, and in a moment we will see how multiplicative notation is set up to refer to them. If we want to use additive notation, we instead use an isomorphic structure <code>AddGroup</code> (the structure underlying additive groups). Its components are named <code>add</code>, <code>zero</code>, and <code>neg</code>, and the associated notation is what you would expect it to be.</p> <p>Recall the type <code>Point</code> that we defined in :numref:<code>section_structures</code>, and the addition function that we defined there. These definitions are reproduced in the examples file that accompanies this section. As an exercise, define an <code>AddGroup₁</code> structure that is similar to the <code>Group₁</code> structure we defined above, except that it uses the additive naming scheme just described. Define negation and a zero on the <code>Point</code> data type, and define the <code>AddGroup₁</code> structure on <code>Point</code>. BOTH: -/ -- QUOTE: structure AddGroup₁ (α : Type*) where /- EXAMPLES: (add : α → α → α) -- fill in the rest SOLUTIONS: -/ add : α → α → α zero : α neg : α → α add_assoc : ∀ x y z : α, add (add x y) z = add x (add y z) add_zero : ∀ x : α, add x zero = x zero_add : ∀ x : α, add x zero = x add_left_neg : ∀ x : α, add (neg x) x = zero</p> <p>-- BOTH: @[ext] structure Point where x : ℝ y : ℝ z : ℝ</p> <p>namespace Point</p> <p>def add (a b : Point) : Point := ⟨a.x + b.x, a.y + b.y, a.z + b.z⟩</p> <p>/- EXAMPLES: def neg (a : Point) : Point := sorry</p> <p>def zero : Point := sorry</p> <p>def addGroupPoint : AddGroup₁ Point := sorry</p> <p>SOLUTIONS: -/ def neg (a : Point) : Point := ⟨-a.x, -a.y, -a.z⟩</p> <p>def zero : Point := ⟨0, 0, 0⟩</p> <p>def addGroupPoint : AddGroup₁ Point where add := Point.add zero := Point.zero neg := Point.neg add_assoc := by simp [Point.add, add_assoc] add_zero := by simp [Point.add, Point.zero] zero_add := by simp [Point.add, Point.zero] add_left_neg := by simp [Point.add, Point.neg, Point.zero]</p> <p>-- BOTH: end Point -- QUOTE.</p> <p>/- TEXT: We are making progress. Now we know how to define algebraic structures in Lean, and we know how to define instances of those structures. But we also want to associate notation with structures so that we can use it with each instance. Moreover, we want to arrange it so that we can define an operation on a structure and use it with any particular instance, and we want to arrange it so that we can prove a theorem about a structure and use it with any instance.</p> <p>In fact, Mathlib is already set up to use generic group notation, definitions, and theorems for <code>Equiv.Perm α</code>. EXAMPLES: -/ section -- QUOTE: variable {α : Type*} (f g : Equiv.Perm α) (n : ℕ)</p> <h1 id=check-f-g>check f * g<a class=headerlink href=#check-f-g title="Permanent link">&para;</a></h1> <h1 id=check-mul_assoc-f-g-g1>check mul_assoc f g g⁻¹<a class=headerlink href=#check-mul_assoc-f-g-g1 title="Permanent link">&para;</a></h1> <p>-- group power, defined for any group</p> <h1 id=check-g-n>check g ^ n<a class=headerlink href=#check-g-n title="Permanent link">&para;</a></h1> <p>example : f * g * g⁻¹ = f := by rw [mul_assoc, mul_right_inv, mul_one]</p> <p>example : f * g * g⁻¹ = f := mul_inv_cancel_right f g</p> <p>example {α : Type*} (f g : Equiv.Perm α) : g.symm.trans (g.trans f) = f := mul_inv_cancel_right f g -- QUOTE.</p> <p>end</p> <p>/- TEXT: You can check that this is not the case for the additive group structure on <code>Point</code> that we asked you to define above. Our task now is to understand that magic that goes on under the hood in order to make the examples for <code>Equiv.Perm α</code> work the way they do.</p> <p>The issue is that Lean needs to be able to <em>find</em> the relevant notation and the implicit group structure, using the information that is found in the expressions that we type. Similarly, when we write <code>x + y</code> with expressions <code>x</code> and <code>y</code> that have type <code>ℝ</code>, Lean needs to interpret the <code>+</code> symbol as the relevant addition function on the reals. It also has to recognize the type <code>ℝ</code> as an instance of a commutative ring, so that all the definitions and theorems for a commutative ring are available. For another example, continuity is defined in Lean relative to any two topological spaces. When we have <code>f : ℝ → ℂ</code> and we write <code>Continuous f</code>, Lean has to find the relevant topologies on <code>ℝ</code> and <code>ℂ</code>.</p> <p>The magic is achieved with a combination of three things.</p> <h1 id=logic-a-definition-that-should-be-interpreted-in-any-group-takes-as>. <em>Logic.</em> A definition that should be interpreted in any group takes, as<a class=headerlink href=#logic-a-definition-that-should-be-interpreted-in-any-group-takes-as title="Permanent link">&para;</a></h1> <p>arguments, the type of the group and the group structure as arguments. Similarly, a theorem about the elements of an arbitrary group begins with universal quantifiers over the type of the group and the group structure.</p> <h1 id=implicit-arguments-the-arguments-for-the-type-and-the-structure>. <em>Implicit arguments.</em> The arguments for the type and the structure<a class=headerlink href=#implicit-arguments-the-arguments-for-the-type-and-the-structure title="Permanent link">&para;</a></h1> <p>are generally left implicit, so that we do not have to write them or see them in the Lean information window. Lean fills the information in for us silently.</p> <h1 id=type-class-inference-also-known-as-class-inference>. <em>Type class inference.</em> Also known as <em>class inference</em>,<a class=headerlink href=#type-class-inference-also-known-as-class-inference title="Permanent link">&para;</a></h1> <p>this is a simple but powerful mechanism that enables us to register information for Lean to use later on. When Lean is called on to fill in implicit arguments to a definition, theorem, or piece of notation, it can make use of information that has been registered.</p> <p>Whereas an annotation <code>(grp : Group G)</code> tells Lean that it should expect to be given that argument explicitly and the annotation <code>{grp : Group G}</code> tells Lean that it should try to figure it out from contextual cues in the expression, the annotation <code>[grp : Group G]</code> tells Lean that the corresponding argument should be synthesized using type class inference. Since the whole point to the use of such arguments is that we generally do not need to refer to them explicitly, Lean allows us to write <code>[Group G]</code> and leave the name anonymous. You have probably already noticed that Lean chooses names like <code>_inst_1</code> automatically. When we use the anonymous square-bracket annotation with the <code>variables</code> command, then as long as the variables are still in scope, Lean automatically adds the argument <code>[Group G]</code> to any definition or theorem that mentions <code>G</code>.</p> <p>How do we register the information that Lean needs to use to carry out the search? Returning to our group example, we need only make two changes. First, instead of using the <code>structure</code> command to define the group structure, we use the keyword <code>class</code> to indicate that it is a candidate for class inference. Second, instead of defining particular instances with <code>def</code>, we use the keyword <code>instance</code> to register the particular instance with Lean. As with the names of class variables, we are allowed to leave the name of an instance definition anonymous, since in general we intend Lean to find it and put it to use without troubling us with the details. EXAMPLES: -/ -- QUOTE: class Group₂ (α : Type*) where mul : α → α → α one : α inv : α → α mul_assoc : ∀ x y z : α, mul (mul x y) z = mul x (mul y z) mul_one : ∀ x : α, mul x one = x one_mul : ∀ x : α, mul one x = x mul_left_inv : ∀ x : α, mul (inv x) x = one</p> <p>instance {α : Type*} : Group₂ (Equiv.Perm α) where mul f g := Equiv.trans g f one := Equiv.refl α inv := Equiv.symm mul_assoc f g h := (Equiv.trans_assoc _ _ _).symm one_mul := Equiv.trans_refl mul_one := Equiv.refl_trans mul_left_inv := Equiv.self_trans_symm -- QUOTE.</p> <p>/- TEXT: The following illustrates their use. EXAMPLES: -/ -- QUOTE:</p> <h1 id=check-group2mul>check Group₂.mul<a class=headerlink href=#check-group2mul title="Permanent link">&para;</a></h1> <p>def mySquare {α : Type*} [Group₂ α] (x : α) := Group₂.mul x x</p> <h1 id=check-mysquare>check mySquare<a class=headerlink href=#check-mysquare title="Permanent link">&para;</a></h1> <p>section variable {β : Type*} (f g : Equiv.Perm β)</p> <p>example : Group₂.mul f g = g.trans f := rfl</p> <p>example : mySquare f = f.trans f := rfl</p> <p>end -- QUOTE.</p> <p>/- TEXT: The <code>#check</code> command shows that <code>Group₂.mul</code> has an implicit argument <code>[Group₂ α]</code> that we expect to be found by class inference, where <code>α</code> is the type of the arguments to <code>Group₂.mul</code>. In other words, <code>{α : Type*}</code> is the implicit argument for the type of the group elements and <code>[Group₂ α]</code> is the implicit argument for the group structure on <code>α</code>. Similarly, when we define a generic squaring function <code>my_square</code> for <code>Group₂</code>, we use an implicit argument <code>{α : Type*}</code> for the type of the elements and an implicit argument <code>[Group₂ α]</code> for the <code>Group₂</code> structure.</p> <p>In the first example, when we write <code>Group₂.mul f g</code>, the type of <code>f</code> and <code>g</code> tells Lean that in the argument <code>α</code> to <code>Group₂.mul</code> has to be instantiated to <code>Equiv.Perm β</code>. That means that Lean has to find an element of <code>Group₂ (Equiv.Perm β)</code>. The previous <code>instance</code> declaration tells Lean exactly how to do that. Problem solved!</p> <p>This simple mechanism for registering information so that Lean can find it when it needs it is remarkably useful. Here is one way it comes up. In Lean's foundation, a data type <code>α</code> may be empty. In a number of applications, however, it is useful to know that a type has at least one element. For example, the function <code>List.headI</code>, which returns the first element of a list, can return the default value when the list is empty. To make that work, the Lean library defines a class <code>Inhabited α</code>, which does nothing more than store a default value. We can show that the <code>Point</code> type is an instance: EXAMPLES: -/ -- QUOTE: instance : Inhabited Point where default := ⟨0, 0, 0⟩</p> <h1 id=check-default-point>check (default : Point)<a class=headerlink href=#check-default-point title="Permanent link">&para;</a></h1> <p>example : ([] : List Point).headI = default := rfl -- QUOTE.</p> <p>/- TEXT: The class inference mechanism is also used for generic notation. The expression <code>x + y</code> is an abbreviation for <code>Add.add x y</code> where---you guessed it---<code>Add α</code> is a class that stores a binary function on <code>α</code>. Writing <code>x + y</code> tells Lean to find a registered instance of <code>[Add.add α]</code> and use the corresponding function. Below, we register the addition function for <code>Point</code>. EXAMPLES: -/ -- QUOTE: instance : Add Point where add := Point.add</p> <p>section variable (x y : Point)</p> <h1 id=check-x-y>check x + y<a class=headerlink href=#check-x-y title="Permanent link">&para;</a></h1> <p>example : x + y = Point.add x y := rfl</p> <p>end -- QUOTE.</p> <p>/- TEXT: In this way, we can assign the notation <code>+</code> to binary operations on other types as well.</p> <p>But we can do even better. We have seen that <code>*</code> can be used in any group, <code>+</code> can be used in any additive group, and both can be used in any ring. When we define a new instance of a ring in Lean, we don't have to define <code>+</code> and <code>*</code> for that instance, because Lean knows that these are defined for every ring. We can use this method to specify notation for our <code>Group₂</code> class: EXAMPLES: -/ -- QUOTE: instance hasMulGroup₂ {α : Type*} [Group₂ α] : Mul α := ⟨Group₂.mul⟩</p> <p>instance hasOneGroup₂ {α : Type*} [Group₂ α] : One α := ⟨Group₂.one⟩</p> <p>instance hasInvGroup₂ {α : Type*} [Group₂ α] : Inv α := ⟨Group₂.inv⟩</p> <p>section variable {α : Type*} (f g : Equiv.Perm α)</p> <h1 id=check-f-1-g1>check f * 1 * g⁻¹<a class=headerlink href=#check-f-1-g1 title="Permanent link">&para;</a></h1> <p>def foo : f * 1 * g⁻¹ = g.symm.trans ((Equiv.refl α).trans f) := rfl</p> <p>end -- QUOTE.</p> <p>/- TEXT: In this case, we have to supply names for the instances, because Lean has a hard time coming up with good defaults. What makes this approach work is that Lean carries out a recursive search. According to the instances we have declared, Lean can find an instance of <code>Mul (Equiv.Perm α)</code> by finding an instance of <code>Group₂ (Equiv.Perm α)</code>, and it can find an instance of <code>Group₂ (Equiv.Perm α)</code> because we have provided one. Lean is capable of finding these two facts and chaining them together.</p> <p>The example we have just given is dangerous, because Lean's library also has an instance of <code>Group (Equiv.Perm α)</code>, and multiplication is defined on any group. So it is ambiguous as to which instance is found. In fact, Lean favors more recent declarations unless you explicitly specify a different priority. Also, there is another way to tell Lean that one structure is an instance of another, using the <code>extends</code> keyword. This is how Mathlib specifies that, for example, every commutative ring is a ring. You can find more information in :numref:<code>hierarchies</code> and in a <code>section on class inference &lt;https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#managing-type-class-inference&gt;</code>_ in <em>Theorem Proving in Lean</em>.</p> <p>In general, it is a bad idea to specify a value of <code>*</code> for an instance of an algebraic structure that already has the notation defined. Redefining the notion of <code>Group</code> in Lean is an artificial example. In this case, however, both interpretations of the group notation unfold to <code>Equiv.trans</code>, <code>Equiv.refl</code>, and <code>Equiv.symm</code>, in the same way.</p> <p>As a similarly artificial exercise, define a class <code>AddGroup₂</code> in analogy to <code>Group₂</code>. Define the usual notation for addition, negation, and zero on any <code>AddGroup₂</code> using the classes <code>Add</code>, <code>Neg</code>, and <code>Zero</code>. Then show <code>Point</code> is an instance of <code>AddGroup₂</code>. Try it out and make sure that the additive group notation works for elements of <code>Point</code>. BOTH: -/ -- QUOTE: class AddGroup₂ (α : Type*) where /- EXAMPLES: add : α → α → α -- fill in the rest -- QUOTE. SOLUTIONS: -/ add : α → α → α zero : α neg : α → α add_assoc : ∀ x y z : α, add (add x y) z = add x (add y z) add_zero : ∀ x : α, add x zero = x zero_add : ∀ x : α, add x zero = x add_left_neg : ∀ x : α, add (neg x) x = zero</p> <p>instance hasAddAddGroup₂ {α : Type*} [AddGroup₂ α] : Add α := ⟨AddGroup₂.add⟩</p> <p>instance hasZeroAddGroup₂ {α : Type*} [AddGroup₂ α] : Zero α := ⟨AddGroup₂.zero⟩</p> <p>instance hasNegAddGroup₂ {α : Type*} [AddGroup₂ α] : Neg α := ⟨AddGroup₂.neg⟩</p> <p>instance : AddGroup₂ Point where add := Point.add zero := Point.zero neg := Point.neg add_assoc := by simp [Point.add, add_assoc] add_zero := by simp [Point.add, Point.zero] zero_add := by simp [Point.add, Point.zero] add_left_neg := by simp [Point.add, Point.neg, Point.zero]</p> <p>section variable (x y : Point)</p> <h1 id=check-x-y-0>check x + -y + 0<a class=headerlink href=#check-x-y-0 title="Permanent link">&para;</a></h1> <p>end</p> <p>/- TEXT: It is not a big problem that we have already declared instances <code>Add</code>, <code>Neg</code>, and <code>Zero</code> for <code>Point</code> above. Once again, the two ways of synthesizing the notation should come up with the same answer.</p> <p>Class inference is subtle, and you have to be careful when using it, because it configures automation that invisibly governs the interpretation of the expressions we type. When used wisely, however, class inference is a powerful tool. It is what makes algebraic reasoning possible in Lean. TEXT. -/</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.sections", "navigation.instant", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"alias": true, "default": "latest", "provider": "mike"}}</script> <script src=../../../assets/javascripts/bundle.fe8b6f2b.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>