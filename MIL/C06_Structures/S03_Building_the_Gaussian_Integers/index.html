<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.0, mkdocs-material-9.5.31"><title>S03 Building the Gaussian Integers - MIL</title><link rel=stylesheet href=../../../assets/stylesheets/main.3cba04c6.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../assets/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent=light-green> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#building-the-gaussian-integers class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <div data-md-color-scheme=default data-md-component=outdated hidden> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=MIL class="md-header__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> MIL </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> S03 Building the Gaussian Integers </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../en/ class=md-tabs__link> 目录 </a> </li> <li class=md-tabs__item> <a href=../../../en/C01_Introduction/ class=md-tabs__link> Introduction </a> </li> <li class=md-tabs__item> <a href=../../../en/C02_Basics/ class=md-tabs__link> Basics </a> </li> <li class=md-tabs__item> <a href=../../../en/C03_Logic/ class=md-tabs__link> Logic </a> </li> <li class=md-tabs__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-tabs__link> Sets and Functions </a> </li> <li class=md-tabs__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-tabs__link> Elementary Number Theory </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=MIL class="md-nav__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> MIL </label> <div class=md-nav__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../en/ class=md-nav__link> <span class=md-ellipsis> 目录 </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C01_Introduction/ class=md-nav__link> <span class=md-ellipsis> Introduction </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C02_Basics/ class=md-nav__link> <span class=md-ellipsis> Basics </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C03_Logic/ class=md-nav__link> <span class=md-ellipsis> Logic </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-nav__link> <span class=md-ellipsis> Sets and Functions </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-nav__link> <span class=md-ellipsis> Elementary Number Theory </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#building-the-gaussian-integers class=md-nav__link> <span class=md-ellipsis> Building the Gaussian Integers </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1>S03 Building the Gaussian Integers</h1> <p>import Mathlib.Algebra.EuclideanDomain.Basic import Mathlib.RingTheory.PrincipalIdealDomain import MIL.Common</p> <p>/- TEXT: .. _section_building_the_gaussian_integers:</p> <h2 id=building-the-gaussian-integers>Building the Gaussian Integers<a class=headerlink href=#building-the-gaussian-integers title="Permanent link">&para;</a></h2> <p>We will now illustrate the use of the algebraic hierarchy in Lean by building an important mathematical object, the <em>Gaussian integers</em>, and showing that it is a Euclidean domain. In other words, according to the terminology we have been using, we will define the Gaussian integers and show that they are an instance of the Euclidean domain structure.</p> <p>In ordinary mathematical terms, the set of Gaussian integers :math:<code>\Bbb{Z}[i]</code> is the set of complex numbers :math:<code>\{ a + b i \mid a, b \in \Bbb{Z}\}</code>. But rather than define them as a subset of the complex numbers, our goal here is to define them as a data type in their own right. We do this by representing a Gaussian integer as a pair of integers, which we think of as the <em>real</em> and <em>imaginary</em> parts. BOTH: -/ -- QUOTE: @[ext] structure GaussInt where re : ℤ im : ℤ -- QUOTE.</p> <p>/- TEXT: We first show that the Gaussian integers have the structure of a ring, with <code>0</code> defined to be <code>⟨0, 0⟩</code>, <code>1</code> defined to be <code>⟨1, 0⟩</code>, and addition defined pointwise. To work out the definition of multiplication, remember that we want the element :math:<code>i</code>, represented by <code>⟨0, 1⟩</code>, to be a square root of :math:<code>-1</code>. Thus we want</p> <p>.. math::</p> <p>(a + bi) (c + di) &amp; = ac + bci + adi + bd i^2 \ &amp; = (ac - bd) + (bc + ad)i.</p> <p>This explains the definition of <code>Mul</code> below. BOTH: -/ namespace GaussInt</p> <p>-- QUOTE: instance : Zero GaussInt := ⟨⟨0, 0⟩⟩</p> <p>instance : One GaussInt := ⟨⟨1, 0⟩⟩</p> <p>instance : Add GaussInt := ⟨fun x y ↦ ⟨x.re + y.re, x.im + y.im⟩⟩</p> <p>instance : Neg GaussInt := ⟨fun x ↦ ⟨-x.re, -x.im⟩⟩</p> <p>instance : Mul GaussInt := ⟨fun x y ↦ ⟨x.re * y.re - x.im * y.im, x.re * y.im + x.im * y.re⟩⟩ -- QUOTE.</p> <p>/- TEXT: As noted in :numref:<code>section_structures</code>, it is a good idea to put all the definitions related to a data type in a namespace with the same name. Thus in the Lean files associated with this chapter, these definitions are made in the <code>GaussInt</code> namespace.</p> <p>Notice that here we are defining the interpretations of the notation <code>0</code>, <code>1</code>, <code>+</code>, <code>-</code>, and <code>*</code> directly, rather than naming them <code>GaussInt.zero</code> and the like and assigning the notation to those. It is often useful to have an explicit name for the definitions, for example, to use with <code>simp</code> and <code>rewrite</code>. BOTH: -/ -- QUOTE: theorem zero_def : (0 : GaussInt) = ⟨0, 0⟩ := rfl</p> <p>theorem one_def : (1 : GaussInt) = ⟨1, 0⟩ := rfl</p> <p>theorem add_def (x y : GaussInt) : x + y = ⟨x.re + y.re, x.im + y.im⟩ := rfl</p> <p>theorem neg_def (x : GaussInt) : -x = ⟨-x.re, -x.im⟩ := rfl</p> <p>theorem mul_def (x y : GaussInt) : x * y = ⟨x.re * y.re - x.im * y.im, x.re * y.im + x.im * y.re⟩ := rfl -- QUOTE.</p> <p>/- TEXT: It is also useful to name the rules that compute the real and imaginary parts, and to declare them to the simplifier. BOTH: -/ -- QUOTE: @[simp] theorem zero_re : (0 : GaussInt).re = 0 := rfl</p> <p>@[simp] theorem zero_im : (0 : GaussInt).im = 0 := rfl</p> <p>@[simp] theorem one_re : (1 : GaussInt).re = 1 := rfl</p> <p>@[simp] theorem one_im : (1 : GaussInt).im = 0 := rfl</p> <p>@[simp] theorem add_re (x y : GaussInt) : (x + y).re = x.re + y.re := rfl</p> <p>@[simp] theorem add_im (x y : GaussInt) : (x + y).im = x.im + y.im := rfl</p> <p>@[simp] theorem neg_re (x : GaussInt) : (-x).re = -x.re := rfl</p> <p>@[simp] theorem neg_im (x : GaussInt) : (-x).im = -x.im := rfl</p> <p>@[simp] theorem mul_re (x y : GaussInt) : (x * y).re = x.re * y.re - x.im * y.im := rfl</p> <p>@[simp] theorem mul_im (x y : GaussInt) : (x * y).im = x.re * y.im + x.im * y.re := rfl -- QUOTE.</p> <p>/- TEXT: It is now surprisingly easy to show that the Gaussian integers are an instance of a commutative ring. We are putting the structure concept to good use. Each particular Gaussian integer is an instance of the <code>GaussInt</code> structure, whereas the type <code>GaussInt</code> itself, together with the relevant operations, is an instance of the <code>CommRing</code> structure. The <code>CommRing</code> structure, in turn, extends the notational structures <code>Zero</code>, <code>One</code>, <code>Add</code>, <code>Neg</code>, and <code>Mul</code>.</p> <p>If you type <code>instance : CommRing GaussInt := _</code>, click on the light bulb that appears in VS Code, and then ask Lean to fill in a skeleton for the structure definition, you will see a scary number of entries. Jumping to the definition of the structure, however, shows that many of the fields have default definitions that Lean will fill in for you automatically. The essential ones appear in the definition below. A special case are <code>nsmul</code> and <code>zsmul</code> which should be ignored for now and will be explained in the next chapter. In each case, the relevant identity is proved by unfolding definitions, using the <code>ext</code> tactic to reduce the identities to their real and imaginary components, simplifying, and, if necessary, carrying out the relevant ring calculation in the integers. Note that we could easily avoid repeating all this code, but this is not the topic of the current discussion. BOTH: -/ -- QUOTE: instance instCommRing : CommRing GaussInt where zero := 0 one := 1 add := (· + ·) neg x := -x mul := (· * ·) nsmul := nsmulRec zsmul := zsmulRec add_assoc := by intros ext &lt;;&gt; simp &lt;;&gt; ring zero_add := by intro ext &lt;;&gt; simp add_zero := by intro ext &lt;;&gt; simp add_left_neg := by intro ext &lt;;&gt; simp add_comm := by intros ext &lt;;&gt; simp &lt;;&gt; ring mul_assoc := by intros ext &lt;;&gt; simp &lt;;&gt; ring one_mul := by intro ext &lt;;&gt; simp mul_one := by intro ext &lt;;&gt; simp left_distrib := by intros ext &lt;;&gt; simp &lt;;&gt; ring right_distrib := by intros ext &lt;;&gt; simp &lt;;&gt; ring mul_comm := by intros ext &lt;;&gt; simp &lt;;&gt; ring zero_mul := by intros ext &lt;;&gt; simp mul_zero := by intros ext &lt;;&gt; simp -- QUOTE.</p> <p>@[simp] theorem sub_re (x y : GaussInt) : (x - y).re = x.re - y.re := rfl</p> <p>@[simp] theorem sub_im (x y : GaussInt) : (x - y).im = x.im - y.im := rfl</p> <p>/- TEXT: Lean's library defines the class of <em>nontrivial</em> types to be types with at least two distinct elements. In the context of a ring, this is equivalent to saying that the zero is not equal to the one. Since some common theorems depend on that fact, we may as well establish it now. BOTH: -/ -- QUOTE: instance : Nontrivial GaussInt := by use 0, 1 rw [Ne, GaussInt.ext_iff] simp -- QUOTE.</p> <p>end GaussInt</p> <p>/- TEXT: We will now show that the Gaussian integers have an important additional property. A <em>Euclidean domain</em> is a ring :math:<code>R</code> equipped with a <em>norm</em> function :math:<code>N : R \to \mathbb{N}</code> with the following two properties:</p> <ul> <li>For every :math:<code>a</code> and :math:<code>b \ne 0</code> in :math:<code>R</code>, there are :math:<code>q</code> and :math:<code>r</code> in :math:<code>R</code> such that :math:<code>a = bq + r</code> and either :math:<code>r = 0</code> or <code>N(r) &lt; N(b)</code>.</li> <li>For every :math:<code>a</code> and :math:<code>b \ne 0</code>, :math:<code>N(a) \le N(ab)</code>.</li> </ul> <p>The ring of integers :math:<code>\Bbb{Z}</code> with :math:<code>N(a) = |a|</code> is an archetypal example of a Euclidean domain. In that case, we can take :math:<code>q</code> to be the result of integer division of :math:<code>a</code> by :math:<code>b</code> and :math:<code>r</code> to be the remainder. These functions are defined in Lean so that the satisfy the following: EXAMPLES: -/ -- QUOTE: example (a b : ℤ) : a = b * (a / b) + a % b := Eq.symm (Int.ediv_add_emod a b)</p> <p>example (a b : ℤ) : b ≠ 0 → 0 ≤ a % b := Int.emod_nonneg a</p> <p>example (a b : ℤ) : b ≠ 0 → a % b &lt; |b| := Int.emod_lt a -- QUOTE.</p> <p>/- TEXT: In an arbitrary ring, an element :math:<code>a</code> is said to be a <em>unit</em> if it divides :math:<code>1</code>. A nonzero element :math:<code>a</code> is said to be <em>irreducible</em> if it cannot be written in the form :math:<code>a = bc</code> where neither :math:<code>b</code> nor :math:<code>c</code> is a unit. In the integers, every irreducible element :math:<code>a</code> is <em>prime</em>, which is to say, whenever :math:<code>a</code> divides a product :math:<code>bc</code>, it divides either :math:<code>b</code> or :math:<code>c</code>. But in other rings this property can fail. In the ring :math:<code>\Bbb{Z}[\sqrt{-5}]</code>, we have</p> <p>.. math::</p> <p>6 = 2 \cdot 3 = (1 + \sqrt{-5})(1 - \sqrt{-5}),</p> <p>and the elements :math:<code>2</code>, :math:<code>3</code>, :math:<code>1 + \sqrt{-5}</code>, and :math:<code>1 - \sqrt{-5}</code> are all irreducible, but they are not prime. For example, :math:<code>2</code> divides the product :math:<code>(1 + \sqrt{-5})(1 - \sqrt{-5})</code>, but it does not divide either factor. In particular, we no longer have unique factorization: the number :math:<code>6</code> can be factored into irreducible elements in more than one way.</p> <p>In contrast, every Euclidean domain is a unique factorization domain, which implies that every irreducible element is prime. The axioms for a Euclidean domain imply that one can write any nonzero element as a finite product of irreducible elements. They also imply that one can use the Euclidean algorithm to find a greatest common divisor of any two nonzero elements <code>a</code> and <code>b</code>, i.e.~an element that is divisible by any other common divisor. This, in turn, implies that factorization into irreducible elements is unique up to multiplication by units.</p> <p>We now show that the Gaussian integers are a Euclidean domain with the norm defined by :math:<code>N(a + bi) = (a + bi)(a - bi) = a^2 + b^2</code>. The Gaussian integer :math:<code>a - bi</code> is called the <em>conjugate</em> of :math:<code>a + bi</code>. It is not hard to check that for any complex numbers :math:<code>x</code> and :math:<code>y</code>, we have :math:<code>N(xy) = N(x)N(y)</code>.</p> <p>To see that this definition of the norm makes the Gaussian integers a Euclidean domain, only the first property is challenging. Suppose we want to write :math:<code>a + bi = (c + di) q + r</code> for suitable :math:<code>q</code> and :math:<code>r</code>. Treating :math:<code>a + bi</code> and :math:<code>c + di</code> are complex numbers, carry out the division</p> <p>.. math::</p> <p>\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{(c + di)(c-di)} = \frac{ac + bd}{c^2 + d^2} + \frac{bc -ad}{c<sup>2+d</sup>2} i.</p> <p>The real and imaginary parts might not be integers, but we can round them to the nearest integers :math:<code>u</code> and :math:<code>v</code>. We can then express the right-hand side as :math:<code>(u + vi) + (u' + v'i)</code>, where :math:<code>u' + v'i</code> is the part left over. Note that we have :math:<code>|u'| \le 1/2</code> and :math:<code>|v'| \le 1/2</code>, and hence</p> <p>.. math::</p> <p>N(u' + v' i) = (u')^2 + (v')^2 \le &frac14; + &frac14; \le &frac12;.</p> <p>Multiplying through by :math:<code>c + di</code>, we have</p> <p>.. math::</p> <p>a + bi = (c + di) (u + vi) + (c + di) (u' + v'i).</p> <p>Setting :math:<code>q = u + vi</code> and :math:<code>r = (c + di) (u' + v'i)</code>, we have :math:<code>a + bi = (c + di) q + r</code>, and we only need to bound :math:<code>N(r)</code>:</p> <p>.. math::</p> <p>N&reg; = N(c + di)N(u' + v'i) \le N(c + di) \cdot &frac12; &lt; N(c + di).</p> <p>The argument we just carried out requires viewing the Gaussian integers as a subset of the complex numbers. One option for formalizing it in Lean is therefore to embed the Gaussian integers in the complex numbers, embed the integers in the Gaussian integers, define the rounding function from the real numbers to the integers, and take great care to pass back and forth between these number systems appropriately. In fact, this is exactly the approach that is followed in Mathlib, where the Gaussian integers themselves are constructed as a special case of a ring of <em>quadratic integers</em>. See the file <code>GaussianInt.lean &lt;https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean&gt;</code>_.</p> <p>Here we will instead carry out an argument that stays in the integers. This illustrates an choice one commonly faces when formalizing mathematics. Given an argument that requires concepts or machinery that is not already in the library, one has two choices: either formalizes the concepts or machinery needed, or adapt the argument to make use of concepts and machinery you already have. The first choice is generally a good investment of time when the results can be used in other contexts. Pragmatically speaking, however, sometimes seeking a more elementary proof is more efficient.</p> <p>The usual quotient-remainder theorem for the integers says that for every :math:<code>a</code> and nonzero :math:<code>b</code>, there are :math:<code>q</code> and :math:<code>r</code> such that :math:<code>a = b q + r</code> and :math:<code>0 \le r &lt; b</code>. Here we will make use of the following variation, which says that there are :math:<code>q'</code> and :math:<code>r'</code> such that :math:<code>a = b q' + r'</code> and :math:<code>|r'| \le b/2</code>. You can check that if the value of :math:<code>r</code> in the first statement satisfies :math:<code>r \le b/2</code>, we can take :math:<code>q' = q</code> and :math:<code>r' = r</code>, and otherwise we can take :math:<code>q' = q + 1</code> and :math:<code>r' = r - b</code>. We are grateful to Heather Macbeth for suggesting the following more elegant approach, which avoids definition by cases. We simply add <code>b / 2</code> to <code>a</code> before dividing and then subtract it from the remainder. BOTH: -/ namespace Int</p> <p>-- QUOTE: def div' (a b : ℤ) := (a + b / 2) / b</p> <p>def mod' (a b : ℤ) := (a + b / 2) % b - b / 2</p> <p>theorem div'_add_mod' (a b : ℤ) : b * div' a b + mod' a b = a := by rw [div', mod'] linarith [Int.ediv_add_emod (a + b / 2) b]</p> <p>theorem abs_mod'_le (a b : ℤ) (h : 0 &lt; b) : |mod' a b| ≤ b / 2 := by rw [mod', abs_le] constructor · linarith [Int.emod_nonneg (a + b / 2) h.ne'] have := Int.emod_lt_of_pos (a + b / 2) h have := Int.ediv_add_emod b 2 have := Int.emod_lt_of_pos b zero_lt_two revert this; intro this -- FIXME, this should not be needed linarith -- QUOTE.</p> <p>/- TEXT: Note the use of our old friend, <code>linarith</code>. We will also need to express <code>mod'</code> in terms of <code>div'</code>. BOTH: -/ -- QUOTE: theorem mod'_eq (a b : ℤ) : mod' a b = a - b * div' a b := by linarith [div'_add_mod' a b] -- QUOTE.</p> <p>end Int</p> <p>/- TEXT: We will use the fact that :math:<code>x^2 + y^2</code> is equal to zero if and only if :math:<code>x</code> and :math:<code>y</code> are both zero. As an exercise, we ask you to prove that this holds in any ordered ring. SOLUTIONS: -/ private theorem aux {α : Type*} [LinearOrderedRing α] {x y : α} (h : x ^ 2 + y ^ 2 = 0) : x = 0 := haveI h' : x ^ 2 = 0 := by apply le_antisymm _ (sq_nonneg x) rw [← h] apply le_add_of_nonneg_right (sq_nonneg y) pow_eq_zero h'</p> <p>-- QUOTE: -- BOTH: theorem sq_add_sq_eq_zero {α : Type*} [LinearOrderedRing α] (x y : α) : x ^ 2 + y ^ 2 = 0 ↔ x = 0 ∧ y = 0 := by /- EXAMPLES: sorry SOLUTIONS: -/ constructor · intro h constructor · exact aux h rw [add_comm] at h exact aux h rintro ⟨rfl, rfl⟩ norm_num -- QUOTE.</p> <p>-- BOTH: /- TEXT: We will put all the remaining definitions and theorems in this section in the <code>GaussInt</code> namespace. First, we define the <code>norm</code> function and ask you to establish some of its properties. The proofs are all short. BOTH: -/ namespace GaussInt</p> <p>-- QUOTE: def norm (x : GaussInt) := x.re ^ 2 + x.im ^ 2</p> <p>@[simp] theorem norm_nonneg (x : GaussInt) : 0 ≤ norm x := by /- EXAMPLES: sorry SOLUTIONS: -/ apply add_nonneg &lt;;&gt; apply sq_nonneg</p> <p>-- BOTH: theorem norm_eq_zero (x : GaussInt) : norm x = 0 ↔ x = 0 := by /- EXAMPLES: sorry SOLUTIONS: -/ rw [norm, sq_add_sq_eq_zero, GaussInt.ext_iff] rfl</p> <p>-- BOTH: theorem norm_pos (x : GaussInt) : 0 &lt; norm x ↔ x ≠ 0 := by /- EXAMPLES: sorry SOLUTIONS: -/ rw [lt_iff_le_and_ne, ne_comm, Ne, norm_eq_zero] simp [norm_nonneg]</p> <p>-- BOTH: theorem norm_mul (x y : GaussInt) : norm (x * y) = norm x * norm y := by /- EXAMPLES: sorry SOLUTIONS: -/ simp [norm] ring</p> <p>-- BOTH: -- QUOTE. /- TEXT: Next we define the conjugate function: BOTH: -/ -- QUOTE: def conj (x : GaussInt) : GaussInt := ⟨x.re, -x.im⟩</p> <p>@[simp] theorem conj_re (x : GaussInt) : (conj x).re = x.re := rfl</p> <p>@[simp] theorem conj_im (x : GaussInt) : (conj x).im = -x.im := rfl</p> <p>theorem norm_conj (x : GaussInt) : norm (conj x) = norm x := by simp [norm] -- QUOTE.</p> <p>/- TEXT: Finally, we define division for the Gaussian integers with the notation <code>x / y</code>, that rounds the complex quotient to the nearest Gaussian integer. We use our bespoke <code>Int.div'</code> for that purpose. As we calculated above, if <code>x</code> is :math:<code>a + bi</code> and <code>y</code> is :math:<code>c + di</code>, then the real and imaginary parts of <code>x / y</code> are the nearest integers to</p> <p>.. math::</p> <p>\frac{ac + bd}{c^2 + d^2} \quad \text{and} \quad \frac{bc -ad}{c<sup>2+d</sup>2},</p> <p>respectively. Here the numerators are the real and imaginary parts of :math:<code>(a + bi) (c - di)</code>, and the denominators are both equal to the norm of :math:<code>c + di</code>. BOTH: -/ -- QUOTE: instance : Div GaussInt := ⟨fun x y ↦ ⟨Int.div' (x * conj y).re (norm y), Int.div' (x * conj y).im (norm y)⟩⟩ -- QUOTE.</p> <p>/- TEXT: Having defined <code>x / y</code>, We define <code>x % y</code> to be the remainder, <code>x - (x / y) * y</code>. As above, we record the definitions in the theorems <code>div_def</code> and <code>mod_def</code> so that we can use them with <code>simp</code> and <code>rewrite</code>. BOTH: -/ -- QUOTE: instance : Mod GaussInt := ⟨fun x y ↦ x - y * (x / y)⟩</p> <p>theorem div_def (x y : GaussInt) : x / y = ⟨Int.div' (x * conj y).re (norm y), Int.div' (x * conj y).im (norm y)⟩ := rfl</p> <p>theorem mod_def (x y : GaussInt) : x % y = x - y * (x / y) := rfl -- QUOTE.</p> <p>/- TEXT: These definitions immediately yield <code>x = y * (x / y) + x % y</code> for every <code>x</code> and <code>y</code>, so all we need to do is show that the norm of <code>x % y</code> is less than the norm of <code>y</code> when <code>y</code> is not zero.</p> <p>We just defined the real and imaginary parts of <code>x / y</code> to be <code>div' (x * conj y).re (norm y)</code> and <code>div' (x * conj y).im (norm y)</code>, respectively. Calculating, we have</p> <p><code>(x % y) * conj y = (x - x / y * y) * conj y = x * conj y - x / y * (y * conj y)</code></p> <p>The real and imaginary parts of the right-hand side are exactly <code>mod' (x * conj y).re (norm y)</code> and <code>mod' (x * conj y).im (norm y)</code>. By the properties of <code>div'</code> and <code>mod'</code>, these are guaranteed to be less than or equal to <code>norm y / 2</code>. So we have</p> <p><code>norm ((x % y) * conj y) ≤ (norm y / 2)^2 + (norm y / 2)^2 ≤ (norm y / 2) * norm y</code>.</p> <p>On the other hand, we have</p> <p><code>norm ((x % y) * conj y) = norm (x % y) * norm (conj y) = norm (x % y) * norm y</code>.</p> <p>Dividing through by <code>norm y</code> we have <code>norm (x % y) ≤ (norm y) / 2 &lt; norm y</code>, as required.</p> <p>This messy calculation is carried out in the next proof. We encourage you to step through the details and see if you can find a nicer argument. BOTH: -/ -- QUOTE: theorem norm_mod_lt (x : GaussInt) {y : GaussInt} (hy : y ≠ 0) : (x % y).norm &lt; y.norm := by have norm_y_pos : 0 &lt; norm y := by rwa [norm_pos] have H1 : x % y * conj y = ⟨Int.mod' (x * conj y).re (norm y), Int.mod' (x * conj y).im (norm y)⟩ · ext &lt;;&gt; simp [Int.mod'_eq, mod_def, div_def, norm] &lt;;&gt; ring have H2 : norm (x % y) * norm y ≤ norm y / 2 * norm y · calc norm (x % y) * norm y = norm (x % y * conj y) := by simp only [norm_mul, norm_conj] _ = |Int.mod' (x.re * y.re + x.im * y.im) (norm y)| ^ 2 + |Int.mod' (-(x.re * y.im) + x.im * y.re) (norm y)| ^ 2 := by simp [H1, norm, sq_abs] _ ≤ (y.norm / 2) ^ 2 + (y.norm / 2) ^ 2 := by gcongr &lt;;&gt; apply Int.abs_mod'_le _ _ norm_y_pos _ = norm y / 2 * (norm y / 2 * 2) := by ring _ ≤ norm y / 2 * norm y := by gcongr; apply Int.ediv_mul_le; norm_num calc norm (x % y) ≤ norm y / 2 := le_of_mul_le_mul_right H2 norm_y_pos _ &lt; norm y := by apply Int.ediv_lt_of_lt_mul · norm_num · linarith -- QUOTE.</p> <p>/- TEXT: We are in the home stretch. Our <code>norm</code> function maps Gaussian integers to nonnegative integers. We need a function that maps Gaussian integers to natural numbers, and we obtain that by composing <code>norm</code> with the function <code>Int.natAbs</code>, which maps integers to the natural numbers. The first of the next two lemmas establishes that mapping the norm to the natural numbers and back to the integers does not change the value. The second one re-expresses the fact that the norm is decreasing. BOTH: -/ -- QUOTE: theorem coe_natAbs_norm (x : GaussInt) : (x.norm.natAbs : ℤ) = x.norm := Int.natAbs_of_nonneg (norm_nonneg _)</p> <p>theorem natAbs_norm_mod_lt (x y : GaussInt) (hy : y ≠ 0) : (x % y).norm.natAbs &lt; y.norm.natAbs := by apply Int.ofNat_lt.1 simp only [Int.coe_natAbs, abs_of_nonneg, norm_nonneg] apply norm_mod_lt x hy -- QUOTE.</p> <p>/- TEXT: We also need to establish the second key property of the norm function on a Euclidean domain. BOTH: -/ -- QUOTE: theorem not_norm_mul_left_lt_norm (x : GaussInt) {y : GaussInt} (hy : y ≠ 0) : ¬(norm (x * y)).natAbs &lt; (norm x).natAbs := by apply not_lt_of_ge rw [norm_mul, Int.natAbs_mul] apply le_mul_of_one_le_right (Nat.zero_le _) apply Int.ofNat_le.1 rw [coe_natAbs_norm] exact Int.add_one_le_of_lt ((norm_pos _).mpr hy) -- QUOTE.</p> <p>/- TEXT: We can now put it together to show that the Gaussian integers are an instance of a Euclidean domain. We use the quotient and remainder function we have defined. The Mathlib definition of a Euclidean domain is more general than the one above in that it allows us to show that remainder decreases with respect to any well-founded measure. Comparing the values of a norm function that returns natural numbers is just one instance of such a measure, and in that case, the required properties are the theorems <code>natAbs_norm_mod_lt</code> and <code>not_norm_mul_left_lt_norm</code>. BOTH: -/ -- QUOTE: instance : EuclideanDomain GaussInt := { GaussInt.instCommRing with quotient := (· / ·) remainder := (· % ·) quotient_mul_add_remainder_eq := fun x y ↦ by simp only; rw [mod_def, add_comm] ; ring quotient_zero := fun x ↦ by simp [div_def, norm, Int.div'] rfl r := (measure (Int.natAbs ∘ norm)).1 r_wellFounded := (measure (Int.natAbs ∘ norm)).2 remainder_lt := natAbs_norm_mod_lt mul_left_not_lt := not_norm_mul_left_lt_norm } -- QUOTE.</p> <p>/- TEXT: An immediate payoff is that we now know that, in the Gaussian integers, the notions of being prime and being irreducible coincide. BOTH: -/ -- QUOTE: example (x : GaussInt) : Irreducible x ↔ Prime x := PrincipalIdealRing.irreducible_iff_prime -- QUOTE.</p> <p>end GaussInt</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.sections", "navigation.instant", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"alias": true, "default": "latest", "provider": "mike"}}</script> <script src=../../../assets/javascripts/bundle.fe8b6f2b.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>