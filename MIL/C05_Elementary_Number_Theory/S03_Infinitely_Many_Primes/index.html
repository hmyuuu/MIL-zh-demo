<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.0, mkdocs-material-9.5.31"><title>S03 Infinitely Many Primes - MIL</title><link rel=stylesheet href=../../../assets/stylesheets/main.3cba04c6.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../assets/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent=light-green> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#infinitely-many-primes class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <div data-md-color-scheme=default data-md-component=outdated hidden> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=MIL class="md-header__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> MIL </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> S03 Infinitely Many Primes </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../en/ class=md-tabs__link> 目录 </a> </li> <li class=md-tabs__item> <a href=../../../en/C01_Introduction/ class=md-tabs__link> Introduction </a> </li> <li class=md-tabs__item> <a href=../../../en/C02_Basics/ class=md-tabs__link> Basics </a> </li> <li class=md-tabs__item> <a href=../../../en/C03_Logic/ class=md-tabs__link> Logic </a> </li> <li class=md-tabs__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-tabs__link> Sets and Functions </a> </li> <li class=md-tabs__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-tabs__link> Elementary Number Theory </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=MIL class="md-nav__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> MIL </label> <div class=md-nav__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../en/ class=md-nav__link> <span class=md-ellipsis> 目录 </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C01_Introduction/ class=md-nav__link> <span class=md-ellipsis> Introduction </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C02_Basics/ class=md-nav__link> <span class=md-ellipsis> Basics </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C03_Logic/ class=md-nav__link> <span class=md-ellipsis> Logic </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-nav__link> <span class=md-ellipsis> Sets and Functions </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-nav__link> <span class=md-ellipsis> Elementary Number Theory </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#infinitely-many-primes class=md-nav__link> <span class=md-ellipsis> Infinitely Many Primes </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1>S03 Infinitely Many Primes</h1> <p>import Mathlib.Data.Nat.Prime.Basic import MIL.Common</p> <p>open BigOperators</p> <p>namespace C05S03</p> <p>/- TEXT: .. _section_infinitely_many_primes:</p> <h2 id=infinitely-many-primes>Infinitely Many Primes<a class=headerlink href=#infinitely-many-primes title="Permanent link">&para;</a></h2> <p>Let us continue our exploration of induction and recursion with another mathematical standard: a proof that there are infinitely many primes. One way to formulate this is as the statement that for every natural number :math:<code>n</code>, there is a prime number greater than :math:<code>n</code>. To prove this, let :math:<code>p</code> be any prime factor of :math:<code>n! + 1</code>. If :math:<code>p</code> is less than :math:<code>n</code>, it divides :math:<code>n!</code>. Since it also divides :math:<code>n! + 1</code>, it divides 1, a contradiction. Hence :math:<code>p</code> is greater than :math:<code>n</code>.</p> <p>To formalize that proof, we need to show that any number greater than or equal to 2 has a prime factor. To do that, we will need to show that any natural number that is not equal to 0 or 1 is greater-than or equal to 2. And this brings us to a quirky feature of formalization: it is often trivial statements like this that are among the most annoying to formalize. Here we consider a few ways to do it.</p> <p>To start with, we can use the <code>cases</code> tactic and the fact that the successor function respects the ordering on the natural numbers. BOTH: -/ -- QUOTE: theorem two_le {m : ℕ} (h0 : m ≠ 0) (h1 : m ≠ 1) : 2 ≤ m := by cases m; contradiction case succ m =&gt; cases m; contradiction repeat' apply Nat.succ_le_succ apply zero_le -- QUOTE.</p> <p>/- TEXT: Another strategy is to use the tactic <code>interval_cases</code>, which automatically splits the goal into cases when the variable in question is contained in an interval of natural numbers or integers. Remember that you can hover over it to see its documentation. EXAMPLES: -/ -- QUOTE: example {m : ℕ} (h0 : m ≠ 0) (h1 : m ≠ 1) : 2 ≤ m := by by_contra h push_neg at h interval_cases m &lt;;&gt; contradiction -- QUOTE.</p> <p>/- TEXT: .. index:: decide, tactics ; decide</p> <p>Recall that the semicolon after <code>interval_cases m</code> means that the next tactic is applied to each of the cases that it generates. Yet another option is to use the tactic, <code>decide</code>, which tries to find a decision procedure to solve the problem. Lean knows that you can decide the truth value of a statement that begins with a bounded quantifier <code>∀ x, x &lt; n → ...</code> or <code>∃ x, x &lt; n ∧ ...</code> by deciding each of the finitely many instances. EXAMPLES: -/ -- QUOTE: example {m : ℕ} (h0 : m ≠ 0) (h1 : m ≠ 1) : 2 ≤ m := by by_contra h push_neg at h revert h0 h1 revert h m decide -- QUOTE.</p> <p>/- TEXT: With the theorem <code>two_le</code> in hand, let's start by showing that every natural number greater than two has a prime divisor. Mathlib contains a function <code>Nat.minFac</code> that returns the smallest prime divisor, but for the sake of learning new parts of the library, we'll avoid using it and prove the theorem directly.</p> <p>Here, ordinary induction isn't enough. We want to use <em>strong induction</em>, which allows us to prove that every natural number :math:<code>n</code> has a property :math:<code>P</code> by showing that for every number :math:<code>n</code>, if :math:<code>P</code> holds of all values less than :math:<code>n</code>, it holds at :math:<code>n</code> as well. In Lean, this principle is called <code>Nat.strong_induction_on</code>, and we can use the <code>using</code> keyword to tell the induction tactic to use it. Notice that when we do that, there is no base case; it is subsumed by the general induction step.</p> <p>The argument is simply as follows. Assuming :math:<code>n ≥ 2</code>, if :math:<code>n</code> is prime, we're done. If it isn't, then by one of the characterizations of what it means to be a prime number, it has a nontrivial factor, :math:<code>m</code>, and we can apply the inductive hypothesis to that. Step through the next proof to see how that plays out. The line <code>dsimp at ih</code> simplifies the expression of the inductive hypothesis to make it more readable. The proof still works if you delete that line. BOTH: -/ -- QUOTE: theorem exists_prime_factor {n : Nat} (h : 2 ≤ n) : ∃ p : Nat, p.Prime ∧ p ∣ n := by by_cases np : n.Prime · use n, np induction' n using Nat.strong_induction_on with n ih rw [Nat.prime_def_lt] at np push_neg at np rcases np h with ⟨m, mltn, mdvdn, mne1⟩ have : m ≠ 0 := by intro mz rw [mz, zero_dvd_iff] at mdvdn linarith have mgt2 : 2 ≤ m := two_le this mne1 by_cases mp : m.Prime · use m, mp . rcases ih m mltn mgt2 mp with ⟨p, pp, pdvd⟩ use p, pp apply pdvd.trans mdvdn -- QUOTE.</p> <p>/- TEXT: We can now prove the following formulation of our theorem. See if you can fill out the sketch. You can use <code>Nat.factorial_pos</code>, <code>Nat.dvd_factorial</code>, and <code>Nat.dvd_sub'</code>. BOTH: -/ -- QUOTE: theorem primes_infinite : ∀ n, ∃ p &gt; n, Nat.Prime p := by intro n have : 2 ≤ Nat.factorial (n + 1) + 1 := by /- EXAMPLES: sorry SOLUTIONS: -/ apply Nat.succ_le_succ exact Nat.succ_le_of_lt (Nat.factorial_pos _) -- BOTH: rcases exists_prime_factor this with ⟨p, pp, pdvd⟩ refine' ⟨p, _, pp⟩ show p &gt; n by_contra ple push_neg at ple have : p ∣ Nat.factorial (n + 1) := by /- EXAMPLES: sorry SOLUTIONS: -/ apply Nat.dvd_factorial apply pp.pos linarith -- BOTH: have : p ∣ 1 := by /- EXAMPLES: sorry SOLUTIONS: -/ convert Nat.dvd_sub' pdvd this simp -- BOTH: show False /- EXAMPLES: sorry SOLUTIONS: -/ have := Nat.le_of_dvd zero_lt_one this linarith [pp.two_le]</p> <p>-- BOTH: -- QUOTE. /- TEXT: Let's consider a variation of the proof above, where instead of using the factorial function, we suppose that we are given by a finite set :math:<code>\{ p_1, \ldots, p_n \}</code> and we consider a prime factor of :math:<code>\prod_{i = 1}^n p_i + 1</code>. That prime factor has to be distinct from each :math:<code>p_i</code>, showing that there is no finite set that contains all the prime numbers.</p> <p>Formalizing this argument requires us to reason about finite sets. In Lean, for any type <code>α</code>, the type <code>Finset α</code> represents finite sets of elements of type <code>α</code>. Reasoning about finite sets computationally requires having a procedure to test equality on <code>α</code>, which is why the snippet below includes the assumption <code>[DecidableEq α]</code>. For concrete data types like <code>ℕ</code>, <code>ℤ</code>, and <code>ℚ</code>, the assumption is satisfied automatically. When reasoning about the real numbers, it can be satisfied using classical logic and abandoning the computational interpretation.</p> <p>We use the command <code>open Finset</code> to avail ourselves of shorter names for the relevant theorems. Unlike the case with sets, most equivalences involving finsets do not hold definitionally, so they need to be expanded manually using equivalences like <code>Finset.subset_iff</code>, <code>Finset.mem_union</code>, <code>Finset.mem_inter</code>, and <code>Finset.mem_sdiff</code>. The <code>ext</code> tactic can still be used to reduce show that two finite sets are equal by showing that every element of one is an element of the other. BOTH: -/ -- QUOTE: open Finset</p> <p>-- EXAMPLES: section variable {α : Type*} [DecidableEq α] (r s t : Finset α)</p> <p>example : r ∩ (s ∪ t) ⊆ r ∩ s ∪ r ∩ t := by rw [subset_iff] intro x rw [mem_inter, mem_union, mem_union, mem_inter, mem_inter] tauto</p> <p>example : r ∩ (s ∪ t) ⊆ r ∩ s ∪ r ∩ t := by simp [subset_iff] intro x tauto</p> <p>example : r ∩ s ∪ r ∩ t ⊆ r ∩ (s ∪ t) := by simp [subset_iff] intro x tauto</p> <p>example : r ∩ s ∪ r ∩ t = r ∩ (s ∪ t) := by ext x simp tauto</p> <p>end -- QUOTE.</p> <p>/- TEXT: We have used a new trick: the <code>tauto</code> tactic (and a strengthened version, <code>tauto!</code>, which uses classical logic) can be used to dispense with propositional tautologies. See if you can use these methods to prove the two examples below. BOTH: -/ section variable {α : Type*} [DecidableEq α] (r s t : Finset α)</p> <p>-- QUOTE: example : (r ∪ s) ∩ (r ∪ t) = r ∪ s ∩ t := by /- EXAMPLES: sorry SOLUTIONS: -/ ext x rw [mem_inter, mem_union, mem_union, mem_union, mem_inter] tauto</p> <p>example : (r ∪ s) ∩ (r ∪ t) = r ∪ s ∩ t := by ext x simp tauto</p> <p>-- BOTH: example : (r s) t = r (s ∪ t) := by /- EXAMPLES: sorry SOLUTIONS: -/ ext x rw [mem_sdiff, mem_sdiff, mem_sdiff, mem_union] tauto</p> <p>example : (r s) t = r (s ∪ t) := by ext x simp tauto -- QUOTE. -- BOTH:</p> <p>end</p> <p>/- TEXT: The theorem <code>Finset.dvd_prod_of_mem</code> tells us that if an <code>n</code> is an element of a finite set <code>s</code>, then <code>n</code> divides <code>∏ i in s, i</code>. EXAMPLES: -/ -- QUOTE: example (s : Finset ℕ) (n : ℕ) (h : n ∈ s) : n ∣ ∏ i in s, i := Finset.dvd_prod_of_mem _ h -- QUOTE.</p> <p>/- TEXT: We also need to know that the converse holds in the case where <code>n</code> is prime and <code>s</code> is a set of primes. To show that, we need the following lemma, which you should be able to prove using the theorem <code>Nat.Prime.eq_one_or_self_of_dvd</code>. BOTH: -/ -- QUOTE: theorem <em>root</em>.Nat.Prime.eq_of_dvd_of_prime {p q : ℕ} (prime_p : Nat.Prime p) (prime_q : Nat.Prime q) (h : p ∣ q) : p = q := by /- EXAMPLES: sorry SOLUTIONS: -/ cases prime_q.eq_one_or_self_of_dvd _ h · linarith [prime_p.two_le] assumption -- QUOTE. -- BOTH:</p> <p>/- TEXT: We can use this lemma to show that if a prime <code>p</code> divides a product of a finite set of primes, then it divides one of them. Mathlib provides a useful principle of induction on finite sets: to show that a property holds of an arbitrary finite set <code>s</code>, show that it holds of the empty set, and show that it is preserved when we add a single new element <code>a ∉ s</code>. The principle is known as <code>Finset.induction_on</code>. When we tell the induction tactic to use it, we can also specify the names <code>a</code> and <code>s</code>, the name for the assumption <code>a ∉ s</code> in the inductive step, and the name of the inductive hypothesis. The expression <code>Finset.insert a s</code> denotes the union of <code>s</code> with the singleton <code>a</code>. The identities <code>Finset.prod_empty</code> and <code>Finset.prod_insert</code> then provide the relevant rewrite rules for the product. In the proof below, the first <code>simp</code> applies <code>Finset.prod_empty</code>. Step through the beginning of the proof to see the induction unfold, and then finish it off. BOTH: -/ -- QUOTE: theorem mem_of_dvd_prod_primes {s : Finset ℕ} {p : ℕ} (prime_p : p.Prime) : (∀ n ∈ s, Nat.Prime n) → (p ∣ ∏ n in s, n) → p ∈ s := by intro h₀ h₁ induction' s using Finset.induction_on with a s ans ih · simp at h₁ linarith [prime_p.two_le] simp [Finset.prod_insert ans, prime_p.dvd_mul] at h₀ h₁ rw [mem_insert] /- EXAMPLES: sorry SOLUTIONS: -/ rcases h₁ with h₁ | h₁ · left exact prime_p.eq_of_dvd_of_prime h₀.1 h₁ right exact ih h₀.2 h₁</p> <p>-- BOTH: -- QUOTE. /- TEXT: We need one last property of finite sets. Given an element <code>s : Set α</code> and a predicate <code>P</code> on <code>α</code>, in :numref:<code>Chapter %s &lt;sets_and_functions&gt;</code> we wrote <code>{ x ∈ s | P x }</code> for the set of elements of <code>s</code> that satisfy <code>P</code>. Given <code>s : Finset α</code>, the analogous notion is written <code>s.filter P</code>. EXAMPLES: -/ -- QUOTE: example (s : Finset ℕ) (x : ℕ) : x ∈ s.filter Nat.Prime ↔ x ∈ s ∧ x.Prime := mem_filter -- QUOTE.</p> <p>/- TEXT: We now prove an alternative formulation of the statement that there are infinitely many primes, namely, that given any <code>s : Finset ℕ</code>, there is a prime <code>p</code> that is not an element of <code>s</code>. Aiming for a contradiction, we assume that all the primes are in <code>s</code>, and then cut down to a set <code>s'</code> that contains all and only the primes. Taking the product of that set, adding one, and finding a prime factor of the result leads to the contradiction we are looking for. See if you can complete the sketch below. You can use <code>Finset.prod_pos</code> in the proof of the first <code>have</code>. BOTH: -/ -- QUOTE: theorem primes_infinite' : ∀ s : Finset Nat, ∃ p, Nat.Prime p ∧ p ∉ s := by intro s by_contra h push_neg at h set s' := s.filter Nat.Prime with s'_def have mem_s' : ∀ {n : ℕ}, n ∈ s' ↔ n.Prime := by intro n simp [s'_def] apply h have : 2 ≤ (∏ i in s', i) + 1 := by /- EXAMPLES: sorry SOLUTIONS: -/ apply Nat.succ_le_succ apply Nat.succ_le_of_lt apply Finset.prod_pos intro n ns' apply (mem_s'.mp ns').pos -- BOTH: rcases exists_prime_factor this with ⟨p, pp, pdvd⟩ have : p ∣ ∏ i in s', i := by /- EXAMPLES: sorry SOLUTIONS: -/ apply dvd_prod_of_mem rw [mem_s'] apply pp -- BOTH: have : p ∣ 1 := by convert Nat.dvd_sub' pdvd this simp show False /- EXAMPLES: sorry SOLUTIONS: -/ have := Nat.le_of_dvd zero_lt_one this linarith [pp.two_le]</p> <p>-- BOTH: -- QUOTE. /- TEXT: We have thus seen two ways of saying that there are infinitely many primes: saying that they are not bounded by any <code>n</code>, and saying that they are not contained in any finite set <code>s</code>. The two proofs below show that these formulations are equivalent. In the second, in order to form <code>s.filter Q</code>, we have to assume that there is a procedure for deciding whether or not <code>Q</code> holds. Lean knows that there is a procedure for <code>Nat.Prime</code>. In general, if we use classical logic by writing <code>open Classical</code>, we can dispense with the assumption.</p> <p>In Mathlib, <code>Finset.sup s f</code> denotes the supremum of the values of <code>f x</code> as <code>x</code> ranges over <code>s</code>, returning <code>0</code> in the case where <code>s</code> is empty and the codomain of <code>f</code> is <code>ℕ</code>. In the first proof, we use <code>s.sup id</code>, where <code>id</code> is the identity function, to refer to the maximum value in <code>s</code>. BOTH: -/ -- QUOTE: theorem bounded_of_ex_finset (Q : ℕ → Prop) : (∃ s : Finset ℕ, ∀ k, Q k → k ∈ s) → ∃ n, ∀ k, Q k → k &lt; n := by rintro ⟨s, hs⟩ use s.sup id + 1 intro k Qk apply Nat.lt_succ_of_le show id k ≤ s.sup id apply le_sup (hs k Qk)</p> <p>theorem ex_finset_of_bounded (Q : ℕ → Prop) [DecidablePred Q] : (∃ n, ∀ k, Q k → k ≤ n) → ∃ s : Finset ℕ, ∀ k, Q k ↔ k ∈ s := by rintro ⟨n, hn⟩ use (range (n + 1)).filter Q intro k simp [Nat.lt_succ_iff] exact hn k -- QUOTE.</p> <p>/- TEXT: A small variation on our second proof that there are infinitely many primes shows that there are infinitely many primes congruent to 3 modulo 4. The argument goes as follows. First, notice that if the product of two numbers :math:<code>m</code> and :math:<code>n</code> is equal to 3 modulo 4, then one of the two numbers is congruent to three modulo 4. After all, both have to be odd, and if they are both congruent to 1 modulo 4, so is their product. We can use this observation to show that if some number greater than 2 is congruent to 3 modulo 4, then that number has a prime divisor that is also congruent to 3 modulo 4.</p> <p>Now suppose there are only finitely many prime numbers congruent to 3 modulo 4, say, :math:<code>p_1, \ldots, p_k</code>. Without loss of generality, we can assume that :math:<code>p_1 = 3</code>. Consider the product :math:<code>4 \prod_{i = 2}^k p_i + 3</code>. It is easy to see that this is congruent to 3 modulo 4, so it has a prime factor :math:<code>p</code> congruent to 3 modulo 4. It can't be the case that :math:<code>p = 3</code>; since :math:<code>p</code> divides :math:<code>4 \prod_{i = 2}^k p_i + 3</code>, if :math:<code>p</code> were equal to 3 then it would also divide :math:<code>\prod_{i = 2}^k p_i</code>, which implies that :math:<code>p</code> is equal to one of the :math:<code>p_i</code> for :math:<code>i = 2, \ldots, k</code>; and we have excluded 3 from this list. So :math:<code>p</code> has to be one of the other elements :math:<code>p_i</code>. But in that case, :math:<code>p</code> divides :math:<code>4 \prod_{i = 2}^k p_i</code> and hence 3, which contradicts the fact that it is not 3.</p> <p>In Lean, the notation <code>n % m</code>, read "<code>n</code> modulo <code>m</code>," denotes the remainder of the division of <code>n</code> by <code>m</code>. EXAMPLES: -/ -- QUOTE: example : 27 % 4 = 3 := by norm_num -- QUOTE.</p> <p>/- TEXT: We can then render the statement "<code>n</code> is congruent to 3 modulo 4" as <code>n % 4 = 3</code>. The following example and theorems sum up the facts about this function that we will need to use below. The first named theorem is another illustration of reasoning by a small number of cases. In the second named theorem, remember that the semicolon means that the subsequent tactic block is applied to all the goals created by the preceding tactic. EXAMPLES: -/ -- QUOTE: example (n : ℕ) : (4 * n + 3) % 4 = 3 := by rw [add_comm, Nat.add_mul_mod_self_left]</p> <p>-- BOTH: theorem mod_4_eq_3_or_mod_4_eq_3 {m n : ℕ} (h : m * n % 4 = 3) : m % 4 = 3 ∨ n % 4 = 3 := by revert h rw [Nat.mul_mod] have : m % 4 &lt; 4 := Nat.mod_lt m (by norm_num) interval_cases m % 4 &lt;;&gt; simp [-Nat.mul_mod_mod] have : n % 4 &lt; 4 := Nat.mod_lt n (by norm_num) interval_cases n % 4 &lt;;&gt; simp</p> <p>theorem two_le_of_mod_4_eq_3 {n : ℕ} (h : n % 4 = 3) : 2 ≤ n := by apply two_le &lt;;&gt; · intro neq rw [neq] at h norm_num at h -- QUOTE.</p> <p>/- TEXT: We will also need the following fact, which says that if <code>m</code> is a nontrivial divisor of <code>n</code>, then so is <code>n / m</code>. See if you can complete the proof using <code>Nat.div_dvd_of_dvd</code> and <code>Nat.div_lt_self</code>. BOTH: -/ -- QUOTE: theorem aux {m n : ℕ} (h₀ : m ∣ n) (h₁ : 2 ≤ m) (h₂ : m &lt; n) : n / m ∣ n ∧ n / m &lt; n := by /- EXAMPLES: sorry SOLUTIONS: -/ constructor · exact Nat.div_dvd_of_dvd h₀ exact Nat.div_lt_self (lt_of_le_of_lt (zero_le _) h₂) h₁ -- QUOTE.</p> <p>-- BOTH: /- TEXT: Now put all the pieces together to prove that any number congruent to 3 modulo 4 has a prime divisor with that same property. BOTH: -/ -- QUOTE: theorem exists_prime_factor_mod_4_eq_3 {n : Nat} (h : n % 4 = 3) : ∃ p : Nat, p.Prime ∧ p ∣ n ∧ p % 4 = 3 := by by_cases np : n.Prime · use n induction' n using Nat.strong_induction_on with n ih rw [Nat.prime_def_lt] at np push_neg at np rcases np (two_le_of_mod_4_eq_3 h) with ⟨m, mltn, mdvdn, mne1⟩ have mge2 : 2 ≤ m := by apply two_le _ mne1 intro mz rw [mz, zero_dvd_iff] at mdvdn linarith have neq : m * (n / m) = n := Nat.mul_div_cancel' mdvdn have : m % 4 = 3 ∨ n / m % 4 = 3 := by apply mod_4_eq_3_or_mod_4_eq_3 rw [neq, h] rcases this with h1 | h1 /- EXAMPLES: . sorry . sorry SOLUTIONS: -/ · by_cases mp : m.Prime · use m rcases ih m mltn h1 mp with ⟨p, pp, pdvd, p4eq⟩ use p exact ⟨pp, pdvd.trans mdvdn, p4eq⟩ obtain ⟨nmdvdn, nmltn⟩ := aux mdvdn mge2 mltn by_cases nmp : (n / m).Prime · use n / m rcases ih (n / m) nmltn h1 nmp with ⟨p, pp, pdvd, p4eq⟩ use p exact ⟨pp, pdvd.trans nmdvdn, p4eq⟩</p> <p>-- BOTH: -- QUOTE. /- TEXT: We are in the home stretch. Given a set <code>s</code> of prime numbers, we need to talk about the result of removing 3 from that set, if it is present. The function <code>Finset.erase</code> handles that. EXAMPLES: -/ -- QUOTE: example (m n : ℕ) (s : Finset ℕ) (h : m ∈ erase s n) : m ≠ n ∧ m ∈ s := by rwa [mem_erase] at h</p> <p>example (m n : ℕ) (s : Finset ℕ) (h : m ∈ erase s n) : m ≠ n ∧ m ∈ s := by simp at h assumption -- QUOTE.</p> <p>/- TEXT: We are now ready to prove that there are infinitely many primes congruent to 3 modulo 4. Fill in the missing parts below. Our solution uses <code>Nat.dvd_add_iff_left</code> and <code>Nat.dvd_sub'</code> along the way. BOTH: -/ -- QUOTE: theorem primes_mod_4_eq_3_infinite : ∀ n, ∃ p &gt; n, Nat.Prime p ∧ p % 4 = 3 := by by_contra h push_neg at h rcases h with ⟨n, hn⟩ have : ∃ s : Finset Nat, ∀ p : ℕ, p.Prime ∧ p % 4 = 3 ↔ p ∈ s := by apply ex_finset_of_bounded use n contrapose! hn rcases hn with ⟨p, ⟨pp, p4⟩, pltn⟩ exact ⟨p, pltn, pp, p4⟩ rcases this with ⟨s, hs⟩ have h₁ : ((4 * ∏ i in erase s 3, i) + 3) % 4 = 3 := by /- EXAMPLES: sorry SOLUTIONS: -/ rw [add_comm, Nat.add_mul_mod_self_left] -- BOTH: rcases exists_prime_factor_mod_4_eq_3 h₁ with ⟨p, pp, pdvd, p4eq⟩ have ps : p ∈ s := by /- EXAMPLES: sorry SOLUTIONS: -/ rw [← hs p] exact ⟨pp, p4eq⟩ -- BOTH: have pne3 : p ≠ 3 := by /- EXAMPLES: sorry SOLUTIONS: -/ intro peq rw [peq, ← Nat.dvd_add_iff_left (dvd_refl 3)] at pdvd rw [Nat.prime_three.dvd_mul] at pdvd norm_num at pdvd have : 3 ∈ s.erase 3 := by apply mem_of_dvd_prod_primes Nat.prime_three _ pdvd intro n simp [← hs n] tauto simp at this -- BOTH: have : p ∣ 4 * ∏ i in erase s 3, i := by /- EXAMPLES: sorry SOLUTIONS: -/ apply dvd_trans _ (dvd_mul_left _ _) apply dvd_prod_of_mem simp constructor &lt;;&gt; assumption -- BOTH: have : p ∣ 3 := by /- EXAMPLES: sorry SOLUTIONS: -/ convert Nat.dvd_sub' pdvd this simp -- BOTH: have : p = 3 := by /- EXAMPLES: sorry SOLUTIONS: -/ apply pp.eq_of_dvd_of_prime Nat.prime_three this -- BOTH: contradiction -- QUOTE.</p> <p>/- TEXT: If you managed to complete the proof, congratulations! This has been a serious feat of formalization. TEXT. -/ -- OMIT: /- Later: o fibonacci numbers o binomial coefficients</p> <p>(The former is a good example of having more than one base case.)</p> <p>TODO: mention <code>local attribute</code> at some point. -/</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.sections", "navigation.instant", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"alias": true, "default": "latest", "provider": "mike"}}</script> <script src=../../../assets/javascripts/bundle.fe8b6f2b.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>