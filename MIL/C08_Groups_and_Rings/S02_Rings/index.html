<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.0, mkdocs-material-9.5.31"><title>S02 Rings - MIL</title><link rel=stylesheet href=../../../assets/stylesheets/main.3cba04c6.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../assets/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent=light-green> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#rings class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <div data-md-color-scheme=default data-md-component=outdated hidden> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=MIL class="md-header__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> MIL </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> S02 Rings </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../en/ class=md-tabs__link> 目录 </a> </li> <li class=md-tabs__item> <a href=../../../en/C01_Introduction/ class=md-tabs__link> Introduction </a> </li> <li class=md-tabs__item> <a href=../../../en/C02_Basics/ class=md-tabs__link> Basics </a> </li> <li class=md-tabs__item> <a href=../../../en/C03_Logic/ class=md-tabs__link> Logic </a> </li> <li class=md-tabs__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-tabs__link> Sets and Functions </a> </li> <li class=md-tabs__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-tabs__link> Elementary Number Theory </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=MIL class="md-nav__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> MIL </label> <div class=md-nav__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../en/ class=md-nav__link> <span class=md-ellipsis> 目录 </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C01_Introduction/ class=md-nav__link> <span class=md-ellipsis> Introduction </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C02_Basics/ class=md-nav__link> <span class=md-ellipsis> Basics </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C03_Logic/ class=md-nav__link> <span class=md-ellipsis> Logic </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-nav__link> <span class=md-ellipsis> Sets and Functions </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-nav__link> <span class=md-ellipsis> Elementary Number Theory </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#rings class=md-nav__link> <span class=md-ellipsis> Rings </span> </a> </li> <li class=md-nav__item> <a href=#check-piringhom class=md-nav__link> <span class=md-ellipsis> check Pi.ringHom </span> </a> </li> <li class=md-nav__item> <a href=#check-ker_pi_quotient_mk class=md-nav__link> <span class=md-ellipsis> check ker_Pi_Quotient_mk </span> </a> </li> <li class=md-nav__item> <a href=#check-injective_lift_iff class=md-nav__link> <span class=md-ellipsis> check injective_lift_iff </span> </a> </li> <li class=md-nav__item> <a href=#check-iscoprime class=md-nav__link> <span class=md-ellipsis> check IsCoprime </span> </a> </li> <li class=md-nav__item> <a href=#check-iscoprime_iff_add class=md-nav__link> <span class=md-ellipsis> check isCoprime_iff_add </span> </a> </li> <li class=md-nav__item> <a href=#check-iscoprime_iff_exists class=md-nav__link> <span class=md-ellipsis> check isCoprime_iff_exists </span> </a> </li> <li class=md-nav__item> <a href=#check-iscoprime_iff_sup_eq class=md-nav__link> <span class=md-ellipsis> check isCoprime_iff_sup_eq </span> </a> </li> <li class=md-nav__item> <a href=#check-iscoprime_iff_codisjoint class=md-nav__link> <span class=md-ellipsis> check isCoprime_iff_codisjoint </span> </a> </li> <li class=md-nav__item> <a href=#check-finsetmem_insert_of_mem class=md-nav__link> <span class=md-ellipsis> check Finset.mem_insert_of_mem </span> </a> </li> <li class=md-nav__item> <a href=#check-finsetmem_insert_self class=md-nav__link> <span class=md-ellipsis> check Finset.mem_insert_self </span> </a> </li> <li class=md-nav__item> <a href=#check-complexofreal-r-c class=md-nav__link> <span class=md-ellipsis> check (Complex.ofReal : ℝ →+* ℂ) </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <p>-- BOTH: import Mathlib.RingTheory.Ideal.QuotientOperations import Mathlib.RingTheory.Localization.Basic import Mathlib.RingTheory.DedekindDomain.Ideal import Mathlib.Analysis.Complex.Polynomial import Mathlib.Data.ZMod.Quotient import MIL.Common</p> <p>noncomputable section</p> <p>/- TEXT: .. _rings:</p> <h2 id=rings>Rings<a class=headerlink href=#rings title="Permanent link">&para;</a></h2> <p>.. index:: ring (algebraic structure)</p> <p>Rings, their units, morphisms and subrings <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup></p> <p>The type of ring structures on a type <code>R</code> is <code>Ring R</code>. The variant where multiplication is assumed to be commutative is <code>CommRing R</code>. We have already seen that the <code>ring</code> tactic will prove any equality that follows from the axioms of a commutative ring. EXAMPLES: -/ -- QUOTE: example {R : Type*} [CommRing R] (x y : R) : (x + y) ^ 2 = x ^ 2 + y ^ 2 + 2 * x * y := by ring -- QUOTE.</p> <p>/- TEXT: More exotic variants do not require that the addition on <code>R</code> forms a group but only an additive monoid. The corresponding type classes are <code>Semiring R</code> and <code>CommSemiring R</code>. The type of natural numbers is an important instance of <code>CommSemiring R</code>, as is any type of functions taking values in the natural numbers. Another important example is the type of ideals in a ring, which will be discussed below. The name of the <code>ring</code> tactic is doubly misleading, since it assumes commutativity but works in semirings as well. In other words, it applies to any <code>CommSemiring</code>. EXAMPLES: -/ -- QUOTE: example (x y : ℕ) : (x + y) ^ 2 = x ^ 2 + y ^ 2 + 2 * x * y := by ring -- QUOTE.</p> <p>/- TEXT: There are also versions of the ring and semiring classes that do not assume the existence of a multiplicative unit or the associativity of multiplication. We will not discuss those here.</p> <p>Some concepts that are traditionally taught in an introduction to ring theory are actually about the underlying multiplicative monoid. A prominent example is the definition of the units of a ring. Every (multiplicative) monoid <code>M</code> has a predicate <code>IsUnit : M → Prop</code> asserting existence of a two-sided inverse, a type <code>Units M</code> of units with notation <code>Mˣ</code>, and a coercion to <code>M</code>. The type <code>Units M</code> bundles an invertible element with its inverse as well as properties than ensure that each is indeed the inverse of the other. This implementation detail is relevant mainly when defining computable functions. In most situations one can use <code>IsUnit.unit {x : M} : IsUnit x → Mˣ</code> to build a unit. In the commutative case, one also has <code>Units.mkOfMulEqOne (x y : M) : x * y = 1 → Mˣ</code> which builds <code>x</code> seen as unit. EXAMPLES: -/ -- QUOTE: example (x : ℤˣ) : x = 1 ∨ x = -1 := Int.units_eq_one_or x</p> <p>example {M : Type*} [Monoid M] (x : Mˣ) : (x : M) * x⁻¹ = 1 := Units.mul_inv x</p> <p>example {M : Type*} [Monoid M] : Group Mˣ := inferInstance -- QUOTE.</p> <p>/- TEXT: The type of ring morphisms between two (semi)-rings <code>R</code> and <code>S</code> is <code>RingHom R S</code>, with notation <code>R →+* S</code>. EXAMPLES: -/ -- QUOTE: example {R S : Type*} [Ring R] [Ring S] (f : R →+* S) (x y : R) : f (x + y) = f x + f y := f.map_add x y</p> <p>example {R S : Type*} [Ring R] [Ring S] (f : R →+* S) : Rˣ →* Sˣ := Units.map f -- QUOTE.</p> <p>/- TEXT: The isomorphism variant is <code>RingEquiv</code>, with notation <code>≃+*</code>.</p> <p>As with submonoids and subgroups, there is a <code>Subring R</code> type for subrings of a ring <code>R</code>, but this type is a lot less useful than the type of subgroups since one cannot quotient a ring by a subring. EXAMPLES: -/ -- QUOTE: example {R : Type*} [Ring R] (S : Subring R) : Ring S := inferInstance -- QUOTE.</p> <p>/- TEXT: Also notice that <code>RingHom.range</code> produces a subring.</p> <p>Ideals and quotients <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup>^^</p> <p>For historical reasons, Mathlib only has a theory of ideals for commutative rings. (The ring library was originally developed to make quick progress toward the foundations of modern algebraic geometry.) So in this section we will work with commutative (semi)rings. Ideals of <code>R</code> are defined as submodules of <code>R</code> seen as <code>R</code>-modules. Modules will be covered later in a chapter on linear algebra, but this implementation detail can mostly be safely ignored since most (but not all) relevant lemmas are restated in the special context of ideals. But anonymous projection notation won't always work as expected. For instance, one cannot replace <code>Ideal.Quotient.mk I</code> by <code>I.Quotient.mk</code> in the snippet below because there are two <code>.</code>s and so it will parse as <code>(Ideal.Quotient I).mk</code>; but <code>Ideal.Quotient</code> by itself doesn't exist. EXAMPLES: -/ -- QUOTE: example {R : Type*} [CommRing R] (I : Ideal R) : R →+* R ⧸ I := Ideal.Quotient.mk I</p> <p>example {R : Type*} [CommRing R] {a : R} {I : Ideal R} : Ideal.Quotient.mk I a = 0 ↔ a ∈ I := Ideal.Quotient.eq_zero_iff_mem -- QUOTE.</p> <p>/- TEXT: The universal property of quotient rings is <code>Ideal.Quotient.lift</code>. EXAMPLES: -/ -- QUOTE: example {R S : Type*} [CommRing R] [CommRing S] (I : Ideal R) (f : R →+* S) (H : I ≤ RingHom.ker f) : R ⧸ I →+* S := Ideal.Quotient.lift I f H -- QUOTE.</p> <p>/- TEXT: In particular it leads to the first isomorphism theorem for rings. EXAMPLES: -/ -- QUOTE: example {R S : Type*} [CommRing R] <a href="f : R →+* S">CommRing S</a> : R ⧸ RingHom.ker f ≃+* f.range := RingHom.quotientKerEquivRange f -- QUOTE.</p> <p>/- TEXT: Ideals form a complete lattice structure with the inclusion relation, as well as a semiring structure. These two structures interact nicely. EXAMPLES: -/ section -- QUOTE: variable {R : Type*} [CommRing R] {I J : Ideal R}</p> <p>-- EXAMPLES: example : I + J = I ⊔ J := rfl</p> <p>example {x : R} : x ∈ I + J ↔ ∃ a ∈ I, ∃ b ∈ J, a + b = x := by simp [Submodule.mem_sup]</p> <p>example : I * J ≤ J := Ideal.mul_le_left</p> <p>example : I * J ≤ I := Ideal.mul_le_right</p> <p>example : I * J ≤ I ⊓ J := Ideal.mul_le_inf -- QUOTE.</p> <p>end</p> <p>/- TEXT: One can use ring morphisms to push ideals forward and pull them back using <code>Ideal.map</code> and <code>Ideal.comap</code>, respectively. As usual, the latter is more convenient to use since it does not involve an existential quantifier. This explains why it is used to state the condition that allows us to build morphisms between quotient rings. EXAMPLES: -/ -- QUOTE: example {R S : Type*} [CommRing R] [CommRing S] (I : Ideal R) (J : Ideal S) (f : R →+* S) (H : I ≤ Ideal.comap f J) : R ⧸ I →+* S ⧸ J := Ideal.quotientMap J f H -- QUOTE.</p> <p>/- TEXT: One subtle point is that the type <code>R ⧸ I</code> really depends on <code>I</code> (up to definitional equality), so having a proof that two ideals <code>I</code> and <code>J</code> are equal is not enough to make the corresponding quotients equal. However, the universal properties do provide an isomorphism in this case. EXAMPLES: -/ -- QUOTE: example {R : Type*} [CommRing R] {I J : Ideal R} (h : I = J) : R ⧸ I ≃+* R ⧸ J := Ideal.quotEquivOfEq h -- QUOTE.</p> <p>/- TEXT: We can now present the Chinese remainder isomorphism as an example. Pay attention to the difference between the indexed infimum symbol <code>⨅</code> and the big product of types symbol <code>Π</code>. Depending on your font, those can be pretty hard to distinguish. EXAMPLES: -/ -- QUOTE: example {R : Type*} [CommRing R] {ι : Type*} [Fintype ι] (f : ι → Ideal R) (hf : ∀ i j, i ≠ j → IsCoprime (f i) (f j)) : (R ⧸ ⨅ i, f i) ≃+* Π i, R ⧸ f i := Ideal.quotientInfRingEquivPiQuotient f hf -- QUOTE.</p> <p>/- TEXT: The elementary version of the Chinese remainder theorem, a statement about <code>ZMod</code>, can be easily deduced from the previous one: BOTH: -/ -- QUOTE: open BigOperators PiNotation</p> <p>-- EXAMPLES: example {ι : Type*} [Fintype ι] (a : ι → ℕ) (coprime : ∀ i j, i ≠ j → (a i).Coprime (a j)) : ZMod (∏ i, a i) ≃+* Π i, ZMod (a i) := ZMod.prodEquivPi a coprime -- QUOTE.</p> <p>/- TEXT: As a series of exercises, we will reprove the Chinese remainder theorem in the general case.</p> <p>We first need to define the map appearing in the theorem, as a ring morphism, using the universal property of quotient rings. BOTH: -/ section -- QUOTE: variable {ι R : Type*} [CommRing R] open Ideal Quotient Function</p> <h1 id=check-piringhom>check Pi.ringHom<a class=headerlink href=#check-piringhom title="Permanent link">&para;</a></h1> <h1 id=check-ker_pi_quotient_mk>check ker_Pi_Quotient_mk<a class=headerlink href=#check-ker_pi_quotient_mk title="Permanent link">&para;</a></h1> <p>/-- The homomorphism from <code>R ⧸ ⨅ i, I i</code> to <code>Π i, R ⧸ I i</code> featured in the Chinese Remainder Theorem. -/ def chineseMap (I : ι → Ideal R) : (R ⧸ ⨅ i, I i) →+* Π i, R ⧸ I i := /- EXAMPLES: sorry SOLUTIONS: -/ Ideal.Quotient.lift (⨅ i, I i) (Pi.ringHom fun i : ι ↦ Ideal.Quotient.mk (I i)) (by simp [← RingHom.mem_ker, ker_Pi_Quotient_mk]) -- QUOTE. -- BOTH:</p> <p>/- TEXT: Make sure the following next two lemmas can be proven by <code>rfl</code>. BOTH: -/ -- QUOTE: lemma chineseMap_mk (I : ι → Ideal R) (x : R) : chineseMap I (Quotient.mk _ x) = fun i : ι ↦ Ideal.Quotient.mk (I i) x := /- EXAMPLES: sorry SOLUTIONS: -/ rfl -- BOTH:</p> <p>lemma chineseMap_mk' (I : ι → Ideal R) (x : R) (i : ι) : chineseMap I (mk _ x) i = mk (I i) x := /- EXAMPLES: sorry SOLUTIONS: -/ rfl -- QUOTE. -- BOTH:</p> <p>/- TEXT: The next lemma proves the easy half of the Chinese remainder theorem, without any assumption on the family of ideals. The proof is less than one line long. EXAMPLES: -/ -- QUOTE:</p> <h1 id=check-injective_lift_iff>check injective_lift_iff<a class=headerlink href=#check-injective_lift_iff title="Permanent link">&para;</a></h1> <p>-- BOTH: lemma chineseMap_inj (I : ι → Ideal R) : Injective (chineseMap I) := by /- EXAMPLES: sorry SOLUTIONS: -/ rw [chineseMap, injective_lift_iff, ker_Pi_Quotient_mk] -- QUOTE. -- BOTH:</p> <p>/- TEXT: We are now ready for the heart of the theorem, which will show the surjectivity of our <code>chineseMap</code>. First we need to know the different ways one can express the coprimality (also called co-maximality assumption). Only the first two will be needed below. EXAMPLES: -/ -- QUOTE:</p> <h1 id=check-iscoprime>check IsCoprime<a class=headerlink href=#check-iscoprime title="Permanent link">&para;</a></h1> <h1 id=check-iscoprime_iff_add>check isCoprime_iff_add<a class=headerlink href=#check-iscoprime_iff_add title="Permanent link">&para;</a></h1> <h1 id=check-iscoprime_iff_exists>check isCoprime_iff_exists<a class=headerlink href=#check-iscoprime_iff_exists title="Permanent link">&para;</a></h1> <h1 id=check-iscoprime_iff_sup_eq>check isCoprime_iff_sup_eq<a class=headerlink href=#check-iscoprime_iff_sup_eq title="Permanent link">&para;</a></h1> <h1 id=check-iscoprime_iff_codisjoint>check isCoprime_iff_codisjoint<a class=headerlink href=#check-iscoprime_iff_codisjoint title="Permanent link">&para;</a></h1> <p>-- QUOTE.</p> <p>/- TEXT: We take the opportunity to use induction on <code>Finset</code>. Relevant lemmas on <code>Finset</code> are given below. Remember that the <code>ring</code> tactic works for semirings and that the ideals of a ring form a semiring. EXAMPLES: -/ -- QUOTE:</p> <h1 id=check-finsetmem_insert_of_mem>check Finset.mem_insert_of_mem<a class=headerlink href=#check-finsetmem_insert_of_mem title="Permanent link">&para;</a></h1> <h1 id=check-finsetmem_insert_self>check Finset.mem_insert_self<a class=headerlink href=#check-finsetmem_insert_self title="Permanent link">&para;</a></h1> <p>-- BOTH: theorem isCoprime_Inf {I : Ideal R} {J : ι → Ideal R} {s : Finset ι} (hf : ∀ j ∈ s, IsCoprime I (J j)) : IsCoprime I (⨅ j ∈ s, J j) := by classical simp_rw [isCoprime_iff_add] at * induction s using Finset.induction with | empty =&gt; simp | @insert i s _ hs =&gt; rw [Finset.iInf_insert, inf_comm, one_eq_top, eq_top_iff, ← one_eq_top] set K := ⨅ j ∈ s, J j calc /- EXAMPLES: 1 = I + K := sorry _ = I + K * (I + J i) := sorry _ = (1 + K) * I + K * J i := sorry _ ≤ I + K ⊓ J i := sorry SOLUTIONS: -/ 1 = I + K := (hs fun j hj ↦ hf j (Finset.mem_insert_of_mem hj)).symm _ = I + K * (I + J i) := by rw [hf i (Finset.mem_insert_self i s), mul_one] _ = (1 + K) * I + K * J i := by ring _ ≤ I + K ⊓ J i := by gcongr ; apply mul_le_left ; apply mul_le_inf</p> <p>-- QUOTE.</p> <p>/- TEXT: We can now prove surjectivity of the map appearing in the Chinese remainder theorem. BOTH: -/ -- QUOTE: lemma chineseMap_surj [Fintype ι] {I : ι → Ideal R} (hI : ∀ i j, i ≠ j → IsCoprime (I i) (I j)) : Surjective (chineseMap I) := by classical intro g choose f hf using fun i ↦ Ideal.Quotient.mk_surjective (g i) have key : ∀ i, ∃ e : R, mk (I i) e = 1 ∧ ∀ j, j ≠ i → mk (I j) e = 0 := by intro i have hI' : ∀ j ∈ ({i} : Finset ι)ᶜ, IsCoprime (I i) (I j) := by /- EXAMPLES: sorry SOLUTIONS: -/ intros j hj exact hI _ _ (by simpa [ne_comm, isCoprime_iff_add] using hj) /- EXAMPLES: sorry SOLUTIONS: -/ rcases isCoprime_iff_exists.mp (isCoprime_Inf hI') with ⟨u, hu, e, he, hue⟩ replace he : ∀ j, j ≠ i → e ∈ I j := by simpa using he refine ⟨e, ?<em>, ?</em>⟩ · simp [eq_sub_of_add_eq' hue, map_sub, eq_zero_iff_mem.mpr hu] · exact fun j hj ↦ eq_zero_iff_mem.mpr (he j hj) -- BOTH: choose e he using key use mk _ (∑ i, f i * e i) /- EXAMPLES: sorry SOLUTIONS: -/ ext i rw [chineseMap_mk', map_sum, Fintype.sum_eq_single i] · simp [(he i).1, hf] · intros j hj simp [(he j).2 i hj.symm] -- QUOTE. -- BOTH:</p> <p>/- TEXT: Now all the pieces come together in the following: BOTH: -/ -- QUOTE: noncomputable def chineseIso [Fintype ι] (f : ι → Ideal R) (hf : ∀ i j, i ≠ j → IsCoprime (f i) (f j)) : (R ⧸ ⨅ i, f i) ≃+* Π i, R ⧸ f i := { Equiv.ofBijective _ ⟨chineseMap_inj f, chineseMap_surj hf⟩, chineseMap f with } -- QUOTE.</p> <p>end</p> <p>/- TEXT: Algebras and polynomials <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup></p> <p>Given a commutative (semi)ring <code>R</code>, an <em>algebra over</em> <code>R</code> is a semiring <code>A</code> equipped with a ring morphism whose image commutes with every element of <code>A</code>. This is encoded as a type class <code>Algebra R A</code>. The morphism from <code>R</code> to <code>A</code> is called the structure map and is denoted <code>algebraMap R A : R →+* A</code> in Lean. Multiplication of <code>a : A</code> by <code>algebraMap R A r</code> for some <code>r : R</code> is called the scalar multiplication of <code>a</code> by <code>r</code> and denoted by <code>r • a</code>. Note that this notion of algebra is sometimes called an <em>associative unital algebra</em> to emphasize the existence of more general notions of algebra.</p> <p>The fact that <code>algebraMap R A</code> is ring morphism packages together a lot of properties of scalar multiplication, such as the following: EXAMPLES: -/ -- QUOTE: example {R A : Type*} [CommRing R] [Ring A] [Algebra R A] (r r' : R) (a : A) : (r + r') • a = r • a + r' • a := add_smul r r' a</p> <p>example {R A : Type*} [CommRing R] [Ring A] [Algebra R A] (r r' : R) (a : A) : (r * r') • a = r • r' • a := mul_smul r r' a -- QUOTE.</p> <p>/- TEXT: The morphisms between two <code>R</code>-algebras <code>A</code> and <code>B</code> are ring morphisms which commute with scalar multiplication by elements of <code>R</code>. They are bundled morphisms with type <code>AlgHom R A B</code>, which is denoted by <code>A →ₐ[R] B</code>.</p> <p>Important examples of non-commutative algebras include algebras of endomorphisms and algebras of square matrices, both of which will be covered in the chapter on linear algebra. In this chapter we will discuss one of the most important examples of a commutative algebra, namely, polynomial algebras.</p> <p>The algebra of univariate polynomials with coefficients in <code>R</code> is called <code>Polynomial R</code>, which can be written as <code>R[X]</code> as soon as one opens the <code>Polynomial</code> namespace. The algebra structure map from <code>R</code> to <code>R[X]</code> is denoted by <code>C</code>, which stands for "constant" since the corresponding polynomial functions are always constant. The indeterminate is denoted by <code>X</code>. EXAMPLES: -/ section Polynomials -- QUOTE: open Polynomial</p> <p>example {R : Type*} [CommRing R] : R[X] := X</p> <p>example {R : Type*} [CommRing R] (r : R) := X - C r -- QUOTE.</p> <p>/- TEXT: In the first example above, it is crucial that we give Lean the expected type since it cannot be determined from the body of the definition. In the second example, the target polynomial algebra can be inferred from our use of <code>C r</code> since the type of <code>r</code> is known.</p> <p>Because <code>C</code> is a ring morphism from <code>R</code> to <code>R[X]</code>, we can use all ring morphisms lemmas such as <code>map_zero</code>, <code>map_one</code>, <code>map_mul</code>, and <code>map_pow</code> before computing in the ring <code>R[X]</code>. For example: EXAMPLES: -/ -- QUOTE: example {R : Type*} [CommRing R] (r : R) : (X + C r) * (X - C r) = X ^ 2 - C (r ^ 2) := by rw [C.map_pow] ring -- QUOTE.</p> <p>/- TEXT: You can access coefficients using <code>Polynomial.coeff</code> EXAMPLES: -/ -- QUOTE: example {R : Type*} [CommRing R] (r:R) : (C r).coeff 0 = r := by simp</p> <p>example {R : Type*} [CommRing R] : (X ^ 2 + 2 * X + C 3 : R[X]).coeff 1 = 2 := by simp -- QUOTE.</p> <p>/- TEXT: Defining the degree of a polynomial is always tricky because of the special case of the zero polynomial. Mathlib has two variants: <code>Polynomial.natDegree : R[X] → ℕ</code> assigns degree <code>0</code> to the zero polynomial, and <code>Polynomial.degree : R[X] → WithBot ℕ</code> assigns <code>⊥</code>. In the latter, <code>WithBot ℕ</code> can be seen as <code>ℕ ∪ {-∞}</code>, except that <code>-∞</code> is denoted <code>⊥</code>, the same symbol as the bottom element in a complete lattice. This special value is used as the degree of the zero polynomial, and it is absorbent for addition. (It is almost absorbent for multiplication, except that <code>⊥ * 0 = 0</code>.)</p> <p>Morally speaking, the <code>degree</code> version is the correct one. For instance, it allows us to state the expected formula for the degree of a product (assuming the base ring has no zero divisor). EXAMPLES: -/ -- QUOTE: example {R : Type*} [Semiring R] [NoZeroDivisors R] {p q : R[X]} : degree (p * q) = degree p + degree q := Polynomial.degree_mul -- QUOTE.</p> <p>/- TEXT: Whereas the version for <code>natDegree</code> needs to assume non-zero polynomials. EXAMPLES: -/ -- QUOTE: example {R : Type*} [Semiring R] [NoZeroDivisors R] {p q : R[X]} (hp : p ≠ 0) (hq : q ≠ 0) : natDegree (p * q) = natDegree p + natDegree q := Polynomial.natDegree_mul hp hq -- QUOTE.</p> <p>/- TEXT: However, <code>ℕ</code> is much nicer to use than <code>WithBot ℕ</code>, so Mathlib makes both versions available and provides lemmas to convert between them. Also, <code>natDegree</code> is the more convenient definition to use when computing the degree of a composition. Composition of polynomial is <code>Polynomial.comp</code> and we have: EXAMPLES: -/ -- QUOTE: example {R : Type*} [Semiring R] [NoZeroDivisors R] {p q : R[X]} : natDegree (comp p q) = natDegree p * natDegree q := Polynomial.natDegree_comp -- QUOTE.</p> <p>/- TEXT: Polynomials give rise to polynomial functions: any polynomial can be evaluated on <code>R</code> using <code>Polynomial.eval</code>. EXAMPLES: -/ -- QUOTE: example {R : Type*} [CommRing R] (P: R[X]) (x : R) := P.eval x</p> <p>example {R : Type*} [CommRing R] (r : R) : (X - C r).eval r = 0 := by simp -- QUOTE.</p> <p>/- TEXT: In particular, there is a predicate, <code>IsRoot</code>, that holds for elements <code>r</code> in <code>R</code> where a polynomial vanishes. EXAMPLES: -/ -- QUOTE: example {R : Type*} [CommRing R] (P : R[X]) (r : R) : IsRoot P r ↔ P.eval r = 0 := Iff.rfl -- QUOTE.</p> <p>/- TEXT: We would like to say that, assuming <code>R</code> has no zero divisor, a polynomial has at most as many roots as its degree, where the roots are counted with multiplicities. But once again the case of the zero polynomial is painful. So Mathlib defines <code>Polynomial.roots</code> to send a polynomial <code>P</code> to a multiset, i.e. the finite set that is defined to be empty if <code>P</code> is zero and the roots of <code>P</code>, with multiplicities, otherwise. This is defined only when the underlying ring is a domain since otherwise the definition does not have good properties. EXAMPLES: -/ -- QUOTE: example {R : Type*} [CommRing R] [IsDomain R] (r : R) : (X - C r).roots = {r} := roots_X_sub_C r</p> <p>example {R : Type*} [CommRing R] [IsDomain R] (r : R) (n : ℕ): ((X - C r) ^ n).roots = n • {r} := by simp -- QUOTE.</p> <p>/- TEXT: Both <code>Polynomial.eval</code> and <code>Polynomial.roots</code> consider only the coefficients ring. They do not allow us to say that <code>X ^ 2 - 2 : ℚ[X]</code> has a root in <code>ℝ</code> or that <code>X ^ 2 + 1 : ℝ[X]</code> has a root in <code>ℂ</code>. For this, we need <code>Polynomial.aeval</code>, which will evaluate <code>P : R[X]</code> in any <code>R</code>-algebra. More precisely, given a semiring <code>A</code> and an instance of <code>Algebra R A</code>, <code>Polynomial.aeval</code> sends every element of <code>a</code> along the <code>R</code>-algebra morphism of evaluation at <code>a</code>. Since <code>AlgHom</code> has a coercion to functions, one can apply it to a polynomial. But <code>aeval</code> does not have a polynomial as an argument, so one cannot use dot notation like in <code>P.eval</code> above. EXAMPLES: -/ -- QUOTE: example : aeval Complex.I (X ^ 2 + 1 : ℝ[X]) = 0 := by simp</p> <p>-- QUOTE. /- TEXT: The function corresponding to <code>roots</code> in this context is <code>aroots</code> which takes a polynomial and then an algebra and outputs a multiset (with the same caveat about the zero polynomial as for <code>roots</code>). EXAMPLES: -/ -- QUOTE: open Complex Polynomial</p> <p>example : aroots (X ^ 2 + 1 : ℝ[X]) ℂ = {Complex.I, -I} := by suffices roots (X ^ 2 + 1 : ℂ[X]) = {I, -I} by simpa [aroots_def] have factored : (X ^ 2 + 1 : ℂ[X]) = (X - C I) * (X - C (-I)) := by rw [C_neg] linear_combination show (C I * C I : ℂ[X]) = -1 by simp [← C_mul] have p_ne_zero : (X - C I) * (X - C (-I)) ≠ 0 := by intro H apply_fun eval 0 at H simp [eval] at H simp only [factored, roots_mul p_ne_zero, roots_X_sub_C] rfl</p> <p>-- Mathlib knows about D'Alembert-Gauss theorem: <code>ℂ</code> is algebraically closed. example : IsAlgClosed ℂ := inferInstance</p> <p>-- QUOTE. /- TEXT: More generally, given an ring morphism <code>f : R →+* S</code> one can evaluate <code>P : R[X]</code> at a point in <code>S</code> using <code>Polynomial.eval₂</code>. This one produces an actual function from <code>R[X]</code> to <code>S</code> since it does not assume the existence of a <code>Algebra R S</code> instance, so dot notation works as you would expect. EXAMPLES: -/ -- QUOTE:</p> <h1 id=check-complexofreal-r-c>check (Complex.ofReal : ℝ →+* ℂ)<a class=headerlink href=#check-complexofreal-r-c title="Permanent link">&para;</a></h1> <p>example : (X ^ 2 + 1 : ℝ[X]).eval₂ Complex.ofReal Complex.I = 0 := by simp -- QUOTE.</p> <p>/- TEXT: Let us end by mentioning multivariate polynomials briefly. Given a commutative semiring <code>R</code>, the <code>R</code>-algebra of polynomials with coefficients in <code>R</code> and indeterminates indexed by a type <code>σ</code> is <code>MVPolynomial σ R</code>. Given <code>i : σ</code>, the corresponding polynomial is <code>MvPolynomial.X i</code>. (As usual, one can open the <code>MVPolynomial</code> namespace to shorten this to <code>X i</code>.) For instance, if we want two indeterminates we can use <code>Fin 2</code> as <code>σ</code> and write the polynomial defining the unit circle in :math:`\mathbb{R}^2`` as: EXAMPLES: -/ -- QUOTE: open MvPolynomial</p> <p>def circleEquation : MvPolynomial (Fin 2) ℝ := X 0 ^ 2 + X 1 ^ 2 - 1 -- QUOTE.</p> <p>/- TEXT: Recall that function application has a very high precedence so the expression above is read as <code>(X 0) ^ 2 + (X 1) ^ 2 - 1</code>. We can evaluate it to make sure the point with coordinates :math:<code>(1, 0)</code> is on the circle. Recall the <code>![...]</code> notation denotes elements of <code>Fin n → X</code> for some natural number <code>n</code> determined by the number of arguments and some type <code>X</code> determined by the type of arguments. EXAMPLES: -/ -- QUOTE: example : MvPolynomial.eval ![0, 1] circleEquation = 0 := by simp [circleEquation] -- QUOTE.</p> <p>end Polynomials</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.sections", "navigation.instant", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"alias": true, "default": "latest", "provider": "mike"}}</script> <script src=../../../assets/javascripts/bundle.fe8b6f2b.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>