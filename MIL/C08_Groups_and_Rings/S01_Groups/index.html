<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.0, mkdocs-material-9.5.31"><title>S01 Groups - MIL</title><link rel=stylesheet href=../../../assets/stylesheets/main.3cba04c6.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../assets/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent=light-green> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#monoids-and-groups class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <div data-md-color-scheme=default data-md-component=outdated hidden> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=MIL class="md-header__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> MIL </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> S01 Groups </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../en/ class=md-tabs__link> 目录 </a> </li> <li class=md-tabs__item> <a href=../../../en/C01_Introduction/ class=md-tabs__link> Introduction </a> </li> <li class=md-tabs__item> <a href=../../../en/C02_Basics/ class=md-tabs__link> Basics </a> </li> <li class=md-tabs__item> <a href=../../../en/C03_Logic/ class=md-tabs__link> Logic </a> </li> <li class=md-tabs__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-tabs__link> Sets and Functions </a> </li> <li class=md-tabs__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-tabs__link> Elementary Number Theory </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=MIL class="md-nav__button md-logo" aria-label=MIL data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> MIL </label> <div class=md-nav__source> <a href=https://github.com/hmyuuu/MIL-zh-demo title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> MIL-zh-demo </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../en/ class=md-nav__link> <span class=md-ellipsis> 目录 </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C01_Introduction/ class=md-nav__link> <span class=md-ellipsis> Introduction </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C02_Basics/ class=md-nav__link> <span class=md-ellipsis> Basics </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C03_Logic/ class=md-nav__link> <span class=md-ellipsis> Logic </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C04_Sets_and_Functions/ class=md-nav__link> <span class=md-ellipsis> Sets and Functions </span> </a> </li> <li class=md-nav__item> <a href=../../../en/C05_Elementary_Number_Theory/ class=md-nav__link> <span class=md-ellipsis> Elementary Number Theory </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#monoids-and-groups class=md-nav__link> <span class=md-ellipsis> Monoids and Groups </span> </a> </li> <li class=md-nav__item> <a href=#check-subgroupmem_map class=md-nav__link> <span class=md-ellipsis> check Subgroup.mem_map </span> </a> </li> <li class=md-nav__item> <a href=#check-subgroupmem_comap class=md-nav__link> <span class=md-ellipsis> check Subgroup.mem_comap </span> </a> </li> <li class=md-nav__item> <a href=#check-card_dvd_of_le class=md-nav__link> <span class=md-ellipsis> check card_dvd_of_le </span> </a> </li> <li class=md-nav__item> <a href=#simp-mul_assoc-c1-2-3-c2-3-4 class=md-nav__link> <span class=md-ellipsis> simp [mul_assoc] c[1, 2, 3] * c[2, 3, 4] </span> </a> </li> <li class=md-nav__item> <a href=#check-natcard_pos-the-nonempty-argument-will-be-automatically-inferred-for-subgroups class=md-nav__link> <span class=md-ellipsis> check Nat.card_pos -- The nonempty argument will be automatically inferred for subgroups </span> </a> </li> <li class=md-nav__item> <a href=#check-subgroupindex_eq_card class=md-nav__link> <span class=md-ellipsis> check Subgroup.index_eq_card </span> </a> </li> <li class=md-nav__item> <a href=#check-subgroupindex_mul_card class=md-nav__link> <span class=md-ellipsis> check Subgroup.index_mul_card </span> </a> </li> <li class=md-nav__item> <a href=#check-nateq_of_mul_eq_mul_right class=md-nav__link> <span class=md-ellipsis> check Nat.eq_of_mul_eq_mul_right </span> </a> </li> <li class=md-nav__item> <a href=#check-natbijective_iff_injective_and_card class=md-nav__link> <span class=md-ellipsis> check Nat.bijective_iff_injective_and_card </span> </a> </li> <li class=md-nav__item> <a href=#check-ker_eq_bot_iff class=md-nav__link> <span class=md-ellipsis> check ker_eq_bot_iff </span> </a> </li> <li class=md-nav__item> <a href=#check-restrict class=md-nav__link> <span class=md-ellipsis> check restrict </span> </a> </li> <li class=md-nav__item> <a href=#check-ker_restrict class=md-nav__link> <span class=md-ellipsis> check ker_restrict </span> </a> </li> <li class=md-nav__item> <a href=#check-mulequivprodcongr class=md-nav__link> <span class=md-ellipsis> check MulEquiv.prodCongr </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <p>-- BOTH: import Mathlib.GroupTheory.Sylow import Mathlib.GroupTheory.Perm.Cycle.Concrete import Mathlib.GroupTheory.Perm.Subgroup import Mathlib.GroupTheory.PresentedGroup</p> <p>import MIL.Common</p> <p>/- TEXT: .. _groups:</p> <h2 id=monoids-and-groups>Monoids and Groups<a class=headerlink href=#monoids-and-groups title="Permanent link">&para;</a></h2> <p>.. index:: monoid .. index:: group (algebraic structure)</p> <p>Monoids and their morphisms <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup></p> <p>Courses in abstract algebra often start with groups and then progress to rings, fields, and vector spaces. This involves some contortions when discussing multiplication on rings since the multiplication operation does not come from a group structure but many of the proofs carry over verbatim from group theory to this new setting. The most common fix, when doing mathematics with pen and paper, is to leave those proofs as exercises. A less efficient but safer and more formalization-friendly way of proceeding is to use monoids. A <em>monoid</em> structure on a type <code>M</code> is an internal composition law that is associative and has a neutral element. Monoids are used primarily to accommodate both groups and the multiplicative structure of rings. But there are also a number of natural examples; for instance, the set of natural numbers equipped with addition forms a monoid.</p> <p>From a practical point of view, you can mostly ignore monoids when using Mathlib. But you need to know they exist when you are looking for a lemma by browsing Mathlib files. Otherwise, you might end up looking for a statement in the group theory files when it is actually in the found with monoids because it does not require elements to be invertible.</p> <p>The type of monoid structures on a type <code>M</code> is written <code>Monoid M</code>. The function <code>Monoid</code> is a type class so it will almost always appear as an instance implicit argument (in other words, in square brackets). By default, <code>Monoid</code> uses multiplicative notation for the operation; for additive notation use <code>AddMonoid</code> instead. The commutative versions of these structures add the prefix <code>Comm</code> before <code>Monoid</code>. EXAMPLES: -/ -- QUOTE: example {M : Type*} [Monoid M] (x : M) : x * 1 = x := mul_one x</p> <p>example {M : Type*} [AddCommMonoid M] (x y : M) : x + y = y + x := add_comm x y -- QUOTE.</p> <p>/- TEXT: Note that although <code>AddMonoid</code> is found in the library, it is generally confusing to use additive notation with a non-commutative operation.</p> <p>The type of morphisms between monoids <code>M</code> and <code>N</code> is called <code>MonoidHom M N</code> and written <code>M →* N</code>. Lean will automatically see such a morphism as a function from <code>M</code> to <code>N</code> when we apply it to elements of <code>M</code>. The additive version is called <code>AddMonoidHom</code> and written <code>M →+ N</code>. EXAMPLES: -/ -- QUOTE: example {M N : Type*} [Monoid M] [Monoid N] (x y : M) (f : M →* N) : f (x * y) = f x * f y := f.map_mul x y</p> <p>example {M N : Type*} [AddMonoid M] [AddMonoid N] (f : M →+ N) : f 0 = 0 := f.map_zero -- QUOTE.</p> <p>/- TEXT: These morphisms are bundled maps, i.e. they package together a map and some of its properties. Remember that :numref:<code>section_hierarchies_morphisms</code> explains bundled maps; here we simply note the slightly unfortunate consequence that we cannot use ordinary function composition to compose maps. Instead, we need to use <code>MonoidHom.comp</code> and <code>AddMonoidHom.comp</code>. EXAMPLES: -/ -- QUOTE: example {M N P : Type*} [AddMonoid M] [AddMonoid N] [AddMonoid P] (f : M →+ N) (g : N →+ P) : M →+ P := g.comp f -- QUOTE.</p> <p>/- TEXT: Groups and their morphisms <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup>^^</p> <p>We will have much more to say about groups, which are monoids with the extra property that every element has an inverse. EXAMPLES: -/ -- QUOTE: example {G : Type*} [Group G] (x : G) : x * x⁻¹ = 1 := mul_inv_self x -- QUOTE.</p> <p>/- TEXT:</p> <p>.. index:: group (tactic), tactics ; group</p> <p>Similar to the <code>ring</code> tactic that we saw earlier, there is a <code>group</code> tactic that proves any identity that holds in any group. (Equivalently, it proves the identities that hold in free groups.)</p> <p>EXAMPLES: -/ -- QUOTE: example {G : Type*} [Group G] (x y z : G) : x * (y * z) * (x * z)⁻¹ * (x * y * x⁻¹)⁻¹ = 1 := by group -- QUOTE.</p> <p>/- TEXT: .. index:: abel, tactics ; abel</p> <p>There is also a tactic for identities in commutative additive groups called <code>abel</code>.</p> <p>EXAMPLES: -/ -- QUOTE: example {G : Type*} [AddCommGroup G] (x y z : G) : z + x + (y - z - x) = y := by abel -- QUOTE.</p> <p>/- TEXT: Interestingly, a group morphism is nothing more than a monoid morphism between groups. So we can copy and paste one of our earlier examples, replacing <code>Monoid</code> with <code>Group</code>. EXAMPLES: -/ -- QUOTE: example {G H : Type*} [Group G] [Group H] (x y : G) (f : G →* H) : f (x * y) = f x * f y := f.map_mul x y -- QUOTE.</p> <p>/- TEXT: Of course we do get some new properties, such as this one: EXAMPLES: -/ -- QUOTE: example {G H : Type*} [Group G] [Group H] (x : G) (f : G →* H) : f (x⁻¹) = (f x)⁻¹ := f.map_inv x -- QUOTE.</p> <p>/- TEXT: You may be worried that constructing group morphisms will require us to do unnecessary work since the definition of monoid morphism enforces that neutral elements are sent to neutral elements while this is automatic in the case of group morphisms. In practice the extra work is not hard, but, to avoid it, there is a function building a group morphism from a function between groups that is compatible with the composition laws. EXAMPLES: -/ -- QUOTE: example {G H : Type*} [Group G] [Group H] (f : G → H) (h : ∀ x y, f (x * y) = f x * f y) : G →* H := MonoidHom.mk' f h -- QUOTE.</p> <p>/- TEXT: There is also a type <code>MulEquiv</code> of group (or monoid) isomorphisms denoted by <code>≃*</code> (and <code>AddEquiv</code> denoted by <code>≃+</code> in additive notation). The inverse of <code>f : G ≃* H</code> is <code>MulEquiv.symm f : H ≃* G</code>, composition of <code>f</code> and <code>g</code> is <code>MulEquiv.trans f g</code>, and the identity isomorphism of <code>G</code> is <code>M̀ulEquiv.refl G</code>. Using anonymous projector notation, the first two can be written <code>f.symm</code> and <code>f.trans g</code> respectively. Elements of this type are automatically coerced to morphisms and functions when necessary. EXAMPLES: -/ -- QUOTE: example {G H : Type*} [Group G] [Group H] (f : G ≃* H) : f.trans f.symm = MulEquiv.refl G := f.self_trans_symm -- QUOTE.</p> <p>/- TEXT: One can use <code>MulEquiv.ofBijective</code> to build an isomorphism from a bijective morphism. Doing so makes the inverse function noncomputable. EXAMPLES: -/ -- QUOTE: noncomputable example {G H : Type*} [Group G] [Group H] (f : G →* H) (h : Function.Bijective f) : G ≃* H := MulEquiv.ofBijective f h -- QUOTE.</p> <p>/- TEXT: Subgroups <sup>^</sup><sup>^</sup><sup>^</sup></p> <p>Just as group morphisms are bundled, a subgroup of <code>G</code> is also a bundled structure consisting of a set in <code>G</code> with the relevant closure properties. EXAMPLES: -/ -- QUOTE: example {G : Type*} [Group G] (H : Subgroup G) {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x * y ∈ H := H.mul_mem hx hy</p> <p>example {G : Type*} [Group G] (H : Subgroup G) {x : G} (hx : x ∈ H) : x⁻¹ ∈ H := H.inv_mem hx -- QUOTE.</p> <p>/- TEXT: In the example above, it is important to understand that <code>Subgroup G</code> is the type of subgroups of <code>G</code>, rather than a predicate <code>IsSubgroup H</code> where <code>H</code> is an element of <code>Set G</code>. <code>Subgroup G</code> is endowed with a coercion to <code>Set G</code> and a membership predicate on <code>G</code>. See :numref:<code>section_hierarchies_subobjects</code> for an explanation of how and why this is done.</p> <p>Of course, two subgroups are the same if and only if they have the same elements. This fact is registered for use with the <code>ext</code> tactic, which can be used to prove two subgroups are equal in the same way it is used to prove that two sets are equal.</p> <p>To state and prove, for example, that <code>ℤ</code> is an additive subgroup of <code>ℚ</code>, what we really want is to construct a term of type <code>AddSubgroup ℚ</code> whose projection to <code>Set ℚ</code> is <code>ℤ</code>, or, more precisely, the image of <code>ℤ</code> in <code>ℚ</code>. EXAMPLES: -/ -- QUOTE: example : AddSubgroup ℚ where carrier := Set.range ((↑) : ℤ → ℚ) add_mem' := by rintro _ _ ⟨n, rfl⟩ ⟨m, rfl⟩ use n + m simp zero_mem' := by use 0 simp neg_mem' := by rintro _ ⟨n, rfl⟩ use -n simp -- QUOTE.</p> <p>/- TEXT: Using type classes, Mathlib knows that a subgroup of a group inherits a group structure. EXAMPLES: -/ -- QUOTE: example {G : Type*} [Group G] (H : Subgroup G) : Group H := inferInstance -- QUOTE.</p> <p>/- TEXT: This example is subtle. The object <code>H</code> is not a type, but Lean automatically coerces it to a type by interpreting it as a subtype of <code>G</code>. So the above example can be restated more explicitly as: EXAMPLES: -/ -- QUOTE: example {G : Type*} [Group G] (H : Subgroup G) : Group {x : G // x ∈ H} := inferInstance -- QUOTE.</p> <p>/- TEXT: An important benefit of having a type <code>Subgroup G</code> instead of a predicate <code>IsSubgroup : Set G → Prop</code> is that one can easily endow <code>Subgroup G</code> with additional structure. Importantly, it has the structure of a complete lattice structure with respect to inclusion. For instance, instead of having a lemma stating that an intersection of two subgroups of <code>G</code> is again a subgroup, we have used the lattice operation <code>⊓</code> to construct the intersection. We can then apply arbitrary lemmas about lattices to the construction.</p> <p>Let us check that the set underlying the infimum of two subgroups is indeed, by definition, their intersection. EXAMPLES: -/ -- QUOTE: example {G : Type*} [Group G] (H H' : Subgroup G) : ((H ⊓ H' : Subgroup G) : Set G) = (H : Set G) ∩ (H' : Set G) := rfl -- QUOTE.</p> <p>/- TEXT: It may look strange to have a different notation for what amounts to the intersection of the underlying sets, but the correspondence does not carry over to the supremum operation and set union, since a union of subgroups is not, in general, a subgroup. Instead one needs to use the subgroup generated by the union, which is done using <code>Subgroup.closure</code>. EXAMPLES: -/ -- QUOTE: example {G : Type*} [Group G] (H H' : Subgroup G) : ((H ⊔ H' : Subgroup G) : Set G) = Subgroup.closure ((H : Set G) ∪ (H' : Set G)) := by rw [Subgroup.sup_eq_closure] -- QUOTE.</p> <p>/- TEXT: Another subtlety is that <code>G</code> itself does not have type <code>Subgroup G</code>, so we need a way to talk about <code>G</code> seen as a subgroup of <code>G</code>. This is also provided by the lattice structure: the full subgroup is the top element of this lattice. EXAMPLES: -/ -- QUOTE: example {G : Type*} [Group G] (x : G) : x ∈ (⊤ : Subgroup G) := trivial -- QUOTE.</p> <p>/- TEXT: Similarly the bottom element of this lattice is the subgroup whose only element is the neutral element. EXAMPLES: -/ -- QUOTE: example {G : Type*} [Group G] (x : G) : x ∈ (⊥ : Subgroup G) ↔ x = 1 := Subgroup.mem_bot -- QUOTE.</p> <p>/- TEXT: As an exercise in manipulating groups and subgroups, you can define the conjugate of a subgroup by an element of the ambient group. BOTH: -/ -- QUOTE: def conjugate {G : Type*} [Group G] (x : G) (H : Subgroup G) : Subgroup G where carrier := {a : G | ∃ h, h ∈ H ∧ a = x * h * x⁻¹} one_mem' := by /- EXAMPLES: dsimp sorry SOLUTIONS: -/ dsimp use 1 constructor exact H.one_mem group -- BOTH: inv_mem' := by /- EXAMPLES: dsimp sorry SOLUTIONS: -/ dsimp rintro - ⟨h, h_in, rfl⟩ use h⁻¹, H.inv_mem h_in group -- BOTH: mul_mem' := by /- EXAMPLES: dsimp sorry SOLUTIONS: -/ dsimp rintro - - ⟨h, h_in, rfl⟩ ⟨k, k_in, rfl⟩ use h*k, H.mul_mem h_in k_in group -- BOTH: -- QUOTE.</p> <p>/- TEXT: Tying the previous two topics together, one can push forward and pull back subgroups using group morphisms. The naming convention in Mathlib is to call those operations <code>map</code> and <code>comap</code>. These are not the common mathematical terms, but they have the advantage of being shorter than "pushforward" and "direct image." EXAMPLES: -/ -- QUOTE: example {G H : Type*} [Group G] [Group H] (G' : Subgroup G) (f : G →* H) : Subgroup H := Subgroup.map f G'</p> <p>example {G H : Type*} [Group G] [Group H] (H' : Subgroup H) (f : G →* H) : Subgroup G := Subgroup.comap f H'</p> <h1 id=check-subgroupmem_map>check Subgroup.mem_map<a class=headerlink href=#check-subgroupmem_map title="Permanent link">&para;</a></h1> <h1 id=check-subgroupmem_comap>check Subgroup.mem_comap<a class=headerlink href=#check-subgroupmem_comap title="Permanent link">&para;</a></h1> <p>-- QUOTE.</p> <p>/- TEXT: In particular, the preimage of the bottom subgroup under a morphism <code>f</code> is a subgroup called the <em>kernel</em> of <code>f</code>, and the range of <code>f</code> is also a subgroup. EXAMPLES: -/ -- QUOTE: example {G H : Type*} [Group G] [Group H] (f : G →* H) (g : G) : g ∈ MonoidHom.ker f ↔ f g = 1 := f.mem_ker</p> <p>example {G H : Type*} [Group G] [Group H] (f : G →* H) (h : H) : h ∈ MonoidHom.range f ↔ ∃ g : G, f g = h := f.mem_range -- QUOTE.</p> <p>/- TEXT: As exercises in manipulating group morphisms and subgroups, let us prove some elementary properties. They are already proved in Mathlib, so do not use <code>exact?</code> too quickly if you want to benefit from these exercises. BOTH: -/ -- QUOTE: section exercises variable {G H : Type*} [Group G] [Group H]</p> <p>open Subgroup</p> <p>example (φ : G →* H) (S T : Subgroup H) (hST : S ≤ T) : comap φ S ≤ comap φ T := by /- EXAMPLES: sorry SOLUTIONS: -/ intro x hx rw [mem_comap] at * -- Lean does not need this line exact hST hx -- BOTH:</p> <p>example (φ : G →* H) (S T : Subgroup G) (hST : S ≤ T) : map φ S ≤ map φ T := by /- EXAMPLES: sorry SOLUTIONS: -/ intro x hx rw [mem_map] at * -- Lean does not need this line rcases hx with ⟨y, hy, rfl⟩ use y, hST hy -- BOTH:</p> <p>variable {K : Type*} [Group K]</p> <p>-- Remember you can use the <code>ext</code> tactic to prove an equality of subgroups. example (φ : G →* H) (ψ : H →* K) (U : Subgroup K) : comap (ψ.comp φ) U = comap φ (comap ψ U) := by /- EXAMPLES: sorry SOLUTIONS: -/ -- The whole proof could be <code>rfl</code>, but let's decompose it a bit. ext x simp only [mem_comap] rfl -- BOTH:</p> <p>-- Pushing a subgroup along one homomorphism and then another is equal to -- pushing it forward along the composite of the homomorphisms. example (φ : G →* H) (ψ : H →* K) (S : Subgroup G) : map (ψ.comp φ) S = map ψ (S.map φ) := by /- EXAMPLES: sorry SOLUTIONS: -/ ext x simp only [mem_map] constructor · rintro ⟨y, y_in, hy⟩ exact ⟨φ y, ⟨y, y_in, rfl⟩, hy⟩ · rintro ⟨y, ⟨z, z_in, hz⟩, hy⟩ use z, z_in calc ψ.comp φ z = ψ (φ z) := rfl _ = ψ y := by congr _ = x := hy -- BOTH:</p> <p>end exercises -- QUOTE.</p> <p>/- TEXT: Let us finish this introduction to subgroups in Mathlib with two very classical results. Lagrange theorem states the cardinality of a subgroup of a finite group divides the cardinality of the group. Sylow's first theorem is a famous partial converse to Lagrange's theorem.</p> <p>While this corner of Mathlib is partly set up to allow computation, we can tell Lean to use nonconstructive logic anyway using the following <code>open scoped</code> command. BOTH: -/ -- QUOTE: open scoped Classical</p> <p>-- EXAMPLES:</p> <p>example {G : Type*} [Group G] (G' : Subgroup G) : Nat.card G' ∣ Nat.card G := ⟨G'.index, mul_comm G'.index _ ▸ G'.index_mul_card.symm⟩</p> <p>-- BOTH: open Subgroup</p> <p>-- EXAMPLES: example {G : Type*} [Group G] [Finite G] (p : ℕ) {n : ℕ} [Fact p.Prime] (hdvd : p ^ n ∣ Nat.card G) : ∃ K : Subgroup G, Nat.card K = p ^ n := Sylow.exists_subgroup_card_pow_prime p hdvd -- QUOTE.</p> <p>/- TEXT: The next two exercises derive a corollary of Lagrange's lemma. (This is also already in Mathlib, so do not use <code>exact?</code> too quickly.) BOTH: -/ -- QUOTE: lemma eq_bot_iff_card {G : Type*} [Group G] {H : Subgroup G} : H = ⊥ ↔ Nat.card H = 1 := by suffices (∀ x ∈ H, x = 1) ↔ ∃ x ∈ H, ∀ a ∈ H, a = x by simpa [eq_bot_iff_forall, Nat.card_eq_one_iff_exists] /- EXAMPLES: sorry SOLUTIONS: -/ constructor · intro h use 1, H.one_mem · rintro ⟨y, -, hy'⟩ x hx calc x = y := hy' x hx _ = 1 := (hy' 1 H.one_mem).symm -- EXAMPLES:</p> <h1 id=check-card_dvd_of_le>check card_dvd_of_le<a class=headerlink href=#check-card_dvd_of_le title="Permanent link">&para;</a></h1> <p>-- BOTH:</p> <p>lemma inf_bot_of_coprime {G : Type*} [Group G] (H K : Subgroup G) (h : (Nat.card H).Coprime (Nat.card K)) : H ⊓ K = ⊥ := by /- EXAMPLES: sorry SOLUTIONS: -/ have D₁ : Nat.card (H ⊓ K : Subgroup G) ∣ Nat.card H := card_dvd_of_le inf_le_left have D₂ : Nat.card (H ⊓ K : Subgroup G) ∣ Nat.card K := card_dvd_of_le inf_le_right exact eq_bot_iff_card.2 (Nat.eq_one_of_dvd_coprimes h D₁ D₂) -- QUOTE.</p> <p>/- TEXT: Concrete groups <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup></p> <p>One can also manipulate concrete groups in Mathlib, although this is typically more complicated than working with the abstract theory. For instance, given any type <code>X</code>, the group of permutations of <code>X</code> is <code>Equiv.Perm X</code>. In particular the symmetric group :math:<code>\mathfrak{S}_n</code> is <code>Equiv.Perm (Fin n)</code>. One can state abstract results about this group, for instance saying that <code>Equiv.Perm X</code> is generated by cycles if <code>X</code> is finite. EXAMPLES: -/ -- QUOTE: open Equiv</p> <p>example {X : Type*} [Finite X] : Subgroup.closure {σ : Perm X | Perm.IsCycle σ} = ⊤ := Perm.closure_isCycle -- QUOTE.</p> <p>/- TEXT: One can be fully concrete and compute actual products of cycles. Below we use the <code>#simp</code> command, which calls the <code>simp</code> tactic on a given expression. The notation <code>c[]</code> is used to define a cyclic permutation. In the example, the result is a permutation of <code>ℕ</code>. One could use a type ascription such as <code>(1 : Fin 5)</code> on the first number appearing to make it a computation in <code>Perm (Fin 5)</code>. EXAMPLES: -/ -- QUOTE:</p> <h1 id=simp-mul_assoc-c1-2-3-c2-3-4>simp [mul_assoc] c[1, 2, 3] * c[2, 3, 4]<a class=headerlink href=#simp-mul_assoc-c1-2-3-c2-3-4 title="Permanent link">&para;</a></h1> <p>-- QUOTE.</p> <p>/- TEXT: Another way to work with concrete groups is to use free groups and group presentations. The free group on a type <code>α</code> is <code>FreeGroup α</code> and the inclusion map is <code>FreeGroup.of : α → FreeGroup α</code>. For instance let us define a type <code>S</code> with three elements denoted by <code>a</code>, <code>b</code> and <code>c</code>, and the element <code>ab⁻¹</code> of the corresponding free group. EXAMPLES: -/ -- QUOTE: section FreeGroup</p> <p>inductive S | a | b | c</p> <p>open S</p> <p>def myElement : FreeGroup S := (.of a) * (.of b)⁻¹ -- QUOTE.</p> <p>/- TEXT: Note that we gave the expected type of the definition so that Lean knows that <code>.of</code> means <code>FreeGroup.of</code>.</p> <p>The universal property of free groups is embodied as the equivalence <code>FreeGroup.lift</code>. For example, let us define the group morphism from <code>FreeGroup S</code> to <code>Perm (Fin 5)</code> that sends <code>a</code> to <code>c[1, 2, 3]</code>, <code>b</code> to <code>c[2, 3, 1]</code>, and <code>c</code> to <code>c[2, 3]</code>, EXAMPLES: -/ -- QUOTE: def myMorphism : FreeGroup S →* Perm (Fin 5) := FreeGroup.lift fun | .a =&gt; c[1, 2, 3] | .b =&gt; c[2, 3, 1] | .c =&gt; c[2, 3]</p> <p>-- QUOTE.</p> <p>/- TEXT: As a last concrete example, let us see how to define a group generated by a single element whose cube is one (so that group will be isomorphic to :math:<code>\mathbb{Z}/3</code>) and build a morphism from that group to <code>Perm (Fin 5)</code>.</p> <p>As a type with exactly one element, we will use <code>Unit</code> whose only element is denoted by <code>()</code>. The function <code>PresentedGroup</code> takes a set of relations, i.e. a set of elements of some free group, and returns a group that is this free group quotiented by a normal subgroup generated by relations. (We will see how to handle more general quotients in :numref:<code>quotient_groups</code>.) Since we somehow hide this behind a definition, we use <code>deriving Group</code> to force creation of a group instance on <code>myGroup</code>. EXAMPLES: -/ -- QUOTE: def myGroup := PresentedGroup {.of () ^ 3} deriving Group -- QUOTE.</p> <p>/- TEXT: The universal property of presented groups ensures that morphisms out of this group can be built from functions that send the relations to the neutral element of the target group. So we need such a function and a proof that the condition holds. Then we can feed this proof to <code>PresentedGroup.toGroup</code> to get the desired group morphism. EXAMPLES: -/ -- QUOTE: def myMap : Unit → Perm (Fin 5) | () =&gt; c[1, 2, 3]</p> <p>lemma compat_myMap : ∀ r ∈ ({.of () ^ 3} : Set (FreeGroup Unit)), FreeGroup.lift myMap r = 1 := by rintro _ rfl simp decide</p> <p>def myNewMorphism : myGroup →* Perm (Fin 5) := PresentedGroup.toGroup compat_myMap</p> <p>end FreeGroup -- QUOTE.</p> <p>/- TEXT: Group actions <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup>^</p> <p>One important way that group theory interacts with the rest of mathematics is through the use of group actions. An action of a group <code>G</code> on some type <code>X</code> is nothing more than a morphism from <code>G</code> to <code>Equiv.Perm X</code>. So in a sense group actions are already covered by the previous discussion. But we don't want to carry this morphism around; instead, we want it to be inferred automatically by Lean as much as possible. So we have a type class for this, which is <code>MulAction G X</code>. The downside of this setup is that having multiple actions of the same group on the same type requires some contortions, such as defining type synonyms, each of which carries different type class instances.</p> <p>This allows us in particular to use <code>g • x</code> to denote the action of a group element <code>g</code> on a point <code>x</code>. BOTH: -/ -- QUOTE: noncomputable section GroupActions</p> <p>-- EXAMPLES: example {G X : Type*} [Group G] [MulAction G X] (g g': G) (x : X) : g • (g' • x) = (g * g') • x := (mul_smul g g' x).symm -- QUOTE.</p> <p>/- TEXT: There is also a version for additive group called <code>AddAction</code>, where the action is denoted by <code>+ᵥ</code>. This is used for instance in the definition of affine spaces. EXAMPLES: -/ -- QUOTE: example {G X : Type*} [AddGroup G] [AddAction G X] (g g' : G) (x : X) : g +ᵥ (g' +ᵥ x) = (g + g') +ᵥ x := (add_vadd g g' x).symm -- QUOTE.</p> <p>/- TEXT: The underlying group morphism is called <code>MulAction.toPermHom</code>. EXAMPLES: -/ -- QUOTE: open MulAction</p> <p>example {G X : Type*} [Group G] [MulAction G X] : G →* Equiv.Perm X := toPermHom G X -- QUOTE.</p> <p>/- TEXT: As an illustration let us see how to define the Cayley isomorphism embedding of any group <code>G</code> into a permutation group, namely <code>Perm G</code>. EXAMPLES: -/ -- QUOTE: def CayleyIsoMorphism (G : Type*) [Group G] : G ≃* (toPermHom G G).range := Equiv.Perm.subgroupOfMulAction G G -- QUOTE.</p> <p>/- TEXT: Note that nothing before the above definition required having a group rather than a monoid (or any type endowed with a multiplication operation really).</p> <p>The group condition really enters the picture when we will want to partition <code>X</code> into orbits. The corresponding equivalence relation on <code>X</code> is called <code>MulAction.orbitRel</code>. It is not declared as a global instance. EXAMPLES: -/ /- OMIT: TODO: We need to explain <code>Setoid</code> somewhere. EXAMPLES. -/ -- QUOTE: example {G X : Type*} [Group G] [MulAction G X] : Setoid X := orbitRel G X -- QUOTE.</p> <p>/- TEXT: Using this we can state that <code>X</code> is partitioned into orbits under the action of <code>G</code>. More precisely, we get a bijection between <code>X</code> and the dependent product <code>(ω : orbitRel.Quotient G X) × (orbit G (Quotient.out' ω))</code> where <code>Quotient.out' ω</code> simply chooses an element that projects to <code>ω</code>. Recall that elements of this dependent product are pairs <code>⟨ω, x⟩</code> where the type <code>orbit G (Quotient.out' ω)</code> of <code>x</code> depends on <code>ω</code>. EXAMPLES: -/ -- QUOTE: example {G X : Type*} [Group G] [MulAction G X] : X ≃ (ω : orbitRel.Quotient G X) × (orbit G (Quotient.out' ω)) := MulAction.selfEquivSigmaOrbits G X -- QUOTE.</p> <p>/- TEXT: In particular, when X is finite, this can be combined with <code>Fintype.card_congr</code> and <code>Fintype.card_sigma</code> to deduce that the cardinality of <code>X</code> is the sum of the cardinalities of the orbits. Furthermore, the orbits are in bijection with the quotient of <code>G</code> under the action of the stabilizers by left translation. This action of a subgroup by left-translation is used to define quotients of a group by a subgroup with notation <code>/</code> so we can use the following concise statement. EXAMPLES: -/ -- QUOTE: example {G X : Type*} [Group G] [MulAction G X] (x : X) : orbit G x ≃ G ⧸ stabilizer G x := MulAction.orbitEquivQuotientStabilizer G x -- QUOTE.</p> <p>/- TEXT: An important special case of combining the above two results is when <code>X</code> is a group <code>G</code> equipped with the action of a subgroup <code>H</code> by translation. In this case all stabilizers are trivial so every orbit is in bijection with <code>H</code> and we get: EXAMPLES: -/ -- QUOTE: example {G : Type*} [Group G] (H : Subgroup G) : G ≃ (G ⧸ H) × H := groupEquivQuotientProdSubgroup -- QUOTE.</p> <p>/- TEXT: This is the conceptual variant of the version of Lagrange theorem that we saw above. Note this version makes no finiteness assumption.</p> <p>As an exercise for this section, let us build the action of a group on its subgroup by conjugation, using our definition of <code>conjugate</code> from a previous exercise. BOTH: -/ -- QUOTE: variable {G : Type*} [Group G]</p> <p>lemma conjugate_one (H : Subgroup G) : conjugate 1 H = H := by /- EXAMPLES: sorry SOLUTIONS: -/ ext x simp [conjugate] -- BOTH:</p> <p>instance : MulAction G (Subgroup G) where smul := conjugate one_smul := by /- EXAMPLES: sorry SOLUTIONS: -/ exact conjugate_one -- BOTH: mul_smul := by /- EXAMPLES: sorry SOLUTIONS: -/ intro x y H ext z constructor · rintro ⟨h, h_in, rfl⟩ use y*h*y⁻¹ constructor · use h · group · rintro ⟨-, ⟨h, h_in, rfl⟩, rfl⟩ use h, h_in group -- BOTH:</p> <p>end GroupActions -- QUOTE.</p> <p>/- TEXT: .. _quotient_groups:</p> <p>Quotient groups <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup></p> <p>In the above discussion of subgroups acting on groups, we saw the quotient <code>G ⧸ H</code> appear. In general this is only a type. It can be endowed with a group structure such that the quotient map is a group morphism if and only if <code>H</code> is a normal subgroup (and this group structure is then unique).</p> <p>The normality assumption is a type class <code>Subgroup.Normal</code> so that type class inference can use it to derive the group structure on the quotient. BOTH: -/ -- QUOTE: noncomputable section QuotientGroup</p> <p>-- EXAMPLES: example {G : Type*} [Group G] (H : Subgroup G) [H.Normal] : Group (G ⧸ H) := inferInstance</p> <p>example {G : Type*} [Group G] (H : Subgroup G) [H.Normal] : G →* G ⧸ H := QuotientGroup.mk' H -- QUOTE.</p> <p>/- TEXT: The universal property of quotient groups is accessed through <code>QuotientGroup.lift</code>: a group morphism <code>φ</code> descends to <code>G ⧸ N</code> as soon as its kernel contains <code>N</code>. EXAMPLES: -/ -- QUOTE: example {G : Type*} [Group G] (N : Subgroup G) [N.Normal] {M : Type*} [Group M] (φ : G →* M) (h : N ≤ MonoidHom.ker φ) : G ⧸ N →* M := QuotientGroup.lift N φ h -- QUOTE.</p> <p>/- TEXT: The fact that the target group is called <code>M</code> is the above snippet is a clue that having a monoid structure on <code>M</code> would be enough.</p> <p>An important special case is when <code>N = ker φ</code>. In that case the descended morphism is injective and we get a group isomorphism onto its image. This result is often called the first isomorphism theorem. EXAMPLES: -/ -- QUOTE: example {G : Type*} [Group G] {M : Type*} [Group M] (φ : G →* M) : G ⧸ MonoidHom.ker φ →* MonoidHom.range φ := QuotientGroup.quotientKerEquivRange φ -- QUOTE.</p> <p>/- TEXT: Applying the universal property to a composition of a morphism <code>φ : G →* G'</code> with a quotient group projection <code>Quotient.mk' N'</code>, we can also aim for a morphism from <code>G ⧸ N</code> to <code>G' ⧸ N'</code>. The condition required on <code>φ</code> is usually formulated by saying "<code>φ</code> should send <code>N</code> inside <code>N'</code>." But this is equivalent to asking that <code>φ</code> should pull <code>N'</code> back inside <code>N</code>, and the latter condition is nicer to work with since the definition of pullback does not involve an existential quantifier. EXAMPLES: -/ -- QUOTE: example {G G': Type*} [Group G] [Group G'] {N : Subgroup G} [N.Normal] {N' : Subgroup G'} [N'.Normal] {φ : G →* G'} (h : N ≤ Subgroup.comap φ N') : G ⧸ N →* G' ⧸ N':= QuotientGroup.map N N' φ h -- QUOTE.</p> <p>/- TEXT: One subtle point to keep in mind is that the type <code>G ⧸ N</code> really depends on <code>N</code> (up to definitional equality), so having a proof that two normal subgroups <code>N</code> and <code>M</code> are equal is not enough to make the corresponding quotients equal. However the universal properties does give an isomorphism in this case. EXAMPLES: -/ -- QUOTE: example {G : Type*} [Group G] {M N : Subgroup G} [M.Normal] [N.Normal] (h : M = N) : G ⧸ M ≃* G ⧸ N := QuotientGroup.quotientMulEquivOfEq h -- QUOTE.</p> <p>/- TEXT: As a final series of exercises for this section, we will prove that if <code>H</code> and <code>K</code> are disjoint normal subgroups of a finite group <code>G</code> such that the product of their cardinalities is equal to the cardinality of <code>G</code> then <code>G</code> is isomorphic to <code>H × K</code>. Recall that disjoint in this context means <code>H ⊓ K = ⊥</code>.</p> <p>We start with playing a bit with Lagrange's lemma, without assuming the subgroups are normal or disjoint. BOTH: -/ -- QUOTE: section variable {G : Type*} [Group G] {H K : Subgroup G}</p> <p>open MonoidHom</p> <h1 id=check-natcard_pos-the-nonempty-argument-will-be-automatically-inferred-for-subgroups>check Nat.card_pos -- The nonempty argument will be automatically inferred for subgroups<a class=headerlink href=#check-natcard_pos-the-nonempty-argument-will-be-automatically-inferred-for-subgroups title="Permanent link">&para;</a></h1> <h1 id=check-subgroupindex_eq_card>check Subgroup.index_eq_card<a class=headerlink href=#check-subgroupindex_eq_card title="Permanent link">&para;</a></h1> <h1 id=check-subgroupindex_mul_card>check Subgroup.index_mul_card<a class=headerlink href=#check-subgroupindex_mul_card title="Permanent link">&para;</a></h1> <h1 id=check-nateq_of_mul_eq_mul_right>check Nat.eq_of_mul_eq_mul_right<a class=headerlink href=#check-nateq_of_mul_eq_mul_right title="Permanent link">&para;</a></h1> <p>lemma aux_card_eq [Finite G] (h' : Nat.card G = Nat.card H * Nat.card K) : Nat.card (G ⧸ H) = Nat.card K := by /- EXAMPLES: sorry SOLUTIONS: -/ have := calc Nat.card (G ⧸ H) * Nat.card H = Nat.card G := by rw [← H.index_eq_card, H.index_mul_card] _ = Nat.card K * Nat.card H := by rw [h', mul_comm]</p> <p>exact Nat.eq_of_mul_eq_mul_right Nat.card_pos this -- QUOTE.</p> <p>/- TEXT: From now on, we assume that our subgroups are normal and disjoint, and we assume the cardinality condition. Now we construct the first building block of the desired isomorphism. BOTH: -/ -- QUOTE: variable [H.Normal][K.Normal] [Fintype G] (h : Disjoint H K) (h' : Nat.card G = Nat.card H * Nat.card K)</p> <h1 id=check-natbijective_iff_injective_and_card>check Nat.bijective_iff_injective_and_card<a class=headerlink href=#check-natbijective_iff_injective_and_card title="Permanent link">&para;</a></h1> <h1 id=check-ker_eq_bot_iff>check ker_eq_bot_iff<a class=headerlink href=#check-ker_eq_bot_iff title="Permanent link">&para;</a></h1> <h1 id=check-restrict>check restrict<a class=headerlink href=#check-restrict title="Permanent link">&para;</a></h1> <h1 id=check-ker_restrict>check ker_restrict<a class=headerlink href=#check-ker_restrict title="Permanent link">&para;</a></h1> <p>def iso₁ [Fintype G] (h : Disjoint H K) (h' : Nat.card G = Nat.card H * Nat.card K) : K ≃* G ⧸ H := by /- EXAMPLES: sorry SOLUTIONS: -/ apply MulEquiv.ofBijective ((QuotientGroup.mk' H).restrict K) rw [Nat.bijective_iff_injective_and_card] constructor · rw [← ker_eq_bot_iff, (QuotientGroup.mk' H).ker_restrict K] simp [h] · symm exact aux_card_eq h' -- QUOTE.</p> <p>/- TEXT: Now we can define our second building block. We will need <code>MonoidHom.prod</code>, which builds a morphism from <code>G₀</code> to <code>G₁ × G₂</code> out of morphisms from <code>G₀</code> to <code>G₁</code> and <code>G₂</code>. BOTH: -/ -- QUOTE: def iso₂ : G ≃* (G ⧸ K) × (G ⧸ H) := by /- EXAMPLES: sorry SOLUTIONS: -/ apply MulEquiv.ofBijective &lt;| (QuotientGroup.mk' K).prod (QuotientGroup.mk' H) rw [Nat.bijective_iff_injective_and_card] constructor · rw [← ker_eq_bot_iff, ker_prod] simp [h.symm.eq_bot] · rw [Nat.card_prod] rw [aux_card_eq h', aux_card_eq (mul_comm (Nat.card H) _▸ h'), h'] -- QUOTE.</p> <p>/- TEXT: We are ready to put all pieces together. EXAMPLES: -/ -- QUOTE:</p> <h1 id=check-mulequivprodcongr>check MulEquiv.prodCongr<a class=headerlink href=#check-mulequivprodcongr title="Permanent link">&para;</a></h1> <p>-- BOTH: def finalIso : G ≃* H × K := /- EXAMPLES: sorry SOLUTIONS: -/ (iso₂ h h').trans ((iso₁ h.symm (mul_comm (Nat.card H) _ ▸ h')).prodCongr (iso₁ h h')).symm</p> <p>end end QuotientGroup -- QUOTE.</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.sections", "navigation.instant", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"alias": true, "default": "latest", "provider": "mike"}}</script> <script src=../../../assets/javascripts/bundle.fe8b6f2b.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>